<html>
<head>
<title>EAGLE Help Version 7.2.0</title>
<style type="text/css"><!-- h1 { background-color: #CCCCCC; color: #0050B0; } pre { background-color: #EEEEEE; } mb { font-weight: bold; font-family: courier; background-color: #EEEEEE; }--></style>
</head>
<body>
<table width=100% cellspacing=0 border=0><tr>
<td align=left>EAGLE Help Version 7.2.0</td>
<td align=right><font size=-1>
<i>Copyright &copy; 2014 CadSoft Computer GmbH</i>
</font></td></tr></table>

<h1>Index</h1>
<ul>
<li><a href=#1>Erkl&auml;rung der Hilfe-Funktion</a>
<li><a href=#2>EAGLE konfigurieren</a>
<li><a href=#3>Kommandozeilen-Optionen</a>
<li><a href=#4>Schnelle Einf&uuml;hrung</a>
<ul>
<li><a href=#5>Control Panel und Editor-Fenster</a>
<li><a href=#6>Eingabe von Parametern und Werten</a>
<li><a href=#7>Schaltplan entwerfen</a>
<li><a href=#8>Hierarchischen Schaltplan entwerfen</a>
<li><a href=#9>Schaltplan &uuml;berpr&uuml;fen</a>
<li><a href=#10>Platine aus Schaltplan erzeugen</a>
<li><a href=#11>Layout &uuml;berpr&uuml;fen</a>
<li><a href=#12>Bauelement in Bibliothek definieren</a>
</ul>
<li><a href=#13>Control Panel</a>
<ul>
<li><a href=#14>Kontext-Men&uuml;s</a>
<li><a href=#15>Verzeichnisse</a>
<li><a href=#16>Datensicherung</a>
<li><a href=#17>Benutzeroberfl&auml;che</a>
<li><a href=#18>Fensterpositionen</a>
<li><a href=#19>Auf Update pr&uuml;fen</a>
</ul>
<li><a href=#20>Tastatur und Maus</a>
<ul>
<li><a href=#21>Benachbarte Objekte selektieren</a>
</ul>
<li><a href=#22>Editor-Fenster</a>
<ul>
<li><a href=#23>Bibliotheks-Editor</a>
<ul>
<li><a href=#24>Bibliotheks-Editier-Modus</a>
</ul>
<li><a href=#25>Layout-Editor</a>
<li><a href=#26>Schaltplan-Editor</a>
<li><a href=#27>Text-Editor</a>
</ul>
<li><a href=#28>Editor-Befehle</a>
<ul>
<li><a href=#29>Befehlseingabe</a>
<li><a href=#30>ADD</a>
<li><a href=#31>ARC</a>
<li><a href=#32>ASSIGN</a>
<li><a href=#33>ATTRIBUTE</a>
<li><a href=#34>AUTO</a>
<li><a href=#35>BOARD</a>
<li><a href=#36>BUS</a>
<li><a href=#37>CHANGE</a>
<li><a href=#38>CIRCLE</a>
<li><a href=#39>CLASS</a>
<li><a href=#40>CLOSE</a>
<li><a href=#41>CONNECT</a>
<li><a href=#42>COPY</a>
<li><a href=#43>CUT</a>
<li><a href=#44>DELETE</a>
<li><a href=#45>DESCRIPTION</a>
<li><a href=#46>DIMENSION</a>
<li><a href=#47>DISPLAY</a>
<li><a href=#48>DRC</a>
<li><a href=#49>EDIT</a>
<li><a href=#50>ERC</a>
<li><a href=#51>ERRORS</a>
<li><a href=#52>EXPORT</a>
<li><a href=#53>FRAME</a>
<li><a href=#54>GATESWAP</a>
<li><a href=#55>GRID</a>
<li><a href=#56>GROUP</a>
<li><a href=#57>HELP</a>
<li><a href=#58>HOLE</a>
<li><a href=#59>INFO</a>
<li><a href=#60>INVOKE</a>
<li><a href=#61>JUNCTION</a>
<li><a href=#62>LABEL</a>
<li><a href=#63>LAYER</a>
<li><a href=#64>LOCK</a>
<li><a href=#65>MARK</a>
<li><a href=#66>MEANDER</a>
<li><a href=#67>MENU</a>
<li><a href=#68>MIRROR</a>
<li><a href=#69>MITER</a>
<li><a href=#70>MODULE</a>
<li><a href=#71>MOVE</a>
<li><a href=#72>NAME</a>
<li><a href=#73>NET</a>
<li><a href=#74>OPEN</a>
<li><a href=#75>OPTIMIZE</a>
<li><a href=#76>PACKAGE</a>
<li><a href=#77>PAD</a>
<li><a href=#78>PASTE</a>
<li><a href=#79>PIN</a>
<li><a href=#80>PINSWAP</a>
<li><a href=#81>POLYGON</a>
<li><a href=#82>PORT</a>
<li><a href=#83>PREFIX</a>
<li><a href=#84>PRINT</a>
<li><a href=#85>QUIT</a>
<li><a href=#86>RATSNEST</a>
<li><a href=#87>RECT</a>
<li><a href=#88>REDO</a>
<li><a href=#89>REMOVE</a>
<li><a href=#90>RENAME</a>
<li><a href=#91>REPLACE</a>
<li><a href=#92>RIPUP</a>
<li><a href=#93>ROTATE</a>
<li><a href=#94>ROUTE</a>
<li><a href=#95>RUN</a>
<li><a href=#96>SCRIPT</a>
<li><a href=#97>SET</a>
<li><a href=#98>SHOW</a>
<li><a href=#99>SIGNAL</a>
<li><a href=#100>SMASH</a>
<li><a href=#101>SMD</a>
<li><a href=#102>SPLIT</a>
<li><a href=#103>TECHNOLOGY</a>
<li><a href=#104>TEXT</a>
<li><a href=#105>UNDO</a>
<li><a href=#106>UPDATE</a>
<li><a href=#107>USE</a>
<li><a href=#108>VALUE</a>
<li><a href=#109>VARIANT</a>
<li><a href=#110>VIA</a>
<li><a href=#111>WINDOW</a>
<li><a href=#112>WIRE</a>
<li><a href=#113>WRITE</a>
</ul>
<li><a href=#114>Ausgabedaten erzeugen</a>
<ul>
<li><a href=#115>Drucken</a>
<ul>
<li><a href=#116>Drucken einer Zeichnung</a>
<li><a href=#117>Drucken eines Textes</a>
<li><a href=#118>Seiteneinrichtung</a>
</ul>
<li><a href=#119>CAM-Prozessor</a>
<ul>
<li><a href=#120>CAM-Prozessor-Hauptmen&uuml;</a>
<li><a href=#121>CAM-Prozessor-Job</a>
<li><a href=#122>Ausgabetreiber (Output Device)</a>
<ul>
<li><a href=#123>Device-Parameter</a>
<ul>
<li><a href=#124>Blenden-Konfigurationsdatei</a>
<li><a href=#125>Blenden-Emulation</a>
<li><a href=#126>Blenden-Toleranzen</a>
<li><a href=#127>Bohrer-Konfigurationsdatei</a>
<li><a href=#128>Bohrer-Toleranzen</a>
<li><a href=#129>Offset</a>
<li><a href=#130>Bedruckbarer Bereich</a>
<li><a href=#131>Stiftdaten</a>
</ul>
<li><a href=#132>Eigenen Device-Treiber definieren</a>
</ul>
<li><a href=#133>Ausgabedatei</a>
<li><a href=#134>Flag-Options</a>
<li><a href=#135>Layer und Farben</a>
</ul>
<li><a href=#136>Konturdaten</a>
</ul>
<li><a href=#137>Autorouter</a>
<li><a href=#138>&Uuml;berpr&uuml;fen des Designs</a>
<ul>
<li><a href=#139>Design Rules</a>
</ul>
<li><a href=#140>Querverweise</a>
<ul>
<li><a href=#141>Querverweis-Labels</a>
<li><a href=#142>Bauteil-Querverweise</a>
<li><a href=#143>Kontaktspiegel</a>
</ul>
<li><a href=#144>User Language</a>
<ul>
<li><a href=#145>Schreiben eines ULP</a>
<li><a href=#146>ULP ausf&uuml;hren</a>
<li><a href=#147>Syntax</a>
<ul>
<li><a href=#148>Whitespace</a>
<li><a href=#149>Kommentare</a>
<li><a href=#150>Direktiven</a>
<ul>
<li><a href=#151>#include</a>
<li><a href=#152>#require</a>
<li><a href=#153>#usage</a>
</ul>
<li><a href=#154>Schl&uuml;sselw&ouml;rter (Keywords)</a>
<li><a href=#155>Identifier</a>
<li><a href=#156>Konstanten</a>
<ul>
<li><a href=#157>Character-Konstanten</a>
<li><a href=#158>Integer-Konstanten</a>
<li><a href=#159>Real-Konstanten</a>
<li><a href=#160>String-Konstanten</a>
<li><a href=#161>Escape-Sequenzen</a>
</ul>
<li><a href=#162>Punctuator-Zeichen</a>
<ul>
<li><a href=#163>Eckige Klammern</a>
<li><a href=#164>Runde Klammern</a>
<li><a href=#165>Geschweifte Klammern</a>
<li><a href=#166>Komma</a>
<li><a href=#167>Semikolon</a>
<li><a href=#168>Doppelpunkt</a>
<li><a href=#169>Gleichheitszeichen</a>
</ul>
</ul>
<li><a href=#170>Datentypen</a>
<ul>
<li><a href=#171>char</a>
<li><a href=#172>int</a>
<li><a href=#173>real</a>
<li><a href=#174>string</a>
<li><a href=#175>Typ-Umwandlung</a>
<li><a href=#176>Typecast</a>
</ul>
<li><a href=#177>Objekt-Typen</a>
<ul>
<li><a href=#178>UL_ARC</a>
<li><a href=#179>UL_AREA</a>
<li><a href=#180>UL_ATTRIBUTE</a>
<li><a href=#181>UL_BOARD</a>
<li><a href=#182>UL_BUS</a>
<li><a href=#183>UL_CIRCLE</a>
<li><a href=#184>UL_CLASS</a>
<li><a href=#185>UL_CONTACT</a>
<li><a href=#186>UL_CONTACTREF</a>
<li><a href=#187>UL_DEVICE</a>
<li><a href=#188>UL_DEVICESET</a>
<li><a href=#189>UL_DIMENSION</a>
<li><a href=#190>UL_ELEMENT</a>
<li><a href=#191>UL_ERROR</a>
<li><a href=#192>UL_FRAME</a>
<li><a href=#193>UL_GATE</a>
<li><a href=#194>UL_GRID</a>
<li><a href=#195>UL_HOLE</a>
<li><a href=#196>UL_INSTANCE</a>
<li><a href=#197>UL_JUNCTION</a>
<li><a href=#198>UL_LABEL</a>
<li><a href=#199>UL_LAYER</a>
<li><a href=#200>UL_LIBRARY</a>
<li><a href=#201>UL_MODULE</a>
<li><a href=#202>UL_MODULEINST</a>
<li><a href=#203>UL_NET</a>
<li><a href=#204>UL_PACKAGE</a>
<li><a href=#205>UL_PAD</a>
<li><a href=#206>UL_PART</a>
<li><a href=#207>UL_PIN</a>
<li><a href=#208>UL_PINREF</a>
<li><a href=#209>UL_POLYGON</a>
<li><a href=#210>UL_PORT</a>
<li><a href=#211>UL_PORTREF</a>
<li><a href=#212>UL_RECTANGLE</a>
<li><a href=#213>UL_SCHEMATIC</a>
<li><a href=#214>UL_SEGMENT</a>
<li><a href=#215>UL_SHEET</a>
<li><a href=#216>UL_SIGNAL</a>
<li><a href=#217>UL_SMD</a>
<li><a href=#218>UL_SYMBOL</a>
<li><a href=#219>UL_TEXT</a>
<li><a href=#220>UL_VARIANTDEF</a>
<li><a href=#221>UL_VARIANT</a>
<li><a href=#222>UL_VIA</a>
<li><a href=#223>UL_WIRE</a>
</ul>
<li><a href=#224>Definitionen</a>
<ul>
<li><a href=#225>Konstanten-Definitionen</a>
<li><a href=#226>Variablen-Definitionen</a>
<li><a href=#227>Funktions-Definitionen</a>
</ul>
<li><a href=#228>Operatoren</a>
<ul>
<li><a href=#229>Bitweise Operatoren</a>
<li><a href=#230>Logische Operatoren</a>
<li><a href=#231>Vergleichs-Operatoren</a>
<li><a href=#232>Evaluation-Operatoren</a>
<li><a href=#233>Arithmetische Operatoren</a>
<li><a href=#234>String-Operatoren</a>
</ul>
<li><a href=#235>Ausdr&uuml;cke</a>
<ul>
<li><a href=#236>Arithmetischer Ausdruck</a>
<li><a href=#237>Zuweisungs-Ausdruck</a>
<li><a href=#238>String-Ausdruck</a>
<li><a href=#239>Komma-Ausdruck</a>
<li><a href=#240>Bedingter Ausdruck</a>
<li><a href=#241>Funktionsaufruf</a>
</ul>
<li><a href=#242>Statements</a>
<ul>
<li><a href=#243>Compound-Statement (Verbundanweisung)</a>
<li><a href=#244>Expression-Statement (Ausdrucksanweisung)</a>
<li><a href=#245>Control-Statements (Steueranweisungen)</a>
<ul>
<li><a href=#246>break</a>
<li><a href=#247>continue</a>
<li><a href=#248>do...while</a>
<li><a href=#249>for</a>
<li><a href=#250>if...else</a>
<li><a href=#251>return</a>
<li><a href=#252>switch</a>
<li><a href=#253>while</a>
</ul>
</ul>
<li><a href=#254>Builtins</a>
<ul>
<li><a href=#255>Builtin-Constants</a>
<li><a href=#256>Builtin Variablen</a>
<li><a href=#257>Builtin-Functions</a>
<ul>
<li><a href=#258>Character-Funktionen</a>
<ul>
<li><a href=#259>is...()</a>
<li><a href=#260>to...()</a>
</ul>
<li><a href=#261>Datei-Funktionen</a>
<ul>
<li><a href=#262>fileerror()</a>
<li><a href=#263>fileglob()</a>
<li><a href=#264>Dateinamens-Funktionen</a>
<li><a href=#265>Datei-Daten-Funktionen</a>
<li><a href=#266>Datei-Einlese-Funktionen</a>
<ul>
<li><a href=#267>fileread()</a>
</ul>
</ul>
<li><a href=#268>Mathematische Funktionen</a>
<ul>
<li><a href=#269>Absolutwert-, Maximum- und Minimum-Funktion</a>
<li><a href=#270>Rundungs-Funktionen</a>
<li><a href=#271>Trigonometrische Funktionen</a>
<li><a href=#272>Exponential-Funktionen</a>
</ul>
<li><a href=#273>Sonstige Funktionen</a>
<ul>
<li><a href=#274>Konfigurations-Parameter</a>
<li><a href=#275>country()</a>
<li><a href=#276>exit()</a>
<li><a href=#277>fdlsignature()</a>
<li><a href=#278>language()</a>
<li><a href=#279>lookup()</a>
<li><a href=#280>palette()</a>
<li><a href=#281>sleep()</a>
<li><a href=#282>sort()</a>
<li><a href=#283>status()</a>
<li><a href=#284>system()</a>
<li><a href=#285>Einheiten-Konvertierung</a>
</ul>
<li><a href=#286>Netzwerk-Funktionen</a>
<ul>
<li><a href=#287>neterror()</a>
<li><a href=#288>netget()</a>
<li><a href=#289>netpost()</a>
</ul>
<li><a href=#290>Print-Funktionen</a>
<ul>
<li><a href=#291>printf()</a>
<li><a href=#292>sprintf()</a>
</ul>
<li><a href=#293>String-Funktionen</a>
<ul>
<li><a href=#294>strchr()</a>
<li><a href=#295>strjoin()</a>
<li><a href=#296>strlen()</a>
<li><a href=#297>strlwr()</a>
<li><a href=#298>strrchr()</a>
<li><a href=#299>strrstr()</a>
<li><a href=#300>strsplit()</a>
<li><a href=#301>strstr()</a>
<li><a href=#302>strsub()</a>
<li><a href=#303>strtod()</a>
<li><a href=#304>strtol()</a>
<li><a href=#305>strupr()</a>
<li><a href=#306>strxstr()</a>
</ul>
<li><a href=#307>Zeit-Funktionen</a>
<ul>
<li><a href=#308>time()</a>
<li><a href=#309>timems()</a>
<li><a href=#310>Zeit-Konvertierungen</a>
</ul>
<li><a href=#311>Objekt-Funktionen</a>
<ul>
<li><a href=#312>clrgroup()</a>
<li><a href=#313>ingroup()</a>
<li><a href=#314>setgroup()</a>
<li><a href=#315>setvariant()</a>
<li><a href=#316>variant()</a>
</ul>
<li><a href=#317>XML-Funktionen</a>
<ul>
<li><a href=#318>xmlattribute(), xmlattributes()</a>
<li><a href=#319>xmlelement(), xmlelements()</a>
<li><a href=#320>xmltags()</a>
<li><a href=#321>xmltext()</a>
</ul>
</ul>
<li><a href=#322>Builtin-Statements</a>
<ul>
<li><a href=#323>board()</a>
<li><a href=#324>deviceset()</a>
<li><a href=#325>library()</a>
<li><a href=#326>module()</a>
<li><a href=#327>output()</a>
<li><a href=#328>package()</a>
<li><a href=#329>schematic()</a>
<li><a href=#330>sheet()</a>
<li><a href=#331>symbol()</a>
</ul>
</ul>
<li><a href=#332>Dialoge</a>
<ul>
<li><a href=#333>Vordefinierte Dialoge</a>
<ul>
<li><a href=#334>dlgDirectory()</a>
<li><a href=#335>dlgFileOpen(), dlgFileSave()</a>
<li><a href=#336>dlgMessageBox()</a>
</ul>
<li><a href=#337>Dialog-Objekte</a>
<ul>
<li><a href=#338>dlgCell</a>
<li><a href=#339>dlgCheckBox</a>
<li><a href=#340>dlgComboBox</a>
<li><a href=#341>dlgDialog</a>
<li><a href=#342>dlgGridLayout</a>
<li><a href=#343>dlgGroup</a>
<li><a href=#344>dlgHBoxLayout</a>
<li><a href=#345>dlgIntEdit</a>
<li><a href=#346>dlgLabel</a>
<li><a href=#347>dlgListBox</a>
<li><a href=#348>dlgListView</a>
<li><a href=#349>dlgPushButton</a>
<li><a href=#350>dlgRadioButton</a>
<li><a href=#351>dlgRealEdit</a>
<li><a href=#352>dlgSpacing</a>
<li><a href=#353>dlgSpinBox</a>
<li><a href=#354>dlgStretch</a>
<li><a href=#355>dlgStringEdit</a>
<li><a href=#356>dlgTabPage</a>
<li><a href=#357>dlgTabWidget</a>
<li><a href=#358>dlgTextEdit</a>
<li><a href=#359>dlgTextView</a>
<li><a href=#360>dlgVBoxLayout</a>
</ul>
<li><a href=#361>Layout-Information</a>
<li><a href=#362>Dialog-Funktionen</a>
<ul>
<li><a href=#363>dlgAccept()</a>
<li><a href=#364>dlgRedisplay()</a>
<li><a href=#365>dlgReset()</a>
<li><a href=#366>dlgReject()</a>
<li><a href=#367>dlgSelectionChanged()</a>
</ul>
<li><a href=#368>Escape-Zeichen</a>
<li><a href=#369>Ein vollst&auml;ndiges Beispiel</a>
</ul>
<li><a href=#370>Unterst&uuml;tzte HTML-Tags</a>
</ul>
<li><a href=#371>Automatischer Backup</a>
<li><a href=#372>Forward&amp;Back-Annotation</a>
<ul>
<li><a href=#373>Konsistenzpr&uuml;fung</a>
<li><a href=#374>Einschr&auml;nkungen</a>
</ul>
<li><a href=#375>Technische Unterst&uuml;tzung</a>
<li><a href=#376>Lizenz</a>
<ul>
<li><a href=#377>EAGLE-Lizenz</a>
<li><a href=#378>EAGLE-Editionen</a>
</ul>
</ul>


<a name=1>
<h1>Erkl&auml;rung der Hilfe-Funktion</h1>
Ist in einem <a href=#25>Layout-Editor</a>-,
<a href=#26>Schaltplan-Editor</a>-, oder
<a href=#23>Bibliotheks-Editor</a>-Fenster ein Befehl
aktiviert, dann wird nach Dr&uuml;cken der F1-Taste oder Eintippen von
<tt>HELP</tt> die Hilfe-Seite f&uuml;r diesen Befehl aufgerufen.
<p>
Die Erkl&auml;rung eines Befehls kann auch durch die Eingabe von
<pre>
HELP befehl
</pre>
aufgerufen werden.
<p>
Ersetzen Sie "befehl" beispielsweise durch <tt>MOVE</tt>, dann rufen Sie
die Hilfe-Seite f&uuml;r den MOVE-Befehl auf.
<p>
Von jeder anderen Stelle aus &ouml;ffnet <tt>F1</tt> eine "kontextsensitive"
Hilfe-Seite.
<p>
Folgende Hilfe-Seiten geben Auskunft f&uuml;r den Einstieg in das Programm.
<ul>
<li><a href=#4>Schnelle Einf&uuml;hrung</a>
<li><a href=#2>EAGLE konfigurieren</a>
<li><a href=#3>Kommandozeilen-Optionen</a>
<li><a href=#13>Control Panel</a>
</ul>


<a name=2>
<h1>EAGLE konfigurieren</h1>
Die folgenden Editor-Befehle k&ouml;nnen dazu verwendet werden, EAGLE individuell
anzupassen. Sie k&ouml;nnen entweder direkt von der Kommandozeile eines
Editor-Fensters eingegeben werden oder man kann Sie in die Datei
<a href=#96>eagle.scr</a> eintragen.
<p>
F&uuml;r die Befehle ASSIGN und SET exisitieren auch Dialoge, die &uuml;ber das
Options-Men&uuml; der Editor-Fenster aufgerufen werden.
<h2>Benutzer-Interface</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Befehlsmen&uuml;              </td><td width=20><td><a href=#67>MENU</a>-Befehl..;</td></tr>
<tr><td>Tastenbelegung           </td><td width=20><td><a href=#32>ASSIGN</a> function_key-Befehl..;</td></tr>
<tr><td>Snap-Funktion            </td><td width=20><td><a href=#97>SET</a> SNAP_LENGTH number;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> CATCH_FACTOR value;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> SELECT_FACTOR value;</td></tr>
<tr><td>Inhalt von Men&uuml;s         </td><td width=20><td><a href=#97>SET</a> USED_LAYERS name | number;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> WIDTH_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> DIAMETER_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> DRILL_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> SMD_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> SIZE_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> ISOLATE_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> SPACING_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> MITER_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> DLINE_WIDTH_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> DLINE_EXT_WIDTH_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> DLINE_EXT_LENGTH_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> DLINE_EXT_OFFSET_MENU value..;</td></tr>
<tr><td>Kontextmen&uuml;s             </td><td width=20><td><a href=#97>SET</a> CONTEXT type text commands;</td></tr>
<tr><td>Wire Bend                </td><td width=20><td><a href=#97>SET</a> WIRE_BEND bend_nr;</td></tr>
<tr><td>Beep ein/aus             </td><td width=20><td><a href=#97>SET</a> BEEP OFF | ON;</td></tr>
</table>
<h2>Bildschirmdarstellung</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Farbe f&uuml;r Grid-Linien    </td><td width=20><td><a href=#97>SET</a> COLOR_GRID color;</td></tr>
<tr><td>Farbe f&uuml;r Layer          </td><td width=20><td><a href=#97>SET</a> COLOR_LAYER layer color;</td></tr>
<tr><td>Fill Style f&uuml;r Layer     </td><td width=20><td><a href=#97>SET</a> FILL_LAYER layer fill;</td></tr>
<tr><td>Grid-Parameter           </td><td width=20><td><a href=#97>SET</a> MIN_GRID_SIZE pixels;</td></tr>
<tr><td>min. dargest. Textgr&ouml;&szlig;e  </td><td width=20><td><a href=#97>SET</a> MIN_TEXT_SIZE size;</td></tr>
<tr><td>Darst. der Netzlinien    </td><td width=20><td><a href=#97>SET</a> NET_WIRE_WIDTH width;</td></tr>
<tr><td>Darst. der Pads          </td><td width=20><td><a href=#97>SET</a> DISPLAY_MODE REAL | NODRILL;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#97>SET</a> PAD_NAMES OFF | ON;</td></tr>
<tr><td>Darst. der Buslinien     </td><td width=20><td><a href=#97>SET</a> BUS_WIRE_WIDTH width;</td></tr>
<tr><td>DRC-F&uuml;llmuster           </td><td width=20><td><a href=#97>SET</a> DRC_FILL fill_name;</td></tr>
<tr><td>Polygon-Berechnung       </td><td width=20><td><a href=#97>SET</a> POLYGON_RATSNEST OFF | ON;</td></tr>
<tr><td>Vector Font              </td><td width=20><td><a href=#97>SET</a> VECTOR_FONT OFF | ON;</td></tr>
</table>
<h2>Mode-Parameter</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Package-Check            </td><td width=20><td><a href=#97>SET</a> CHECK_CONNECTS OFF | ON;</td></tr>
<tr><td>Grid-Parameter           </td><td width=20><td><a href=#55>GRID</a> options;</td></tr>
<tr><td>Replace-Modus            </td><td width=20><td><a href=#97>SET</a> REPLACE_SAME NAMES | COORDS;</td></tr>
<tr><td>UNDO-Buffer              </td><td width=20><td><a href=#97>SET</a> UNDO_LOG OFF | ON;</td></tr>
<tr><td>Wire-Optimierung         </td><td width=20><td><a href=#97>SET</a> OPTIMIZING OFF | ON;</td></tr>
<tr><td>Net-Wire beenden         </td><td width=20><td><a href=#97>SET</a> AUTO_END_NET OFF | ON;</td></tr>
<tr><td>Automatische Junctions   </td><td width=20><td><a href=#97>SET</a> AUTO_JUNCTION OFF | ON;</td></tr>
</table>
<h2>Voreinstellungen</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Pad-Form                 </td><td width=20><td><a href=#37>CHANGE</a> SHAPE shape;</td></tr>
<tr><td>Wire-Breite              </td><td width=20><td><a href=#37>CHANGE</a> WIDTH value;</td></tr>
<tr><td>Pad/Via-Durchmesser      </td><td width=20><td><a href=#37>CHANGE</a> DIAMETER diameter;</td></tr>
<tr><td>Pad/Via/Hole-Bohrd.      </td><td width=20><td><a href=#37>CHANGE</a> DRILL value;</td></tr>
<tr><td>Smd-Gr&ouml;&szlig;e                </td><td width=20><td><a href=#37>CHANGE</a> SMD width height;</td></tr>
<tr><td>Text-H&ouml;he                </td><td width=20><td><a href=#37>CHANGE</a> SIZE value;</td></tr>
<tr><td>Text-Linienbreite        </td><td width=20><td><a href=#37>CHANGE</a> RATIO ratio;</td></tr>
<tr><td>Text-Font                </td><td width=20><td><a href=#37>CHANGE</a> FONT font;</td></tr>
<tr><td>Text-Ausrichtung         </td><td width=20><td><a href=#37>CHANGE</a> ALIGN align;</td></tr>
<tr><td>Polygon-Parameter        </td><td width=20><td><a href=#37>CHANGE</a> THERMALS OFF | ON;</td></tr>
<tr><td>Polygon-Parameter        </td><td width=20><td><a href=#37>CHANGE</a> ORPHANS OFF | ON;</td></tr>
<tr><td>Polygon-Parameter        </td><td width=20><td><a href=#37>CHANGE</a> ISOLATE distance;</td></tr>
<tr><td>Polygon-Parameter        </td><td width=20><td><a href=#37>CHANGE</a> POUR SOLID | HATCH | CUTOUT;</td></tr>
<tr><td>Polygon-Parameter        </td><td width=20><td><a href=#37>CHANGE</a> RANK value;</td></tr>
<tr><td>Polygon-Parameter        </td><td width=20><td><a href=#37>CHANGE</a> SPACING distance;</td></tr>
<tr><td>Bema&szlig;ungsart             </td><td width=20><td><a href=#37>CHANGE</a> DTYPE value;</td></tr>
</table>


<a name=3>
<h1>Kommandozeilen-Optionen</h1>
EAGLE kann mit Kommandozeilen-Optionen aufgerufen werden. Dazu ist
folgendes Format erforderlich:
<pre>
eagle [ Optionen [ Dateiname [ Layer ] ] ]
</pre>
<h2>Optionen</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>-Axxx</tt></td>  <td width=20><td>Best&uuml;ckungsvariante</td></tr>
<tr><td><tt>-Cxxx</tt></td>  <td width=20><td>den angegebenen Befehl ausf&uuml;hren</td></tr>
<tr><td><tt>-Dxxx</tt></td>  <td width=20><td>Draw-Toleranz (0.1 = 10%)</td></tr>
<tr><td><tt>-Exxx</tt></td>  <td width=20><td>Drill-Toleranz (0.1 = 10%)</td></tr>
<tr><td><tt>-Fxxx</tt></td>  <td width=20><td>Flash-Toleranz (0.1 = 10%)</td></tr>
<tr><td><tt>-N-</tt></td>    <td width=20><td>keine R&uuml;ckfragen in der Kommandozeile</td></tr>
<tr><td><tt>-O+</tt></td>    <td width=20><td>Stift-Bewegungen optimieren</td></tr>
<tr><td><tt>-Pxxx</tt></td>  <td width=20><td>Plotter-Stift (Layer=Stift)</td></tr>
<tr><td><tt>-Rxxx</tt></td>  <td width=20><td>Bohrer-Datei</td></tr>
<tr><td><tt>-Sxxx</tt></td>  <td width=20><td>Script-Datei</td></tr>
<tr><td><tt>-Uxxx</tt></td>  <td width=20><td>Datei f&uuml;r Benutzereinstellungen</td></tr>
<tr><td><tt>-Wxxx</tt></td>  <td width=20><td>Blenden-Datei</td></tr>
<tr><td><tt>-X-</tt></td>    <td width=20><td>CAM-Prozessor ausf&uuml;hren</td></tr>
<tr><td><tt>-c+</tt></td>    <td width=20><td>positive Koordinaten</td></tr>
<tr><td><tt>-dxxx</tt></td>  <td width=20><td>Ausgabeger&auml;t (-d? f&uuml;r Liste)</td></tr>
<tr><td><tt>-e-</tt></td>    <td width=20><td>Blenden emulieren</td></tr>
<tr><td><tt>-f+</tt></td>    <td width=20><td>Pads ausf&uuml;llen</td></tr>
<tr><td><tt>-hxxx</tt></td>  <td width=20><td>Seitenh&ouml;he (inch)</td></tr>
<tr><td><tt>-m-</tt></td>    <td width=20><td>Ausgabe spiegeln</td></tr>
<tr><td><tt>-oxxx</tt></td>  <td width=20><td>Ausgabedateiname</td></tr>
<tr><td><tt>-pxxx</tt></td>  <td width=20><td>Stiftdurchmesser (mm)</td></tr>
<tr><td><tt>-q-</tt></td>    <td width=20><td>Quick-Plot</td></tr>
<tr><td><tt>-r-</tt></td>    <td width=20><td>Ausgabe um 90 Grad drehen</td></tr>
<tr><td><tt>-sxxx</tt></td>  <td width=20><td>Skalierungsfaktor</td></tr>
<tr><td><tt>-u-</tt></td>    <td width=20><td>Ausgabe auf dem Kopf stehend</td></tr>
<tr><td><tt>-vxxx</tt></td>  <td width=20><td>Stiftgeschwindigkeit</td></tr>
<tr><td><tt>-wxxx</tt></td>  <td width=20><td>Seitenbreite (inch)</td></tr>
<tr><td><tt>-xxxx</tt></td>  <td width=20><td>X-Versatz (inch)</td></tr>
<tr><td><tt>-yxxx</tt></td>  <td width=20><td>Y-Versatz (inch)</td></tr>
</table>
<p>
Hierbei bedeutet <tt>xxx</tt>, dass weitere Daten, z. B. ein Dateiname oder
eine Dezimalzahl an den Optionsbuchstaben angeh&auml;ngt werden m&uuml;ssen (ohne oder mit
Leerzeichen), wie zum Beispiel bei
<pre>
-Wmywheel.whl
-W mywheel.whl
-e      Blenden-Emulation ein
-e+     dto.
-e-     Blenden-Emulation aus
</pre>
Bei Schalter-Optionen bedeutet ein <tt>'-'</tt>, dass der Schalter standardm&auml;&szlig;ig
ausgeschaltet ist, w&auml;hrend er bei <tt>'+'</tt> standardm&auml;&szlig;ig eingeschaltet ist.
<p>
Schalter-Optionen (z.B. <tt>-e</tt>) k&ouml;nnen ohne Wiederholung des <tt>'-'</tt>-Zeichens
verwendet werden:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>-ecfm</tt></td>  <td width=20><td>Blenden-Emulation ein, positive Koordinaten ein, Pads ausf&uuml;llen ein, Ausgabe spiegeln</td></tr>
<tr><td><tt>-ec-f+</tt></td> <td width=20><td>Blenden-Emulation ein, positive Koordinaten <b>aus</b>, Pads ausf&uuml;llen <b>ein</b></td></tr>
</table>
<h2>Benutzereinstellungen</h2>
Benutzereinstellungen werden in der <tt>eaglerc</tt>-Datei gespeichert, die
normalerweise unter <tt>$HOME/.eaglerc</tt> abgelegt wird.
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
Unter <b>Windows</b> wird die Datei als <tt>eaglerc.usr</tt> in dem Verzeichnis
abgelegt, welches durch den Registry-Eintrag "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\AppData"
definiert ist, sofern keine Umgebungsvariable namens HOME definiert ist.
</td></tr></table>
Mit der Kommandozeilen-Option <tt>-U</tt> kann daf&uuml;r eine andere Datei angegeben werden.
Dies ist insbesondere sinnvoll, wenn Sie mehrere EAGLE-Versionen mit verschiedenen Einstellungen verwenden wollen.<br>
Beispiel:
<center><tt>C:/Progamme/MyEAGLE5/bin/eagle.exe -UC:/Settings/eaglerc5.usr</tt></center>
k&ouml;nnte eine Startzeile f&uuml;r Version 5 mit einer V5-spezifischen,
<center><tt>C:/Progamme/MyEAGLE6/bin/eagle.exe -UC:/Settings/eaglerc6.usr</tt></center>
f&uuml;r Version 6 mit einer V6-spezifischen <tt>eaglerc</tt>-Datei aufrufen, welche sich von eaglerc5.usr
z.B. in den Projekt-Verzeichnissen unterscheidet.
<p>
Wird als Dateiname das Zeichen <tt>'-'</tt> angegeben, wie in <tt>-U-</tt>, so
wird keine <tt>eaglerc</tt>-Datei gelesen bzw. geschrieben.
<h2>Toleranzen definieren</h2>
Ohne <tt>'+'</tt>- oder <tt>'-'</tt>-Zeichen gilt eine Toleranzangabe f&uuml;r beide Richtungen:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>-D0.10</tt></td>         <td width=20><td>stellt Draw-Toleranz auf &plusmn;10% ein</td></tr>
<tr><td><tt>-D+0.1 -D-0.05</tt></td> <td width=20><td>stellt Draw-Toleranz auf +10% und -5% ein</td></tr>
</table>
<h2>Befehle Ausf&uuml;hren</h2>
Wird ein Befehl &uuml;ber die Option <tt>'-C'</tt> angegeben, wie etwa
<pre>
eagle -C "window (1 1) (2 2);" myboard.brd
</pre>
so l&auml;dt EAGLE die angegebene Datei und f&uuml;hrt den Befehl so aus, als w&auml;re
er in der Kommandozeile des Editor-Fensters eingegeben worden.
<p>
Folgende Bedingungen gelten f&uuml;r die Option <tt>'-C'</tt>:
<ul>
<li>Es muss ein Dateiname (Board, Schaltplan oder Library) angegeben werden,
    so dass ein Editor-Fenster ge&ouml;ffnet wird, in dem der Befehl ausgef&uuml;hrt
    werden kann. Diese Datei muss nicht notwendigerweise existieren.
    Der Befehl wird nach dem Ladevorgang und Best&auml;tigung evtl. damit verbundener Meldungen
    ausgef&uuml;hrt.
<li>Die Datei <tt>eagle.scr</tt> wird nicht automatisch ausgef&uuml;hrt.
<li>Die Option <tt>'-s'</tt> wird ignoriert.
<li>Die Benutzer-Einstellungen werden nicht in die <tt>eaglerc</tt>-Datei zur&uuml;ckgeschrieben.
<li>Falls beim letzten Verlassen von EAGLE ein Projekt ge&ouml;ffnet war, so wird dieses
    nicht ge&ouml;ffnet.
<li>Der Befehl kann ein einzelner Befehl sein oder eine Sequenz von durch
    Semikolons getrennten Befehlen.
</ul>
Um EAGLE zu starten ohne automatisch die Datei <tt>eagle.scr</tt> auszuf&uuml;hren oder
ein Projekt zu laden, kann der Befehl auch leer sein:
<pre>
eagle -C ""
</pre>
Beachten Sie bitte, dass in diesem speziellen Fall ein Leerzeichen zwischen dem
Options-Buchstaben und den Anf&uuml;hrungszeichen sein muss, damit das Programm den
explizit leeren String sieht. Es muss dann auch kein Dateiname angegeben werden,
da ja kein Befehl ausgef&uuml;hrt werden soll.
<h2>Dateiname</h2>
Falls der angegebene Dateiname <tt>eagle.epf</tt> ist (evtl. mit vorangestelltem
Verzeichnisnamen), so l&auml;dt EAGLE diese Projekt-Datei. Ansonsten wird, falls keine
Dateinamenserweiterung angegeben ist, <tt>.brd</tt> als Default verwendet.


<a name=4>
<h1>Schnelle Einf&uuml;hrung</h1>
Um schnell mit EAGLE zurechtzukommen, sollten Sie mehr &uuml;ber folgende Themen
wissen:
<ul>
<li><a href=#5>Control Panel und Editor-Fenster</a>
<li><a href=#29>Befehlseingabe</a>
<li><a href=#6>Eingabe von Parametern und Werten</a>
<li><a href=#7>Schaltplan entwerfen</a>
<li><a href=#8>Hierarchischen Schaltplan entwerfen</a>
<li><a href=#9>Schaltplan &uuml;berpr&uuml;fen</a>
<li><a href=#10>Platine aus Schaltplan erzeugen</a>
<li><a href=#11>Layout &uuml;berpr&uuml;fen</a>
<li><a href=#12>Bauelement in Bibliothek definieren</a>
<li><a href=#137>Autorouter benutzen</a>
<li><a href=#115>Ausdrucken auf den System-Drucker</a>
<li><a href=#119>Daten ausgeben mit dem CAM-Prozessor</a>
</ul>
Bei Problemen wenden Sie sich bitte an unseren
kostenlosen <a href=#375>Technischen Support</a>.


<a name=5>
<h1>Control Panel und Editor-Fenster</h1>
Vom <a href=#13>Control Panel</a> aus k&ouml;nnen Sie &uuml;ber das Datei-Men&uuml;
oder durch Anklicken eines Icons die Fenster des Schaltplan-, Layout-
und Bibliotheks-Editors &ouml;ffnen.


<a name=6>
<h1>Eingabe von Parametern und Werten</h1>
Parameter und Werte k&ouml;nnen &uuml;ber die EAGLE-Kommandozeile oder,
wesentlich bequemer, &uuml;ber die Parameter-Toolbar eingegeben werden, die
erscheint, wenn ein Befehl aktiviert ist. Da dies keiner gro&szlig;en
Erkl&auml;rung bedarf, wird an anderen Stellen im Hilfe-Text nicht explizit
darauf hingewiesen.
<p>
Wann immer Koordinaten oder Abmessungen (z.B. Leiterbahnbreiten oder Pad-Durchmesser)
angegeben werden k&ouml;nnen, k&ouml;nnen diese mit Einheiten versehen werden, wie etwa 50mil
oder 0.8mm. Wird keine Einheit angegeben, so wird die aktuelle Grid-Einheit verwendet.


<a name=7>
<h1>Schaltplan entwerfen</h1>
<h2>Schaltplan anlegen</h2>
Neuen Schaltplan mit "Datei/Neu" anlegen und mit "Datei/Speichern unter..." unter neuem
Namen abspeichern.
<h2>Zeichnungsrahmen laden</h2>
Bibliothek FRAMES mit <a href=#107>USE</a> laden und Rahmen mit <a href=#30>ADD</a> plazieren.
<h2>Symbole plazieren</h2>
Bibliotheken mit <a href=#107>USE</a> laden und Symbole plazieren (siehe <a href=#30>ADD</a>, <a href=#71>MOVE</a>,
<a href=#44>DELETE</a>, <a href=#93>ROTATE</a>, <a href=#72>NAME</a>, <a href=#108>VALUE</a>). Fehlt ein bestimmtes Bauelement, dann
mit Bibliotheks-Editor definieren.
<h2>Busse einzeichnen</h2>
Busse mit <a href=#36>BUS</a> einzeichnen. Geben Sie den Bussen Namen (<a href=#72>NAME</a>), aus denen
hervorgeht, welche Signale sich herausf&uuml;hren lassen.
<h2>Netze einzeichnen</h2>
Die Verbindungen zwischen den Pins der Elemente definiert man
mit <a href=#73>NET</a>. Dargestellt werden Netze im Net-Layer. Mit dem
Befehl <a href=#61>JUNCTION</a> kennzeichnet man Verbindungen sich kreuzender Netze.
<h2>Hierarchischen Schaltplan entwerfen</h2>
<a href=#8>Hierarchischen Schaltplan entwerfen</a>


<a name=8>
<h1>Hierarchischen Schaltplan entwerfen</h1>
<h2>Hierarchischen Schaltplan entwerfen</h2>
Ein hierarchischer Schaltplan wird durch Module gebildet.
Ein Modul wird durch den <a href=#70>MODULE</a>-Befehl erzeugt.
Module k&ouml;nnen auch &uuml;ber mehrere Schaltplanseiten gehen.
<h2>Module verwenden</h2>
Im Schaltplan wird ein Modul durch eine Modul-Instanz referenziert.
Es kann mehrere Modul-Instanzen desselben Moduls geben.
<h2>Modul-Instanzen anschlie&szlig;en</h2>
Anschlusspunkte f&uuml;r Modul-Instanzen werden durch <a href=#82>PORT</a>s definiert.


<a name=9>
<h1>Schaltplan &uuml;berpr&uuml;fen</h1>
Electrical Rule Check (<a href=#50>ERC</a>) durchf&uuml;hren und anhand der Meldungen
Fehler korrigieren. Eventuell Netz- und Pin-Liste ausgeben (<a href=#52>EXPORT</a>).
Mit dem <a href=#98>SHOW</a>-Befehl Netze am Bildschirm verfolgen.


<a name=10>
<h1>Platine aus Schaltplan erzeugen</h1>
Mit dem <a href=#35>BOARD</a>-Befehl bzw. durch Anklicken des Board-Icons
erzeugen Sie eine Platine aus dem geladenen Schaltplan (falls noch
keine Platine mit demselben Namen existiert).
<p>
Es entsteht eine Leerplatine, neben der die mit Luftlinien verbundenen
Bauelemente plaziert sind. Versorgungs-Pins werden mit den Signalen
verbunden, die ihrem Namen entsprechen, falls nicht explizit ein
anderes Netz mit ihnen verbunden wurde.
<p>
Die Platine ist &uuml;ber die <a href=#372>Forward&amp;Back-Annotation</a> mit dem Schaltplan
verbunden. Damit ist gew&auml;hrleistet, dass beide &uuml;bereinstimmen. Um die
Forward&amp;Back-Annotation aufrechtzuerhalten, sollten Sie immer beide
Dateien geladen haben, wenn Sie &Auml;nderungen am Schaltplan oder an
der Platine durchf&uuml;hren.
<h2>Platinenumrisse und Plazierung festlegen</h2>
Gegebenenfalls die Leerplatine in Gr&ouml;&szlig;e und Form ver&auml;ndern (<a href=#71>MOVE</a>,
<a href=#102>SPLIT</a>). Elemente an gew&uuml;nschte Position verschieben (<a href=#71>MOVE</a>) und
&uuml;berpr&uuml;fen, ob die Plazierung g&uuml;nstig oder ung&uuml;nstig ist (<a href=#86>RATSNEST</a>).
<h2>Sperrfl&auml;chen definieren</h2>
Falls gew&uuml;nscht, zeichnet man Sperrfl&auml;chen f&uuml;r den Autorouter als
Rechtecke, Polygone oder Kreise in die Layer tRestrict, bRestrict und
vRestrict (siehe <a href=#87>RECT</a>, <a href=#81>POLYGON</a>, <a href=#38>CIRCLE</a>). F&uuml;r den Autorouter begrenzen
auch geschlossene Wire-Z&uuml;ge im Dimension-Layer die Route-Fl&auml;che.
<h2>Routen</h2>
Mit dem <a href=#94>ROUTE</a>-Befehl lassen sich jetzt die Luftlinien in Leitungen
umwandeln. Diese Aufgabe kann man auch dem Autorouter (siehe Befehl
<a href=#34>AUTO</a>) zuweisen.


<a name=11>
<h1>Layout &uuml;berpr&uuml;fen</h1>
Design Rule Check (<a href=#48>DRC</a>) durchf&uuml;hren und Fehler korrigieren (<a href=#51>ERRORS</a>).
Eventuell Netz-, Bauteile- und Pin-Liste ausgeben (<a href=#52>EXPORT</a>).


<a name=12>
<h1>Bauelement in Bibliothek definieren</h1>
Die Definition eines Bauelements erfordert drei Schritte, die
aufeinander aufbauen.
<p>
&Ouml;ffnen Sie eine Bibliothek mit &Ouml;ffnen oder Neu im Datei-Men&uuml;.
<h2>Package definieren</h2>
Packages sind die Geh&auml;use der Bauelemente, die im Board dargestellt
werden.
<p>
Klicken Sie das Edit-Package-Icon an, und tragen Sie den gew&uuml;nschten
Namen in das New-Feld ein.
<p>
Legen Sie das Raster fest (<a href=#55>GRID</a>).
<p>
Plazieren Sie die Pads (<a href=#77>PAD</a>) und legen Sie deren Namen (<a href=#72>NAME</a>) und
Parameter fest (<a href=#37>CHANGE</a>).
<p>
Plazieren Sie mit dem <a href=#104>TEXT</a>-Befehl die Strings &gt;NAME und &gt;VALUE
(repr&auml;sentieren den aktuellen Namen und Wert in der Platine), und
zeichnen Sie das Geh&auml;use (<a href=#112>WIRE</a>-Befehl) in die entsprechenden Layer.
<h2>Symbol definieren</h2>
Symbole sind der Teil eines Devices, das im Schaltplan dargestellt wird.
<p>
Klicken Sie das Edit-Symbol-Icon an, und tragen Sie den gew&uuml;nschten
Namen in das New-Feld ein.
<p>
Plazieren Sie die Pins (<a href=#79>PIN</a>) und legen Sie deren Namen (<a href=#72>NAME</a>) und
Parameter fest (<a href=#37>CHANGE</a>).
<p>
Plazieren Sie mit dem <a href=#104>TEXT</a>-Befehl die Strings &gt;NAME und &gt;VALUE
(repr&auml;sentieren den aktuellen Namen und Wert im Schaltplan), und
zeichnen Sie das Symbol (<a href=#112>WIRE</a>-Befehl) in die entsprechenden Layer.
<h2>Device definieren</h2>
Ein Device enth&auml;lt die Definition eines gesamten Bauelements
einschlie&szlig;lich Geh&auml;use und Schaltplan-Symbol(e).
<p>
Klicken Sie das Edit-Device-Icon an, und tragen Sie den gew&uuml;nschten
Namen in das New-Feld ein.
<p>
Weisen Sie dem Device ein Geh&auml;use zu (<a href=#76>PACKAGE</a>-Befehl).
<p>
Verwenden Sie den <a href=#30>ADD</a>-Befehl, um das Symbol oder die Symbole in das
Device zu holen.
<p>
Klicken Sie auf das <a href=#41>CONNECT</a>-Icon, um festzulegen, welche Pins mit
welchen Geh&auml;use-Pads verbunden sind.
<p>
Speichern Sie die Bibliothek, und sie kann anschlie&szlig;end vom
Schaltplan- oder vom Board-Editor aus mit <a href=#107>USE</a> geladen werden.


<a name=13>
<h1>Control Panel</h1>
Das Control Panel ist EAGLEs Steuerzentrale.
Es enth&auml;lt in der linken Fensterh&auml;lfte eine Baumstruktur und ein Informationsfenster
in der rechten H&auml;lfte.
<h2>Verzeichnisse einstellen</h2>
Die Haupteintr&auml;ge in der Baumansicht repr&auml;sentieren die verschiedenen EAGLE-Dateitypen.
Jeder der Eintr&auml;ge kann auf ein oder mehrere Verzeichnisse zeigen, die Dateien dieses
Typs enthalten.
Die Verzeichnisse werden im <a href=#15>Directories-Dialog</a> definiert.
Wenn einer der Haupteintr&auml;ge auf ein Verzeichnis zeigt, sehen Sie nach dem Aufklappen
des Eintrags (entweder durch einen Klick auf das kleine Symbol links oder durch einen
Doppelklick auf den Eintrag selbst) direkt den Inhalt des Verzeichnisses.
Wenn ein Haupteintrag auf mehrere Verzeichnisse zeigt, werden nach dem Aufklappen alle
Verzeichniseintr&auml;ge aufgelistet.
<h2>Kontext-Men&uuml;</h2>
Das <a href=#14>Kontext-Men&uuml;</a> eines Eintrags in der Baumstruktur
erreichen Sie mit einem rechten Mausklick auf den entsprechenden Eintrag. Es enth&auml;lt
dann spezielle Punkte zu diesem Eintrag.
<h2>Beschreibungen</h2>
Die <i>Beschreibung</i>-Spalte der Baumansicht enth&auml;lt eine Kurzbeschreibung des Eintrags
(wenn vorhanden). Diese Beschreibungen werden aus der ersten nicht leeren Textzeile der
folgenden Quellen erzeugt:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Verzeichnisse</td>          <td width=20><td>Die Datei mit dem Namen DESCRIPTION darin</td></tr>
<tr><td>Bibliotheken</td>           <td width=20><td>DESCRIPTION-Befehl in der Bibliothek</td></tr>
<tr><td>Devices</td>                <td width=20><td>DESCRIPTION-Befehl im Device-Editor</td></tr>
<tr><td>Packages</td>               <td width=20><td>DESCRIPTION-Befehl im Package-Editor</td></tr>
<tr><td>Design-Regeln</td>          <td width=20><td>Die Beschreibung der Design-Regel-Datei im DRC-Dialog</td></tr>
<tr><td>User-Language-Programme</td><td width=20><td>Text, durch die <tt>#usage</tt>-Anweisung gekennzeichnet</td></tr>
<tr><td>Script-Dateien</td>         <td width=20><td>Der Kommentar am Anfang der Script-Datei</td></tr>
<tr><td>CAM-Jobs</td>               <td width=20><td>DESCRIPTION-Befehl im CAM-Prozessor-Job</td></tr>
</table>
<h2>Drag&amp;Drop</h2>
Sie k&ouml;nnen mit Hilfe von <i>Drag&amp;Drop</i> Dateien und Verzeichnisse innerhalb der
Baumstruktur kopieren oder bewegen. Es ist auch m&ouml;glich, ein Device oder ein Package
in das Schaltplan-, Layout- bzw. Library-Fenster zu ziehen und dort zu plazieren.
Zieht man User-Language-Programme und Script-Dateien auf ein Editor-Fenster, werden sie
darin ausgef&uuml;hrt. Design Rules werden einem Layout zugeordnet, wenn Sie einen entsprechenden
Eintrag in das Layout-Editor-Fenster ziehen.
Ziehen Sie eine Board-, Schaltplan- oder Library-Datei auf das jeweilige Editor-Fenster,
so wird die Datei in den Editor geladen.
All diese Funktionen erreichen Sie auch &uuml;ber das <i>Kontext-Men&uuml;</i> des entsprechenden Eintrags
in der Baumstruktur.
<h2>Informations-Fenster</h2>
In der rechten H&auml;lfte des Control Panels werden Informationen zum selektierten
Punkt in der Baumstruktur angezeigt. Diese Informationen werden aus den Quellen
erzeugt, die unter <i>Beschreibungen</i> angegeben sind. Bei Device und Package
erh&auml;lt man eine Voransicht des Elements.
<h2>Men&uuml;-Leiste</h2>
Die <i>Men&uuml;-Leiste</i> des Control Panels enth&auml;lt folgende Punkte:
<h2>Datei</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Neu   </td><td width=20><td>Erzeugt eine neue Datei</td></tr>
<tr><td>&Ouml;ffnen          </td><td width=20><td>&Ouml;ffnet eine existierende Datei</td></tr>
<tr><td>Zuletzt ge&ouml;ffnete Projekte</td><td width=20><td>&Ouml;ffnet eines der zuletzt bearbeiteten Projekte</td></tr>
<tr><td>Alles speichern </td><td width=20><td>Speichert alle modifizierten Editor-Dateien</td></tr>
<tr><td>Projekt schlie&szlig;en</td><td width=20><td>Schlie&szlig;t das aktuelle Projekt</td></tr>
<tr><td>Beenden         </td><td width=20><td>Beendet das Programm</td></tr>
</table>
<h2>Ansicht</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Aktualisieren</td><td width=20><td>Aktualisiert den Inhalt der Baumansicht</td></tr>
<tr><td>Suche</td><td width=20><td>Sucht im Inhalt der Baumansicht (siehe unten)</td></tr>
<tr><td>Sortieren       </td><td width=20><td>&Auml;ndert die Sortierung der Baumansicht</td></tr>
</table>
<h2>Optionen</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Verzeichnisse...    </td><td width=20><td>&Ouml;ffnet den <a href=#15>Verzeichnis-Dialog</a></td></tr>
<tr><td>Sicherung...         </td><td width=20><td>&Ouml;ffnet den <a href=#16>Sicherungs-Dialog</a></td></tr>
<tr><td>Benutzeroberfl&auml;che... </td><td width=20><td>&Ouml;ffnet den <a href=#17>Benutzeroberfl&auml;che-Dialog</a></td></tr>
<tr><td>Fensterpositionen...  </td><td width=20><td>&Ouml;ffnet den <a href=#18>Fensterpositionen-Dialog</a></td></tr>
</table>
<h2>Fenster</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Control Panel         </td><td width=20><td>Zum Control Panel wechseln</td></tr>
<tr><td>1 Schaltplan - ...    </td><td width=20><td>Zu Fenster 1 wechseln</td></tr>
<tr><td>2 Board - ...         </td><td width=20><td>Zu Fenster 2 wechseln</td></tr>
</table>
<h2>Hilfe</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Allgemein </td><td width=20><td>&Ouml;ffnet eine allgemeine Hilfe-Seite</td></tr>
<tr><td>Kontext           </td><td width=20><td>&Ouml;ffnet die Hilfe-Seite f&uuml;r den momentanen Kontext</td></tr>
<tr><td>Control Panel     </td><td width=20><td>&Ouml;ffnet diese Hilfe-Seite</td></tr>
<tr><td>EAGLE Lizenz      </td><td width=20><td>&Ouml;ffnet den <a href=#377>Lizenz-Dialog</a></td></tr>
<tr><td>Auf Update pr&uuml;fen </td><td width=20><td><a href=#19>Pr&uuml;ft</a> ob eine neue Version von EAGLE verf&uuml;gbar ist</td></tr>
<tr><td>&Uuml;ber EAGLE        </td><td width=20><td>Zeigt Details zu Ihrer EAGLE Version und <a href=#376>Lizenz</a> an</td></tr>
</table>
<h2>Suchleiste</h2>
Das <i>Suchmuster</i> kann aus einem oder mehreren W&ouml;rtern, getrennt durch Leerzeichen,
bestehen. Nach diesen Begriffen wird in den Namen und Beschreibungen der Baumansicht
unabh&auml;ngig von Gro&szlig;- und Kleinschreibung gesucht. Es m&uuml;ssen <i>alle</i> Begriffe gefunden
werden. Der Platzhalter '*' steht f&uuml;r eine beliebige Anzahl von sichtbaren Zeichen,
w&auml;hrend '?' f&uuml;r exakt <i>ein</i> sichtbares Zeichen steht. Um einen Platzhalter selbst
zu suchen, muss diesem ein Backslash vorangestellt werden, wie in '\*'.
Um die Suche auf einen bestimmten Zweig der Baumansicht zu beschr&auml;nken, muss die
Suche in dessen Kontextmen&uuml; gestartet werden.
Um z.B. ein NAND-Bauteil der 74xx-Serie zu finden, geben Sie ein: <i>74* nand</i>
<h2>Statuszeile</h2>
Die Statuszeile unten im Control Panel enth&auml;lt
den vollst&auml;ndigen Namen des gegenw&auml;rtig selektierten Objektes.


<a name=14>
<h1>Kontext-Men&uuml;s</h1>
Ein Klick mit der rechten Maustaste auf ein Objekt des
<a href=#13>Control Panels</a> &ouml;ffnet ein Kontext-Men&uuml; das
folgende Aktionen erm&ouml;glicht (nicht alle davon sind f&uuml;r alle Objekte zutreffend):
<h2>Neuer Ordner</h2>
Erzeugt ein neues Verzeichnis unterhalb des selektierten Ordners und schaltet den
neu erzeugten Zweig der Baumansicht in den <i>Umbenennen</i>-Modus, so dass der
gew&uuml;nschte Name vergeben werden kann.
<h2>Beschreibung editieren</h2>
L&auml;dt die DESCRIPTION-Datei in den HTML-Editor.
<h2>Umbenennen</h2>
Schaltet den Eintrag der Baumansicht in den Editier-Modus, so dass er umbenannt
werden kann.
<h2>Kopieren</h2>
&Ouml;ffnet einen Datei-Dialog in dem Sie den neuen Namen der zu kopierenden Datei bzw. des
Verzeichnisses angeben. Dateien oder Verzeichnisse kann man auch mit Hilfe von
<i>Drag&amp;Drop</i> kopieren.
<h2>L&ouml;schen</h2>
L&ouml;scht die Datei oder das Verzeichnis. Sie werden vor dem L&ouml;schen gefragt, ob
wirklich gel&ouml;scht werden soll.
<h2>Use</h2>
Ist eine Bibliothek als <i>in use</i> markiert, werden die Devices und Packages darin
von der Suchfunktion ber&uuml;cksichtigt. Sie k&ouml;nnen auch durch einen Mausklick auf den Marker
in der zweiten Spalte der Baumansicht die Bibliothek freigeben oder nicht.
<h2>Alle Bibliotheken laden</h2>
Alle Bibliotheken im Bibliothekspfad werden bei der Suche nach Devices und Packages
ber&uuml;cksichtigt, d. h. alle Bibliotheken sind <i>in use</i>.
<h2>Keine Bibliothek laden</h2>
Keine der Bibliotheken ist <i>in use</i> (einschlie&szlig;lich der Bibliotheken, die nicht im Bibliothekspfad stehen).
<h2>Update</h2>
Tauscht alle Bauteile des geladenen Schaltplans oder Layouts, die aus dieser Bibliothek genommen wurden gegen die
aktuelle Bauteile-Definition aus.
<h2>Update in Bibliothek</h2>
Tauscht alle in der geladenen Bibliothek verwendeten Geh&auml;usedefinitionen gegen den aktuellen Stand aus dieser
Bibliothek aus.
<h2>In Schaltplan einf&uuml;gen</h2>
Startet den <a href=#30>ADD</a>-Befehl im Schaltplan-Editor f&uuml;r dieses Device.
Das ist auch &uuml;ber <i>Drag&amp;Drop</i> m&ouml;glich.
<h2>In Platine einf&uuml;gen</h2>
Startet den <a href=#30>ADD</a>-Befehl im Layout-Editor f&uuml;r dieses Package.
Das ist auch &uuml;ber <i>Drag&amp;Drop</i> m&ouml;glich.
<h2>In Bibliothek kopieren</h2>
Kopiert das selektierte Device-Set oder Package in die geladene Bibliothek.
Das ist auch &uuml;ber <i>Drag&amp;Drop</i> m&ouml;glich.
<h2>Neue Package-Variante in der Bibliothek</h2>
Erzeugt eine neue Package-Variante mit dem selektierten Package im aktuellen
Device-Set der geladenen Bibliothek.
Das ist auch &uuml;ber <i>Drag&amp;Drop</i> m&ouml;glich.
<h2>Projekt &ouml;ffnen/schlie&szlig;en</h2>
&Ouml;ffnet oder schlie&szlig;t ein Projekt.
Dazu k&ouml;nnen Sie auch auf den Marker rechts vom Projekt-Eintrag in der Baumansicht klicken.
<h2>Neu</h2>
&Ouml;ffnet ein Fenster mit der neuen Datei des entsprechenden Typs.
<h2>&Ouml;ffnen</h2>
&Ouml;ffnet ein Editor-Fenster mit dieser Datei.
Das ist auch mit &uuml;ber <i>Drag&amp;Drop</i> m&ouml;glich.
<h2>Drucken...</h2>
Druckt die Datei auf dem System-Drucker aus.
Weitere Informationen zur Benutzung der Druck-Dialoge entnehmen Sie
bitte dem Kapitel <a href=#115>Drucken auf dem System-Drucker</a>.
<p>
Wird eine Datei &uuml;ber dies Kontext-Men&uuml; Option ausgedruckt, so wird immer
die Datei von der Platte gelesen, auch wenn Sie ein offenes Editor Fenster
haben in dem Sie die Datei editieren! Benutzen Sie den
<a href=#84>PRINT</a>-Befehl um eine Zeichnung aus einem offenen
Editor Fenster heraus zu drucken.<br>
<b>Bitte beachten Sie, dass Polygone in Platinen beim Ausdrucken &uuml;ber das
Kontext-Men&uuml; nicht automatisch freigerechnet werden! Es werden lediglich die
Umrisse dargestellt. Um die Polygone freigerechnet auszudrucken, laden Sie
die Zeichnung in ein Editor-Fenster, geben Sie
<a href=#86>RATSNEST</a> ein und dann
<a href=#84>PRINT</a>.</b>
<h2>Im ... ausf&uuml;hren</h2>
Startet das gew&auml;hlte User-Language-Programm bzw. Script im aktuellen Schaltplan, Board oder in der
Bibliothek.
Das ist auch &uuml;ber <i>Drag&amp;Drop</i> m&ouml;glich.
<h2>Im Board laden</h2>
L&auml;dt diesen Satz von Design Rules f&uuml;r das aktuelle Board.
Das ist auch &uuml;ber<i>Drag&amp;Drop</i> m&ouml;glich.


<a name=15>
<h1>Verzeichnisse</h1>
Mit dem <i>Verzeichnisse</i>-Dialog definiert man die Pfade, in denen nach
Dateien gesucht werden soll.
<p>
Alle Felder k&ouml;nnen ein oder mehrere, durch Doppelpunkt (<b><tt>':'</tt></b>) getrennte
Verzeichnisse enthalten, in denen nach den verschiedenen Dateitypen gesucht wird.
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
Unter <b>Windows</b> werden die einzelnen Verzeichnisnamen durch Strichpunkte (<b><tt>';'</tt></b>) getrennt.
</td></tr></table>
Wird einer der Befehle <a href=#74>OPEN</a>,
<a href=#107>USE</a>, <a href=#96>SCRIPT</a> oder
<a href=#95>RUN</a> eingegeben, dann werden diese Pfade durchsucht,
mit Priorit&auml;t von links nach rechts.
Wird der Datei-Dialog benutzt um eine Datei eines dieser Typen anzusprechen, so wird
das Verzeichnis, in das der Anwender mittels des Datei-Dialogs navigiert hat, implizit
an das Ende des jeweiligen Pfades angeh&auml;ngt.
<p>
Die Variablen <tt>$HOME</tt> und <tt>$EAGLEDIR</tt> werden verwendet, um das
Home-Verzeichnis des Benutzers bzw. das EAGLE-Programm-Verzeichnis anzugeben.
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
Unter <b>Windows</b> gilt f&uuml;r <tt>$HOME</tt> entweder die Umgebungsvariable HOME (falls gesetzt),
oder der Wert des Schl&uuml;ssels "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell&nbsp;Folders\Personal"
in der Windows-Registry, der den g&uuml;ltigen Pfad des Verzeichnisses "Eigene Dateien" enth&auml;lt.
</td></tr></table>


<a name=16>
<h1>Datensicherung</h1>
Der <i>Datensicherung</i>-Dialog erm&ouml;glicht es Ihnen, den
<a href=#371>automatischen Backup</a> individuell
einzustellen.
<h2>Max. Anzahl der Sicherungskopien</h2>
Definiert wie viele Backup-Kopien Ihrer EAGLE-Dateien "aufgehoben"
werden wenn eine Datei normal mit dem WRITE-Befehl abgespeichert wird (Default: 9).
<h2>Intervall f. automat. Sicherung (Minuten)</h2>
Bestimmt das Zeitintervall nachdem EAGLE automatisch eine Sicherungskopie aller
modifizierten Zeichnungsdateien erzeugt (default ist 5 min.).
<h2>Projektdatei automatisch sichern</h2>
Ist diese Option gew&auml;hlt, werden Ihre Projekteinstellungen automatisch gesichert, wenn
Sie das Programm verlassen.
Bitte beachten Sie, dass das momentan ge&ouml;ffnete Projekt nicht abgespeichert wird,
wenn Sie diese Option ausschalten, was zur Folge hat, dass die Einstellung nicht
nicht in der eagle.epf-Datei des Projekts gespeichert wird. Daher ist diese
Option wieder eingeschaltet, wenn Sie das Projekt das n&auml;chste Mal &ouml;ffnen.
Wenn Sie wollen, dass diese Option f&uuml;r das aktuelle Projekt ausgeschaltet
bleibt, m&uuml;ssen Sie manuell "Datei/Alles speichern" aus dem Pulldown-Men&uuml;
w&auml;hlen, nachdem Sie die Option ausgeschaltet haben.


<a name=17>
<h1>Benutzeroberfl&auml;che</h1>
Der <i>Benutzeroberfl&auml;che</i>-Dialog erm&ouml;glicht es, das Erscheinungsbild der
<a href=#22>Editor-Fenster</a> f&uuml;r Layout, Schaltplan
und Bibliothek den eigenen Vorstellungen anzupassen.
<h2>Symbolleisten und Men&uuml;s</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Men&uuml;leiste </td><td width=20><td>aktiviert das Pulldown-Men&uuml; am oberen Rand des Editor-Fensters</td></tr>
<tr><td>Aktionsleiste        </td><td width=20><td>aktiviert die Toolbar mit Buttons f&uuml;r "Datei", "Drucken" etc.</td></tr>
<tr><td>Parameterleiste      </td><td width=20><td>aktiviert die dynamische Parameter-Toolbar, die alle Parameter des gerade aktiven Befehls enth&auml;lt</td></tr>
<tr><td>Befehlsmen&uuml;          </td><td width=20><td>aktiviert die Kommando-Toolbar</td></tr>
<tr><td>Textmen&uuml;             </td><td width=20><td>aktiviert das Text-Men&uuml;</td></tr>
<tr><td>Seitenvorschau       </td><td width=20><td>aktiviert die Vorschau f&uuml;r Schaltplanseiten</td></tr>
</table>
<h2>Layout</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Hintergrund </td><td width=20><td>w&auml;hlt die Hintergrundfarbe schwarz, wei&szlig; oder farbig im Layout-Editor</td></tr>
<tr><td>Mauszeiger           </td><td width=20><td>w&auml;hlt einen kleines Kreuz oder ein gro&szlig;es Fadenkreuz als Mauszeiger im Layout-Editor</td></tr>
</table>
<h2>Schaltplan</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Hintergrund </td><td width=20><td>w&auml;hlt die Hintergrundfarbe schwarz, wei&szlig; oder farbig im Schaltplan-Editor</td></tr>
<tr><td>Mauszeiger           </td><td width=20><td>w&auml;hlt ein kleines Kreuz oder ein gro&szlig;es Fadenkreuz als Mauszeiger im Schaltplan-Editor</td></tr>
</table>
<h2>Hilfe</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Direkthilfe </td><td width=20><td>aktiviert die "Direkthilfe" Funktion, die einen kurzen Hinweis &uuml;ber die Bedeutung der Buttons gibt, wenn man den Mauszeiger &uuml;ber einen solchen bewegt</td></tr>
<tr><td>Benutzerf&uuml;hrung       </td><td width=20><td>aktiviert die "Benutzerf&uuml;hrung", die einen Hilfetext anzeigt, der dem Benutzer bei aktivem Befehl jederzeit den n&auml;chsten sinnvollen Schritt angibt</td></tr>
</table>
<h2>Misc</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Immer Vektor-Schrift </td><td width=20><td>Texte in Zeichnungen werden immer im EAGLE-eigenen
Vektor-Font dargestellt, unabh&auml;ngig welche Schriftart f&uuml;r einen Text urspr&uuml;nglich gew&auml;hlt wurde.</td></tr>
<tr><td>Mausrad-Zoomfaktor </td><td width=20><td>definiert den Zoom-Faktor f&uuml;r das Hinein- bzw.
Herauszoomen mit einer R&auml;dchenmaus in einem Editor-Fenster ('0' schaltet diese
Funktion aus, das Vorzeichen bestimmt die Drehrichtung des R&auml;dchens)</td></tr>
</table>


<a name=18>
<h1>Fensterpositionen</h1>
Der <i>Fensterpositionen</i>-Dialog erm&ouml;glicht es, die Positionen aller momentan
ge&ouml;ffneten Fenster abzuspeichern, so dass sp&auml;ter, wenn ein Fenster des gleichen Typs
erneut ge&ouml;ffnet wird, dieses an der gleichen Stelle wie zuvor erscheint.
<p>
Sie k&ouml;nnen auch alle gespeicherten Fensterpositionen l&ouml;schen, so dass es wieder
dem Window-Manager &uuml;berlassen ist, wo neu ge&ouml;ffnete Fenster platziert werden.


<a name=19>
<h1>Auf Update pr&uuml;fen</h1>
Die Option "Hilfe/Auf Update pr&uuml;fen" im Pulldown-Men&uuml; des Control-Panels
&ouml;ffnet einen Dialog, der anzeigt, ob auf dem CadSoft-Server eine neue
Version von EAGLE zur Verf&uuml;gung steht.
<p>
Der <b>Konfigurieren</b>-Button &ouml;ffnet einen Dialog, in dem Sie angeben k&ouml;nnen ob
und wie h&auml;ufig eine automatische &Uuml;berpr&uuml;fung auf eine neue Version beim
Programmstart stattfinden soll (standardm&auml;&szlig;ig geschieht dies einmal am Tag).
Falls Sie einen Proxy benutzen m&uuml;ssen, um das Internet anzusprechen, so
k&ouml;nnen Sie diesen auch im Konfigurationsdialog angeben. Geben Sie dazu im
Feld "Host" den vollen Namen des Proxy-Rechners ein, ohne etwaigen
<tt>http://</tt>-Pr&auml;fix, und im Feld "Port" eine optionale Port-Nummer.
<p>
Falls Sie auch &uuml;ber Betaversionen von EAGLE informiert werden m&ouml;chten, so
k&ouml;nnen sie die Option "Auch auf Betaversionen pr&uuml;fen" einschalten.


<a name=20>
<h1>Tastatur und Maus</h1>
Die <i>Steuertasten</i> (<tt>Alt</tt>, <tt>Ctrl</tt> und <tt>Shift</tt>) werden benutzt
um das Verhalten bestimmter Maus-Aktionen zu ver&auml;ndern.
Beachten Sie bitte, dass abh&auml;nging vom verwendeten Betriebssystem bzw. Window-Manager
manche dieser Tasten (in Kombination mit Maus-Aktionen) m&ouml;glicherweise nicht an
Applikationen weitergeleitet werden, was zur Folge hat, dass einige der hier beschriebenen
Funktionen dann nicht verf&uuml;gbar sind.
<p>
Auf deutschen Tastaturen wird die <tt>Ctrl</tt>-Taste meist als <tt>Strg</tt>
bezeichnet und die <tt>Shift</tt>-Taste als "Umschalt-Taste". Da EAGLE an einigen
Stellen Code-Buchstaben f&uuml;r die Bezeichnung dieser Tasten verwendet (siehe
<a href=#32>ASSIGN</a> und <a href=#29>Befehlseingabe</a>)
verwenden wir durchgehend die Bezeichnungen <tt>Ctrl</tt> und <tt>Shift</tt>.
<h2>Alt</h2>
Ein Druck auf die <tt>Alt</tt>-Taste schaltet auf ein alternatives <a href=#55>GRID</a>
um. Dies kann typischerweise ein feineres Raster als das normale sein, wodurch es
zum Beispiel schnell und einfach m&ouml;glich ist etwas in einem dicht belegten Gebiet
fein zu positionieren, wof&uuml;r das normal Raster zu grob w&auml;re.
Das alternative Grid bleibt so lange aktiv, wie die <tt>Alt</tt>-Taste gedr&uuml;ckt
gehalten wird.
<h2>Ctrl</h2>
Wird die <tt>Ctrl</tt>-Taste zusammen mit der rechten Maustaste gedr&uuml;ckt so wird
zwischen korrespondierenden Knickwinkeln hin und her geschaltet (dies betrifft nur
Befehle die Wire-Knickwinkel unterst&uuml;tzen, wie etwa <a href=#112>WIRE</a>).
<p>
Die <tt>Ctrl</tt>-Taste zusammen mit der linken Maustaste steuert spezielle Funktionen
der einzelnen Befehle, wie zum Beispiel das Aufnehmen eines Objektes an seinem
Aufh&auml;ngepunkt beim <a href=#71>MOVE</a>-Befehl.
<p>
Falls ein Befehl eine Gruppe selektieren kann, so muss die <tt>Ctrl</tt>-Taste zusammen
mit der rechten Maustaste gedr&uuml;ckt werden, um die Gruppe zu selektieren (ansonsten
w&uuml;rde ein Kontext-Men&uuml; f&uuml;r das ausgew&auml;hlte Objekt ge&ouml;ffnet).
<p>
<table><tr><td valign="top"><img src="platforms-mac.png"></td><td valign="middle">
Unter <b>Mac OS X</b> ist anstatt der <tt>Ctrl</tt>-Taste die <tt>Cmd</tt>-Taste
zu verwenden.
</td></tr></table>
<h2>Shift</h2>
Wird die <tt>Shift</tt>-Taste zusammen mit der rechten Maustaste gedr&uuml;ckt so wird
die Richtung des Weiterschaltens des Knickwinkels umgekehrt  (dies betrifft nur
Befehle die Wire-Knickwinkel unterst&uuml;tzen, wie etwa <a href=#112>WIRE</a>).
<p>
Die <tt>Shift</tt>-Taste zusammen mit der linken Maustaste steuert spezielle Funktionen
der einzelnen Befehle, wie zum Beispiel das L&ouml;schen eines &uuml;bergeordneten Objektes
beim <a href=#44>DELETE</a>-Befehl.
<h2>Esc</h2>
Wird bei einem aktiven Befehl die <tt>Esc</tt>-Taste gedr&uuml;ckt, so wird die
aktuelle Aktion dieses Befehls beendet, ohne dass der gesamte Befehl
abgebrochen wird (falls die Kommandozeile Text enth&auml;lt so wird dieser zuerst
gel&ouml;scht und der n&auml;chste Druck auf die <tt>Esc</tt>-Taste wirkt auf den Befehl).
F&uuml;r den <a href=#71>MOVE</a>-Befehl zum Beispiel bedeutet dies, dass ein am Mauszeiger
befindliches Objekt "fallengelassen" wird und ein anderes Objekt
selektiert werden kann.
<h2>Crsr-Up/Down</h2>
Die Tasten <tt>Crsr-Up</tt> (Pfeil nach oben) bzw. <tt>Crsr-Down</tt>
(Pfeil nach unten) erlauben es in der Kommandozeile des Editor-Fensters
fr&uuml;her eingegeben Befehlszeilen wieder herzuholen ("History-Funktion").
<h2>Funktionstasten</h2>
Beliebige Kommandos k&ouml;nnen mit dem <a href=#32>ASSIGN</a>-Befehl auf
Funktionstasten gelegt werden.
<h2>Linke Maustaste</h2>
Die linke Maustaste dient generell zum Selektieren, Zeichnen und Plazieren von
Objekten.
<h2>Mittlere Maustaste</h2>
Die mittlere Maustaste wechselt den aktuellen Layer oder spiegelt das am Mauszeiger
h&auml;ngende Objekt.
<p>
Folgende Befehle unterst&uuml;tzen die mittlere Maustaste:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#30>ADD</a>  </td><td width=20><td>Bauteil spiegeln</td></tr>
<tr><td><a href=#31>ARC</a>            </td><td width=20><td>aktiven Layer wechseln</td></tr>
<tr><td><a href=#38>CIRCLE</a>      </td><td width=20><td>aktiven Layer wechseln</td></tr>
<tr><td><a href=#42>COPY</a>          </td><td width=20><td>Objekt spiegeln</td></tr>
<tr><td><a href=#60>INVOKE</a>      </td><td width=20><td>Gatter spiegeln</td></tr>
<tr><td><a href=#62>LABEL</a>        </td><td width=20><td>aktiven Layer wechseln</td></tr>
<tr><td><a href=#71>MOVE</a>          </td><td width=20><td>Objekt oder Gruppe spiegeln</td></tr>
<tr><td><a href=#78>PASTE</a>        </td><td width=20><td>Gruppe spiegeln</td></tr>
<tr><td><a href=#81>POLYGON</a>    </td><td width=20><td>aktiven Layer wechseln</td></tr>
<tr><td><a href=#87>RECT</a>          </td><td width=20><td>aktiven Layer wechseln</td></tr>
<tr><td><a href=#94>ROUTE</a>        </td><td width=20><td>aktiven Layer wechseln</td></tr>
<tr><td><a href=#101>SMD</a>            </td><td width=20><td>aktiven Layer wechseln</td></tr>
<tr><td><a href=#104>TEXT</a>          </td><td width=20><td>aktiven Layer wechseln</td></tr>
<tr><td><a href=#112>WIRE</a>          </td><td width=20><td>aktiven Layer wechseln</td></tr>
</table>
<p>
Click&amp;Drag mit der mittleren Maustaste verschiebt die Zeichnung innerhalb
des Editor-Fensters.
<h2>Rechte Maustaste</h2>
Die rechte Maustaste wird im Wesentlichen dazu verwendet, eine Gruppe zu selektieren,
am Mauszeiger h&auml;ngende Objekte zu rotieren, den Wire-Knickwinkel zu &auml;ndern sowie f&uuml;r
einige andere, befehlsspezifische Funktionen.
<p>
Wird ein Objekt mit der rechten Maustaste angeklickt, so wird ein kontextspezifisches
Popup-Men&uuml; angezeigt, aus dem Befehle, die f&uuml;r dieses Objekt anwendbar sind, ausgew&auml;hlt
werden k&ouml;nnen.
Falls gerade ein Befehl aktiv ist, der auf eine Gruppe angewendet werden kann,
enth&auml;lt das Popup-Men&uuml; einen entsprechenden Eintrag.
<p>
Folgende Befehle unterst&uuml;tzen die rechte Maustaste:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#30>ADD</a>  </td><td width=20><td>Bauteil drehen</td></tr>
<tr><td><a href=#31>ARC</a>            </td><td width=20><td>Drehsinn des Kreisbogens &auml;ndern</td></tr>
<tr><td><a href=#36>BUS</a>            </td><td width=20><td>Wire-Knickwinkel &auml;ndern</td></tr>
<tr><td><a href=#37>CHANGE</a>      </td><td width=20><td>Change auf Gruppe anwenden</td></tr>
<tr><td><a href=#44>DELETE</a>      </td><td width=20><td>Gruppe l&ouml;schen</td></tr>
<tr><td><a href=#56>GROUP</a>        </td><td width=20><td>Polygon schlie&szlig;en</td></tr>
<tr><td><a href=#60>INVOKE</a>      </td><td width=20><td>Gatter drehen</td></tr>
<tr><td><a href=#62>LABEL</a>        </td><td width=20><td>Label drehen</td></tr>
<tr><td><a href=#68>MIRROR</a>      </td><td width=20><td>Gruppe spiegeln</td></tr>
<tr><td><a href=#71>MOVE</a>          </td><td width=20><td>Objekt drehen bzw. Gruppe selektieren</td></tr>
<tr><td><a href=#73>NET</a>            </td><td width=20><td>Wire-Knickwinkel &auml;ndern</td></tr>
<tr><td><a href=#77>PAD</a>            </td><td width=20><td>Pad drehen</td></tr>
<tr><td><a href=#78>PASTE</a>        </td><td width=20><td>Gruppe drehen</td></tr>
<tr><td><a href=#79>PIN</a>            </td><td width=20><td>Pin drehen</td></tr>
<tr><td><a href=#81>POLYGON</a>    </td><td width=20><td>Wire-Knickwinkel &auml;ndern</td></tr>
<tr><td><a href=#92>RIPUP</a>        </td><td width=20><td>Ripup auf Gruppe anwenden</td></tr>
<tr><td><a href=#93>ROTATE</a>      </td><td width=20><td>Gruppe drehen</td></tr>
<tr><td><a href=#94>ROUTE</a>        </td><td width=20><td>Wire-Knickwinkel &auml;ndern</td></tr>
<tr><td><a href=#101>SMD</a>            </td><td width=20><td>Smd drehen</td></tr>
<tr><td><a href=#102>SPLIT</a>        </td><td width=20><td>Wire-Knickwinkel &auml;ndern</td></tr>
<tr><td><a href=#104>TEXT</a>          </td><td width=20><td>Text drehen</td></tr>
<tr><td><a href=#112>WIRE</a>          </td><td width=20><td>Wire-Knickwinkel &auml;ndern</td></tr>
</table>
<h2>Maus-R&auml;dchen</h2>
Innerhalb eines Editor-Fensters kann mit dem Maus-R&auml;dchen die Zoomstufe ver&auml;ndert
werden.


<a name=21>
<h1>Benachbarte Objekte selektieren</h1>
Wenn Sie an einer Stelle ein Objekt selektieren wollen, an der mehrere
Objekte eng beieinander liegen, nimmt der Mauszeiger die Form eines
Vierfach-Pfeils an, und es erscheint die Frage
<p>
<i>Hervorgehobenes Objekt ausw&auml;hlen? (links=ja, rechts=weiter, ESC=abbrechen)</i>
<p>
Dr&uuml;cken Sie die rechte Maustaste, um zyklisch durch alle in Frage
kommenden Objekte "durchzutasten".
<p>
Mit der linken Maustaste w&auml;hlen Sie das gew&uuml;nschte Objekt aus.
<p>
Um die Auswahl ganz abzubrechen, dr&uuml;cken Sie die Esc-Taste.
<p>
Mit dem Befehl
<pre>
<a href=#97>SET</a> Select_Factor select_radius;
</pre>
k&ouml;nnen Sie beeinflussen, wie gro&szlig; der "Selektionsradius" sein soll.
<p>
Wurde die urspr&uuml;ngliche Selektion mit der rechten Maustaste gemacht, so erscheint
ein kontextspezifisches Popup-Men&uuml; f&uuml;r das erste ausgew&auml;hlte Objekt, welches als
ersten Eintrag "Weiterschalten" enth&auml;lt. Durch Klicken auf diesen Eintrag wird
zyklisch durch die Objekte im Selektionsradius geschaltet.


<a name=22>
<h1>Editor-Fenster</h1>
EAGLE kennt unterschiedliche Typen von Daten-Dateien. Jeder davon wird in
einem eigenen Editor-Fenster-Typ bearbeitet. Wenn Sie eines der Objekte
durch Doppelklick selektieren oder vom <a href=#13>Control Panel</a>
aus eine Datei mit <b>Datei/&Ouml;ffnen</b>
laden, dann &ouml;ffnet sich ein Editor-Fenster f&uuml;r diesen Dateityp.
<ul>
<li><a href=#23>Bibliotheks-Editor</a>
<li><a href=#26>Schaltplan-Editor</a>
<li><a href=#25>Layout-Editor</a>
<li><a href=#27>Text-Editor</a>
</ul>


<a name=23>
<h1>Bibliotheks-Editor</h1>
Der <i>Bibliotheks-Editor</i> dient dazu, Bauelemente-Bibliotheken
(<tt>*.lbr</tt>) zu editieren.
<p>
Nachdem Sie ein neues Bibliotheks-Editor-Fenster ge&ouml;ffnet haben,
erscheint eine leere Arbeitsfl&auml;che, und Sie m&uuml;ssen mit dem
<a href=#49>EDIT</a> Befehl angeben, welches
Geh&auml;use (Package), Symbol oder Device Sie laden oder neu anlegen wollen.


<a name=24>
<h1>Bibliotheks-Editier-Modus</h1>
Im Bibliotheks-Editier-Modus k&ouml;nnen Sie Packages, Symbole und Devices
editieren.
<p>
<b>Package:</b> Die Geh&auml;use-Definition.
<p>
<b>Symbol:</b> Schaltzeichen, wie es im Schaltplan erscheinen soll.
<p>
<b>Device:</b> Definition des realen Bauteils. Enth&auml;lt eine oder
mehrere Package-Varianten und ein oder mehrere Symbole (Gates).
Es d&uuml;rfen unterschiedliche Symbole kombiniert werden.
<p>
Klicken Sie den Button <b>Dev</b>, <b>Pac</b>
oder <b>Sym</b>, um Devices, Packages oder Symbole zu
selektieren.
<p>
Wenn Sie ein neues Objekt anlegen wollen, schreiben Sie den Namen des
neuen Objekts in das Feld <b>New</b> Sie k&ouml;nnen auch ein
exitstierendes Objekt laden, indem Sie seinen Namen in dieses Feld
eintippen. Wenn Sie die Extension des Datei-Namens nicht angeben, wird
ein Objekt geladen, dessen Typ vom <b>Choose...</b> Prompt
bestimmt wird. Andernfalls bestimmt die Extension den Typ.
<p>
Falls Ihre <a href=#376>Lizenz</a> das
Schaltplan-Modul nicht einschlie&szlig;t, erscheinen die Object-Type-Buttons
(<b>Dev</b>...) nicht im Men&uuml;.


<a name=25>
<h1>Layout-Editor</h1>
Der <i>Layout-Editor</i> dient dazu, Layouts (<tt>*.brd</tt>) zu editieren.
<p>
Wenn im selben Verzeichnis eine Schaltplan-Datei (<tt>*.sch</tt>) mit
demselben Namen existiert, wird beim &Ouml;ffnen eines Layouts automatisch
auch ein <a href=#26>Schaltplan-Editor</a>-Fenster
mit dieser Datei als Icon auf den Desktop
gelegt. Das ist notwendig, damit die Schaltplan-Datei geladen ist, wenn
&Auml;nderungen an der Platine die <a href=#372>Back-Annotation</a>
zum Schaltplan erforderlich machen.


<a name=26>
<h1>Schaltplan-Editor</h1>
Der <i>Schaltplan-Editor</i> dient dazu, Schaltpl&auml;ne (<tt>*.sch</tt>)
zu editieren.
<p>
Wenn im selben Verzeichnis eine Layout-Datei (<tt>*.brd</tt>) mit
demselben Namen existiert, wird beim &Ouml;ffnen eines Layouts automatisch
auch ein <a href=#25>Layout-Editor</a>-Fenster
mit dieser Datei als Icon auf den Desktop
gelegt. Das ist notwendig, damit die Layout-Datei geladen ist, wenn
&Auml;nderungen an der Platine die
<a href=#372>Forward-Annotation</a>
zum Layout erforderlich machen.
<p>
Mit Hilfe der Combo-Box in der Action-Toolbar des Schaltplan-Editor-Fensters
k&ouml;nnen Sie zwischen den einzelnen Schaltplan-Seiten
wechseln oder neue Seiten anlegen. Sie k&ouml;nnen dazu auch den
<a href=#49>EDIT</a>-Befehl verwenden.


<a name=27>
<h1>Text-Editor</h1>
Der <i>Text-Editor</i> dient dazu, Textdateien zu editieren.
<p>
Die Textdatei muss eine reine ASCII-Datei sein und darf keine
Steuerzeichen enthalten. Als Anwendungen sind in erster Linie
vorgesehen: das Schreiben von
<a href=#144>User-Language-Programmen</a> und
<a href=#96>Script-Dateien</a>.
<h2>Verwenden eines externen Text-Editors</h2>
Falls Sie anstatt des in EAGLE eingebauten lieber einen externen Text-Editor
verwenden wollen, so k&ouml;nnen Sie den zum Starten dieses Editors n&ouml;tigen Befehl
im Dialog "Optionen/Benutzeroberfl&auml;che" eintragen.
<p>
In diesem Befehl werden die folgenden Platzhalter durch aktuelle Werte ersetzt:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%C</tt></td><td width=20><td>die Spalte, in die der Cursor positioniert werden soll (zur Zeit immer <tt>1</tt>)</td></tr>
<tr><td><tt>%F</tt></td><td width=20><td>der Name der zu ladenden Datei</td></tr>
<tr><td><tt>%L</tt></td><td width=20><td>die Zeile, in die der Cursor positioniert werden soll</td></tr>
</table>
<p>
Ist als Befehl lediglich ein Minuszeichen (<tt>'-'</tt>) eingetragen, so wird
EAGLE niemals ein Text-Editor-Fenster &ouml;ffnen. Dies ist hilfreich f&uuml;r Benutzer,
die ihren Text-Editor immer selbst starten wollen.
<p>
Folgende Einschr&auml;nkungen gelten bei der Verwendung eines externen Text-Editors:
<ul>
<li>Der externe Text-Editor l&auml;uft in einem separaten Prozess, und EAGLE hat
    keine M&ouml;glichkeit zu wissen ob die geladene Datei ver&auml;ndert worden ist
    oder nicht. Sie sind selber daf&uuml;r verantwortlich, die Datei nach eventuellen
    &Auml;nderungen abzuspeichern.
<li>Wird die selbe Datei mehrfach in den Text-Editor geladen, so h&auml;ngt es von der
    Konfiguration des verwendeten Text-Editors ab, ob dieser jedesmal ein neues
    Fenster &ouml;ffnet, oder die Datei immer in das selbe Fenster l&auml;dt.
<li>Die Fenster des externen Text-Editors erscheinen nicht in der Liste der EAGLE-Fenster,
    und werden daher auch nicht im Projekt mit abgespeichert und somit auch bei einem
    sp&auml;teren Neu-Laden des Projekts nicht wieder ge&ouml;ffnet.
<li>Beim Verlassen von EAGLE werden die externen Text-Editor-Prozesse beendet.
    Es h&auml;ngt vom verwendeten Betriebssystem und dem konkreten Text-Editor ab,
    ob Sie im Falle einer ver&auml;nderten Datei gefragt werden, ob diese abgespeichert
    werden soll.
<li>Die Funktion "Datei/Alles speichern" speichert nicht die im externen Text-Editor
    ge&auml;nderten Dateien.
<li>Der unter Umst&auml;nden beim Laden einer Datei aus einer &auml;lteren EAGLE-Version
    erzeugte Update-Bericht wird immer mit dem eingebauten Text-Editor angezeigt.
</ul>


<a name=28>
<h1>Editor-Befehle</h1>
<h2>Wechsel der Betriebsart/Dateibefehle</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#40>CLOSE</a>     </td><td width=20><td>Bibliothek nach Editieren schlie&szlig;en</td></tr>
<tr><td><a href=#49>EDIT</a>      </td><td width=20><td>Zeichnung laden/anlegen</td></tr>
<tr><td><a href=#52>EXPORT</a>    </td><td width=20><td>ASCII-Liste erzeugen (z.B. Netzliste)</td></tr>
<tr><td><a href=#74>OPEN</a>      </td><td width=20><td>Bibliothek zum Editieren laden</td></tr>
<tr><td><a href=#85>QUIT</a>      </td><td width=20><td>EAGLE verlassen</td></tr>
<tr><td><a href=#89>REMOVE</a>    </td><td width=20><td>Dateien/Bibliotheks-Elemente l&ouml;schen</td></tr>
<tr><td><a href=#96>SCRIPT</a>    </td><td width=20><td>Befehlsdatei ausf&uuml;hren</td></tr>
<tr><td><a href=#107>USE</a>       </td><td width=20><td>Bibliothek zum Plazieren von Elementen laden</td></tr>
<tr><td><a href=#113>WRITE</a>     </td><td width=20><td>Zeichnung/Bibliothek speichern</td></tr>
</table>
<h2>Zeichnungen/Bibliotheken editieren</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#30>ADD</a>       </td><td width=20><td>Element in Zeichnung / Symbol in Device einf&uuml;gen</td></tr>
<tr><td><a href=#31>ARC</a>       </td><td width=20><td>Kreisbogen zeichnen</td></tr>
<tr><td><a href=#33>ATTRIBUTE</a>  </td><td width=20><td>Attribute definieren</td></tr>
<tr><td><a href=#38>CIRCLE</a>    </td><td width=20><td>Kreis zeichnen</td></tr>
<tr><td><a href=#39>CLASS</a>    </td><td width=20><td>Netzklassen definieren</td></tr>
<tr><td><a href=#42>COPY</a>      </td><td width=20><td>Objekte/Elemente kopieren</td></tr>
<tr><td><a href=#43>CUT</a>       </td><td width=20><td>Vorher definierte Gruppe in die Zwischenablage kopieren</td></tr>
<tr><td><a href=#44>DELETE</a>    </td><td width=20><td>Objekt l&ouml;schen</td></tr>
<tr><td><a href=#45>DESCRIPTION</a> </td><td width=20><td>Beschreibung eines Objektes &auml;ndern</td></tr>
<tr><td><a href=#56>GROUP</a>     </td><td width=20><td>Gruppe f&uuml;r sp&auml;tere Operation definieren</td></tr>
<tr><td><a href=#58>HOLE</a>      </td><td width=20><td>Nichtleitende Bohrung definieren</td></tr>
<tr><td><a href=#63>LAYER</a>     </td><td width=20><td>Layer definieren/wechseln</td></tr>
<tr><td><a href=#68>MIRROR</a>    </td><td width=20><td>Objekt spiegeln</td></tr>
<tr><td><a href=#69>MITER</a>    </td><td width=20><td>Wire-Verbindungsstellen abschr&auml;gen</td></tr>
<tr><td><a href=#70>MODULE</a>  </td><td width=20><td>Modul und Modul-Instanz erzeugen</td></tr>
<tr><td><a href=#71>MOVE</a>      </td><td width=20><td>Objekt bewegen oder rotieren</td></tr>
<tr><td><a href=#72>NAME</a>      </td><td width=20><td>Objekt mit Namen versehen</td></tr>
<tr><td><a href=#78>PASTE</a>     </td><td width=20><td>Inhalt der Zwischenablage in die Zeichnung einf&uuml;gen</td></tr>
<tr><td><a href=#82>PORT</a>   </td><td width=20><td>Port zu einem Modul hinzuf&uuml;gen</td></tr>
<tr><td><a href=#81>POLYGON</a>   </td><td width=20><td>Polygon zeichnen</td></tr>
<tr><td><a href=#87>RECT</a>      </td><td width=20><td>Rechteck zeichnen</td></tr>
<tr><td><a href=#93>ROTATE</a>    </td><td width=20><td>Objekt rotieren</td></tr>
<tr><td><a href=#100>SMASH</a>     </td><td width=20><td>NAME/VALUE zum Bewegen vorbereiten</td></tr>
<tr><td><a href=#102>SPLIT</a>     </td><td width=20><td>Wires/Linien (Netze etc.) knicken</td></tr>
<tr><td><a href=#104>TEXT</a>      </td><td width=20><td>Text zu einer Zeichnung hinzuf&uuml;gen</td></tr>
<tr><td><a href=#108>VALUE</a>     </td><td width=20><td>Wert f&uuml;r Element definieren/&auml;ndern</td></tr>
<tr><td><a href=#112>WIRE</a>      </td><td width=20><td>Linie oder geroutete Verbindung zeichnen</td></tr>
</table>
<h2>Spezielle Befehle f&uuml;r Platinen</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#48>DRC</a>       </td><td width=20><td>Design Rule Check durchf&uuml;hren</td></tr>
<tr><td><a href=#51>ERRORS</a>    </td><td width=20><td>DRC-Fehler anzeigen</td></tr>
<tr><td><a href=#64>LOCK</a>    </td><td width=20><td>Bauteilposition verriegeln</td></tr>
<tr><td><a href=#86>RATSNEST</a>  </td><td width=20><td>K&uuml;rzeste Luftlinien anzeigen</td></tr>
<tr><td><a href=#91>REPLACE</a>   </td><td width=20><td>Bauteil ersetzen</td></tr>
<tr><td><a href=#92>RIPUP</a>     </td><td width=20><td>Signal aufl&ouml;sen</td></tr>
<tr><td><a href=#94>ROUTE</a>     </td><td width=20><td>Signal routen</td></tr>
<tr><td><a href=#99>SIGNAL</a>    </td><td width=20><td>Signal (Luftlinie) definieren</td></tr>
<tr><td><a href=#110>VIA</a>       </td><td width=20><td>Durchkontaktierung (Via) plazieren</td></tr>
</table>
<h2>Spezielle Befehle f&uuml;r Schaltpl&auml;ne</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#35>BOARD</a>      </td><td width=20><td>Platine aus einem Schaltplan erzeugen</td></tr>
<tr><td><a href=#36>BUS</a>       </td><td width=20><td>Buslinie zeichnen</td></tr>
<tr><td><a href=#50>ERC</a>       </td><td width=20><td>Electrical Rule Check ausf&uuml;hren</td></tr>
<tr><td><a href=#54>GATESWAP</a>  </td><td width=20><td>&Auml;quivalente 'Gates' tauschen</td></tr>
<tr><td><a href=#60>INVOKE</a>    </td><td width=20><td>'Gate' aus Device plazieren</td></tr>
<tr><td><a href=#61>JUNCTION</a>  </td><td width=20><td>Verbindungspunkt plazieren</td></tr>
<tr><td><a href=#62>LABEL</a>     </td><td width=20><td>Label f&uuml;r Bus oder Netz plazieren</td></tr>
<tr><td><a href=#73>NET</a>       </td><td width=20><td>Netz definieren</td></tr>
<tr><td><a href=#80>PINSWAP</a>   </td><td width=20><td>&Auml;quivalente Pins tauschen</td></tr>
</table>
<h2>Spezielle Befehle f&uuml;r Bibliotheken</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#41>CONNECT</a>   </td><td width=20><td>Pin/Pad-Zuordnung festlegen</td></tr>
<tr><td><a href=#76>PACKAGE</a>   </td><td width=20><td>Package f&uuml;r Device definieren</td></tr>
<tr><td><a href=#77>PAD</a>       </td><td width=20><td>Pad in Package einf&uuml;gen</td></tr>
<tr><td><a href=#79>PIN</a>       </td><td width=20><td>Pin in Symbol einf&uuml;gen</td></tr>
<tr><td><a href=#83>PREFIX</a>    </td><td width=20><td>Default-Pr&auml;fix f&uuml;r Device festlegen</td></tr>
<tr><td><a href=#89>REMOVE</a>    </td><td width=20><td>Elemente aus Bibliothek l&ouml;schen</td></tr>
<tr><td><a href=#90>RENAME</a>    </td><td width=20><td>Symbol/Package/Device neu benennen</td></tr>
<tr><td><a href=#101>SMD</a>       </td><td width=20><td>Smd-Pad in Package einf&uuml;gen</td></tr>
<tr><td><a href=#103>TECHNOLOGY</a> </td><td width=20><td>Technologien f&uuml;r ein Device definieren</td></tr>
<tr><td><a href=#108>VALUE</a>     </td><td width=20><td>Definieren, ob Value-Text &auml;nderbar</td></tr>
</table>
<h2>Befehle f&uuml;r Bildschirmdarstellung und Benutzer-Interface</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#32>ASSIGN</a>    </td><td width=20><td>Tasten belegen</td></tr>
<tr><td><a href=#37>CHANGE</a>    </td><td width=20><td>EAGLE-Parameter &auml;ndern</td></tr>
<tr><td><a href=#47>DISPLAY</a>   </td><td width=20><td>Layer anzeigen/ausblenden</td></tr>
<tr><td><a href=#55>GRID</a>      </td><td width=20><td>Raster/Einheit definieren</td></tr>
<tr><td><a href=#67>MENU</a>      </td><td width=20><td>Befehls-Men&uuml; konfigurieren</td></tr>
<tr><td><a href=#97>SET</a>       </td><td width=20><td>Programm-Parameter einstellen</td></tr>
<tr><td><a href=#111>WINDOW</a>    </td><td width=20><td>Bildausschnitt ver&auml;ndern</td></tr>
</table>
<h2>Weitere Befehle</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#34>AUTO</a>      </td><td width=20><td>Autorouter starten</td></tr>
<tr><td><a href=#57>HELP</a>      </td><td width=20><td>Hilfe-Seite anzeigen</td></tr>
<tr><td><a href=#59>INFO</a>      </td><td width=20><td>Information &uuml;ber Objekt zeigen</td></tr>
<tr><td><a href=#65>MARK</a>      </td><td width=20><td>Messmarke setzen/entfernen</td></tr>
<tr><td><a href=#75>OPTIMIZE</a>  </td><td width=20><td>Wire-Segmente zusammenfassen</td></tr>
<tr><td><a href=#84>PRINT</a>    </td><td width=20><td>Ausdrucken auf dem System-Drucker</td></tr>
<tr><td><a href=#88>REDO</a>      </td><td width=20><td>Zur&uuml;ckgenommene Befehle ausf&uuml;hren</td></tr>
<tr><td><a href=#95>RUN</a>        </td><td width=20><td>User-Language-Programm ausf&uuml;hren</td></tr>
<tr><td><a href=#98>SHOW</a>      </td><td width=20><td>Objekt hell darstellen</td></tr>
<tr><td><a href=#105>UNDO</a>      </td><td width=20><td>Befehle zur&uuml;cknehmen</td></tr>
<tr><td><a href=#106>UPDATE</a>  </td><td width=20><td>Bibliotheks-Objekte aktualisieren</td></tr>
</table>


<a name=29>
<h1>Befehlseingabe</h1>
EAGLE-Befehle k&ouml;nnen auf vier verschiedene Arten eingegeben werden:
<ul>
<li>mit der Tastatur als Text
<li>mit der Maus, durch Anklicken von Men&uuml;punkten oder Icons
<li>mit belegten Tasten (siehe <a href=#32>ASSIGN</a>-Befehl)
<li>mit einer Script-Datei (siehe <a href=#96>SCRIPT</a>-Befehl)
</ul>
Diese Eingabearten k&ouml;nnen auch gemischt verwendet werden.
<p>
F&uuml;r die Befehlsbeschreibungen gelten folgende Regeln:
<p>
Befehle und Parameter in <tt>GROSSBUCHSTABEN</tt> werden
direkt eingegeben (bzw. aus dem Befehlsmen&uuml; mit der Maus selektiert).
Bei der Eingabe werden Gro&szlig;- und Kleinbuchstaben nicht unterschieden.
<p>
Parameter in <tt>Kleinbuchstaben</tt> werden durch Namen, Zahlenwerte oder
Schl&uuml;sselw&ouml;rter ersetzt. Beispiel:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Syntax:   </td><td width=20><td><tt>GRID grid_size grid_multiple;</tt></td></tr>
<tr><td>Input:    </td><td width=20><td><tt>GRID 1 10;</tt></td></tr>
</table>
<h2>Verk&uuml;rzte Eingabe</h2>
Befehle und andere Schl&uuml;sselw&ouml;rter k&ouml;nnen beliebig abgek&uuml;rzt werden,
solange sie nicht mit anderen Schl&uuml;sselw&ouml;rtern verwechselt werden
k&ouml;nnen.
<h2>Alternative Parameter</h2>
Das Zeichen | bedeutet, dass Parameter alternativ angegeben werden
k&ouml;nnen. Beispiel:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Syntax:   </td><td width=20><td><tt>SET BEEP OFF | ON;</tt></td></tr>
<tr><td>Input:    </td><td width=20><td><tt>SET BEEP OFF;</tt></td></tr>
<tr><td>          </td><td width=20><td>oder</td></tr>
<tr><td>          </td><td width=20><td><tt>SET BEEP ON;</tt></td></tr>
</table>
<h2>Wiederholungspunkte</h2>
Die Zeichen .. bedeuten, dass die Funktion mehrfach ausgef&uuml;hrt
werden kann bzw. dass mehrere Parameter vom gleichen Typ erlaubt
sind. Beispiel:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Syntax:   </td><td width=20><td><tt>DISPLAY option layer_name..</tt></td></tr>
<tr><td>Input:    </td><td width=20><td><tt>DISPLAY TOP PINS VIAS</tt></td></tr>
</table>
<h2>Koordinatenangaben</h2>
Das Zeichen &#149; bedeutet normalerweise, dass an dieser Stelle im Befehl mit der
linken Maustaste ein Objekt anzuklicken ist. Beispiel:
<p>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Syntax:   </td><td width=20><td><tt>MOVE &#149; &#149;..</tt></td></tr>
<tr><td>Input:    </td><td width=20><td><tt>MOVE</tt></td></tr>
<tr><td>          </td><td width=20><td><tt>Mausklick auf erstes zu bewegendes Element</tt></td></tr>
<tr><td>          </td><td width=20><td><tt>Mausklick auf das Ziel</tt></td></tr>
<tr><td>          </td><td width=20><td><tt>Mausklick auf zweites zu bewegendes Element</tt></td></tr>
<tr><td>          </td><td width=20><td><tt>etc.</tt></td></tr>
</table>
<p>
An diesem Beispiel sehen Sie auch, wie die Wiederholungspunkte bei
Befehlen mit Mausklicks zu verstehen sind.
<p>
Jeder Mausklick stellt eine Koordinatenangabe
dar. Will man den Befehl textuell eingeben, dann kann man anstelle
des Mausklicks die Koordinaten &uuml;ber die Tastatur in folgender
Form eingeben:
<pre>
(x y)
</pre>
Dabei sind x und y Zahlen in der mit dem GRID-Befehl gew&auml;hlten
Einheit. Die textuelle Eingabem&ouml;glichkeit ist insbesondere f&uuml;r
Script-Dateien erforderlich.<br>
Soll eine andere als die im GRID-Befehl gew&auml;hlte Einheit verwendet werden,
so kann diese an die angegebenen Koordinaten angef&uuml;gt werden, wie in
<pre>
(100mil 200mil)
</pre>
Erlaubte Einheiten sind <tt>mm</tt>, <tt>mic</tt>, <tt>mil</tt> und <tt>in</tt>.
Es k&ouml;nnen auch unterschiedliche Einheiten f&uuml;r x und y verwendet werden.<br>
Die spezielle Koordinate
<pre>
(@)
</pre>
kann dazu benutzt werden, die aktuelle Position des Mauszeigers im
Zeichenfenster zu referenzieren. So w&uuml;rde zum Beispiel die Eingabe
<pre>
MOVE R1 (@)
</pre>
das Bauteil mit dem Namen R1 an die Position verschieben, auf der
der Mauszeiger im Moment steht.
<p>
Nach der &ouml;ffnenden Klammer darf eine beliebige Kombination der folgenden
Steuerzeichen folgen um einen bestimmten Tastendruck zusammen mit dem
"Mausklick" zu simulieren oder die Art der Koordinaten zu modifizieren:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>&gt;</tt></td><td width=20><td>rechte Maustaste</td></tr>
<tr><td><tt>A   </tt></td><td width=20><td>Alt-Taste</td></tr>
<tr><td><tt>C   </tt></td><td width=20><td>Ctrl-Taste</td></tr>
<tr><td><tt>P   </tt></td><td width=20><td>Polar-Koordinaten (relativ zur <a href=#65>Marke</a>, x = Radius, y = Winkel in Grad, gegen den Uhrzeigersinn)</td></tr>
<tr><td><tt>R   </tt></td><td width=20><td>Relative Koordinaten (relativ zur <a href=#65>Marke</a>)</td></tr>
<tr><td><tt>S   </tt></td><td width=20><td>Shift-Taste</td></tr>
</table>
Die Eingabe
<pre>
(CR&gt; 1 2)
</pre>
w&uuml;rde zum Beispiel einem "Mausklick" mit der rechten Maustaste an den Koordinaten
(1&nbsp;2) relativ zur <a href=#65>Marke</a>, mit gedr&uuml;ckter Ctrl-Taste entsprechen
(nat&uuml;rlich w&uuml;rde es vom konkreten Befehl abh&auml;ngen was genau mit dieser Art von
Eingabe geschehen w&uuml;rde). Falls momentan keine Marke gesetzt ist, beziehen sich
Koordinaten mit <tt>R</tt> oder <tt>P</tt> auf den Ursprung der Zeichnung.
Die Steuerzeichen sind unabh&auml;ngig von Gro&szlig;-/Kleinschreibung, ihre Reihenfolge
spielt keine Rolle und es muss auch kein Leerzeichen zwischen ihnen und der
ersten Ziffer der Koordinaten stehen. Das obige Beispiel k&ouml;nnte also ebenso
als <tt>(r&gt;c1&nbsp;2)</tt> geschrieben werden.
Als "Polar-Koordinaten" eingegebene Werte werden intern als die entsprechenden
(x&nbsp;y) Koordinaten abgespeichert.
<p>
Als Beispiel f&uuml;r die Koordinateneingabe in Textform soll die Eingabe der
Platinenumrisse mit exakten Ma&szlig;en dienen:
<pre>
GRID 1 MM;
CHANGE LAYER DIMENSION;
WIRE 0 (0 0) (160 0) (160 100) (0 100) (0 0);
GRID LAST;
</pre>
<h2>Dezimalzahlen</h2>
Bei der Eingabe von Dezimalzahlen in der Kommandozeile des Editor-Fensters
oder in Dialog-Eingabefeldern k&ouml;nnen Sie das Komma als Dezimal-Trennzeichen
verwenden (also zum Beispiel <tt>12,34</tt>), falls Ihre landesspezifischen
Einstellungen dies zulassen. Allerdings sollten Sie beim Schreiben eines Scripts
oder eines ULPs, welches EAGLE-Befehle &uuml;ber die <tt>exit()</tt>-Funktion
zur&uuml;ckgibt, immer den Punkt als Dezimal-Trennzeichen verwenden (also <tt>12.34</tt>).
Ansonsten kann es sein, dass Ihr Script bzw. ULP nicht auf anderen Systemen
lauff&auml;hig ist. Generell ist es empfehlenswert, immer den Punkt als
Dezimal-Trennzeichen zu verwenden.
<h2>Strichpunkt</h2>
Der Strichpunkt (';') schlie&szlig;t einen Befehl ab. Ein Befehl muss dann
mit einem Strichpunkt abgeschlossen werden, wenn er weniger als die
maximal m&ouml;gliche Zahl von Parametern enth&auml;lt.
Der Befehl
<pre>
WINDOW;
</pre>
frischt beispielsweise das Zeichenfenster auf, w&auml;hrend
<pre>
WINDOW FIT
</pre>
das Zeichenfenster so skaliert, dass die gesamte Zeichnung sichtbar ist.
Im zweiten Fall ist kein Strichpunkt erforderlich, weil bereits klar
ist, dass kein weiterer Parameter folgen kann.


<a name=30>
<h1>ADD</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Elemente in eine Zeichnung einf&uuml;gen.<br>
Symbole in ein Device einf&uuml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>ADD package_name[@library_name] [name] [orientation] &#149;..</tt><br>
<tt>ADD device_name[@library_name]  [name [gate]] [orientation] &#149;..</tt><br>
<tt>ADD symbol_name                 [name] [options] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> spiegelt das Bauteil.<br>
<mb>Rechte</mb> dreht das Bauteil.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#106>UPDATE</a>,
<a href=#107>USE</a>,
<a href=#60>INVOKE</a>
<p>
Der ADD-Befehl holt ein Schaltplan-Symbol (Gate) oder ein Package aus
der aktiven Bibliothek und plaziert es in der Zeichnung.
<p>
Bei der Device-Definition holt der ADD-Befehl ein Symbol in das Device.
<p>
&Uuml;blicherweise klickt man den ADD-Befehl an und selektiert das
Package/Symbol aus dem sich &ouml;ffnenden Men&uuml;. Nun k&ouml;nnen die Parameter
(falls erforderlich) per Tastatur eingegeben werden.
<p>
Wenn <tt>device_name</tt> Platzhalter enth&auml;lt (<tt>'*'</tt> oder <tt>'?'</tt>) und mehr als ein
Device gefunden wird, &ouml;ffnet sich der ADD-Dialog. Daraus kann dann das gew&uuml;nschte
Device gew&auml;hlt werden.
Beachten Sie, dass die <i>Beschreibung</i> Checkbox im ADD-Dialog ausgeschaltet wird,
sobald ein ADD-Befehl mit einem Device-Namen in der Kommandozeile angegeben wird,
egal ob der Name Platzhalter enth&auml;lt oder nicht. Der Grund hierf&uuml;r ist, dass ein
in der Kommandozeile angegebener Device-Name nur in den Namen der Devices gesucht
wird und nicht in deren Beschreibungen.
<p>
Plaziert wird das Package/Symbol mit der linken Maustaste, rotiert
wird es mit der rechten. Nachdem es plaziert wurde, h&auml;ngt sofort eine
weitere Kopie am Mauszeiger.
<p>
Wenn bereits ein Device oder Package mit gleichem Namen (aus derselben Bibliothek) in der
Zeichnung existiert und die Bibliothek seit dem Plazieren des urspr&uuml;nglichen Elements
modifiziert wurde, startet EAGLE automatisch einen <a href=#106>Library-Update</a>
bei dem Sie gefragt werden, ob die Bauteile durch die neuere Bibliotheksdefinition
ersetzt werden sollen.
<b>Achtung: Nach einem Library-Update sollten Sie immer den <a href=#48>Design Rule Check</a>
(DRC) und den <a href=#50>Electrical Rule Check</a> (ERC) laufen lassen!</b>
<h2>Package oder Symbol in Zeichnung holen</h2>
<h3>Platzhalter</h3>
Der ADD-Befehl kann mit Platzhaltern (<tt>'*'</tt> oder <tt>'?'</tt>) arbeiten, um ein
bestimmtes Element zu finden. Der ADD-Dialog zeigt alle gefundenen Elemente in einer
Baumansicht und dazu auch eine Voransicht des Devices und der Package-Variante.
<p>
Um ein Element direkt zu plazieren, verwenden Sie die Syntax:
<pre>
ADD devicename@libraryname
</pre>
<tt>devicename</tt> darf Platzhalter enthalten und <tt>libraryname</tt> darf entweder
direkt der Bibliotheksname (wie "ttl" oder "ttl.lbr") oder der volle Name mit Pfadangabe
(wie "/home/mydir/myproject/ttl.lbr" oder "../lbr/ttl") sein. Im Falle von Leerzeichen
im Pfad ist der Gesamtausdruck von Hochkommas einzuschlie&szlig;en (z.B. ADD 'DEV1A@/home/my dir/ttl.lbr').
<h3>Namen</h3>
Der Parameter package_name, device_name bzw. symbol_name ist der Name, unter dem das
Package/Device/Symbol in der Bibliothek abgelegt ist. Er wird &uuml;blicherweise aus einem
Men&uuml; selektiert. Der Parameter name ist der Name, den das Element in der Zeichnung erhalten
soll. Falls der Name als eine Orientierung oder Option interpretiert werden k&ouml;nnte,
muss er in Hochkommas eingeschlossen werden. Wird er nicht explizit angegeben, erh&auml;lt
das Element einen generierten Namen.
<p>
Beispiel:
<pre>
ADD DIL14 IC1 &#149;
</pre>
holt das Package DIL14 in die Platine und gibt ihm den Namen IC1.
<p>
Wird im Schaltplan kein Name angegeben, erh&auml;lt das Gate als Namen den bei der
Device-Definition mit <a href=#83>PREFIX</a> festgelegten Pr&auml;fix, erg&auml;nzt
um eine fortlaufende Zahl (z.B. IC1).
<p>
Beispiel:
<pre>
ADD 7400 &#149; &#149; &#149; &#149; &#149;
</pre>
Hier werden der Reihe nach f&uuml;nf Gatter aus Bausteinen des Typs 7400 plaziert.
Sofern als Pr&auml;fix "IC" definiert wurde und die Einzelgatter innerhalb eines 7400
die Namen A...D haben, erhalten die Gatter im Schaltplan die Namen IC1A, IC1B,
IC1C, IC1D, IC2A (falls schon Elemente mit demselben Pr&auml;fix plaziert wurden,
wird die Z&auml;hlung mit der n&auml;chsten laufenden Nummer fortgesetzt. Siehe auch
<a href=#60>INVOKE</a>.
<p>
W&auml;hrend ein Objekt am Cursor h&auml;ngt, k&ouml;nnen Sie den Namen, unter dem es in die
Zeichnung eingef&uuml;gt wird, &auml;ndern. Damit k&ouml;nnen Sie mehrere Bauteile gleichen
Typs unter verschiedenen, explizit vergebenen Namen einf&uuml;gen:
<p>
Beispiel:
<pre>
ADD CAP C1 &#149; C5 &#149; C7 &#149;
</pre>
<h3>Bestimmte Gatter</h3>
Um ein bestimmtes Gatter eines neu hinzugef&uuml;gten Bausteins zu holen kann nach dem Bauteilnamen der Name des Gatters angegeben werden:
<p>
Beispiel:
<pre>
ADD 7400 IC1 A &#149;
</pre>
Dies ist vor allem daf&uuml;r gedacht, wenn ein Schaltplan &uuml;ber ein Script generiert werden soll.
Beachten Sie bitte, dass wenn ein bestimmtes Gatter geholt wird keine anderen Gatter mit
Add-Level MUST oder ALWAYS automatisch mit geholt werden, und Sie m&uuml;ssen zumindest die MUST-Gatter
mit dem <a href=#60>INVOKE</a>-Befehl aktivieren (ansonsten wird sie der
<a href=#50>Electrical Rule Check</a> als fehlend melden).
<h3>Orientation</h3>
Dieser Parameter gibt die Ausrichtung des Objektes in der Zeichnung an.
Normalerweise rotiert man Objekte mit der rechten Maustaste.
In <a href=#96>Script</a>-Dateien verwendet man die textuellen Angaben f&uuml;r diesen
Parameter:
<p>
<b><tt>[S][M]Rnnn</tt></b>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b><tt>S</tt></b>   </td><td width=20><td>setzt das <b>S</b>pin-Flag, welches die Funktion abschaltet, die Texte von unten oder rechts lesbar h&auml;lt (nur im Board-Kontext verf&uuml;gbar)</td></tr>
<tr><td><b><tt>M</tt></b>   </td><td width=20><td>setzt das <b>M</b>irror-Flag, welches das Objekt an der Y-Achse spiegelt</td></tr>
<tr><td><b><tt>Rnnn</tt></b></td><td width=20><td>setzt die <b>R</b>otation auf den angegebenen Wert, der im Board-Kontext im Bereich <tt>0.0</tt>...<tt>359.9</tt> (mit einer Aufl&ouml;sung von 0.1 Grad) und im Schaltplan-Kontext einer der Werte <tt>0</tt>, <tt>90</tt>, <tt>180</tt> oder <tt>270</tt> sein darf (Winkel d&uuml;rfen auch negativ angegeben werden, sie werden dann in den entsprechenden positiven Wert umgewandelt)</td></tr>
</table>
<p>
Die Schl&uuml;sselbuchstaben <b><tt>S</tt></b>, <b><tt>M</tt></b> und <b><tt>R</tt></b>
k&ouml;nnen als Gro&szlig;- oder Kleinbuchstaben angegeben werden und es muss mindestens <b><tt>R</tt></b>
gefolgt von einer Zahl vorhanden sein.
<p>
Ist das <b>M</b>irror-Flag sowohl in einem Bauteil als auch in einem in dessen
Package befindlichen Text gesetzt, so heben sich diese in ihrer Wirkung auf.
Das gleiche gilt f&uuml;r das <b>S</b>pin-Flag.
<p>
Beispiele:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>R0 </td><td width=20><td>keine Rotation</td></tr>
<tr><td>R90    </td><td width=20><td>um 90&deg; gegen den Uhrzeigersinn gedreht</td></tr>
<tr><td>R-90   </td><td width=20><td>um 90&deg; im Uhrzeigersinn gedreht (wird in 270&deg; umgerechnet)</td></tr>
<tr><td>MR0    </td><td width=20><td>an der Y-Achse gespiegelt</td></tr>
<tr><td>SR0    </td><td width=20><td>Texte werden mit "Spin" dargestellt</td></tr>
<tr><td>SMR33.3</td><td width=20><td>um 33.3&deg; gegen den Uhrzeigersinn gedreht, gespiegelt und mit "Spin"</td></tr>
</table>
<p>
<p>
Default: R0
<p>
<pre>
ADD DIL16 R90 (0 0);
</pre>
plaziert ein 16poliges DIL-Geh&auml;use, das um 90 Grad gegen den Uhrzeigersinn gedreht ist, an den Koordinaten (0 0).
<h3>Fehlermeldungen</h3>
Soll ein Gate aus einem unvollst&auml;ndig definierten Device geholt werden, erscheint
eine Fehlermeldung (siehe <a href=#35>BOARD</a>-Befehl). Dies l&auml;sst sich mit dem
Befehl "<a href=#97>SET</a> CHECK_CONNECTS OFF;"
verhindern. Vorsicht: Der BOARD-Befehl f&uuml;hrt diese Pr&uuml;fung auf alle F&auml;lle durch. Sie
abzuschalten ist also nur sinnvoll, wenn man keine Platine erzeugen will.
<h2>Symbol in Device holen</h2>
Bei der Device-Definition holt der ADD-Befehl ein vorher definiertes Symbol in das Device.
Als Optionen sind zwei Parameter (Swaplevel und Addlevel) m&ouml;glich, die in beliebiger Reihenfolge
eingegeben werden k&ouml;nnen. Beide lassen sich mit dem <a href=#37>CHANGE</a>-Befehl
voreinstellen und &auml;ndern. Auch der im ADD-Befehl angegebene Wert bleibt als Voreinstellung erhalten.
<h3>Swaplevel</h3>
Der Swaplevel ist eine ganze Zahl, wobei gilt:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>0:  </td><td width=20><td>Das Symbol (Gate) kann im Schaltplan nicht mit einem anderen vertauscht werden.</td></tr>
<tr><td>&gt;0 </td><td width=20><td>Das Symbol (Gate) kann im Schaltplan mit jedem anderen Symbol dieses Typs vertauscht werden, das denselben Swaplevel hat (auch zwischen verschiedenen Devices).</td></tr>
</table>
<p>
Default: 0
<h3>Addlevel</h3>
F&uuml;r diesen Parameter gibt es folgende M&ouml;glichkeiten:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>Next</tt>   </td><td width=20><td>Wenn ein Device mehr als ein Gate aufweist, werden in den Schaltplan der Reihe nach die Symbole mit Addlevel Next geholt.</td></tr>
<tr><td><tt>Must</tt>   </td><td width=20><td>Wird ein beliebiges Symbol eines Device in den Schaltplan geholt, dann muss auch ein mit dem Addlevel Must definiertes Symbol im Schaltplan erscheinen. Dies geschieht automatisch. Es kann nicht gel&ouml;scht werden, bevor nicht alle anderen Symbole aus diesem Device gel&ouml;scht sind. Falls nur noch Must-Symbole aus einem Device vorhanden sind, l&ouml;scht der DELETE-Befehl das ganze Device.</td></tr>
<tr><td><tt>Always</tt> </td><td width=20><td>Wie Must, allerdings kann ein Symbol mit Addlevel Always gel&ouml;scht und mit <a href=#60>INVOKE</a> wieder in den Schaltplan geholt werden.</td></tr>
<tr><td><tt>Can</tt>    </td><td width=20><td>Gibt es in einem Device Next-Gates, dann werden Can-Gates nur geholt, wenn sie explizit mit INVOKE angefordert werden. Ein Symbol mit Addlevel Can wird mit ADD nur dann in den Schaltplan geholt, wenn das Device nur Can- und Request-Gates enth&auml;lt.</td></tr>
<tr><td><tt>Request</tt></td><td width=20><td>Diese Eigenschaft wird sinnvollerweise f&uuml;r Versorgungs-Symbole von Bausteinen verwendet. Request-Gates k&ouml;nnen nur explizit in den Schaltplan geholt werden (INVOKE) und werden intern nicht mitgez&auml;hlt. Das hat zur Folge, dass in Bausteinen mit nur einem Gatter und einem Versorgungsspannungs-Symbol der Gatter-Name nicht zum Bauteil-Namen hinzugef&uuml;gt wird. Im Falle eines 7400 mit vier Gattern (plus Versorgungsspannung) hei&szlig;en die einzelnen Gatter im Schaltplan beispielsweise IC1A, IC1B, IC1C und IC1D. Ein 68000 mit nur einem <i>Gate</i>, dem Prozessor-Symbol, heisst dagegen im Schaltplan z. B. IC1, da sein separates Spannungsversorgungs-Symbol als Gate nicht mitz&auml;hlt.</td></tr>
</table>
<p>
Beispiel:
<pre>
ADD PWR 0 REQUEST &#149;
</pre>
holt das Symbol PWR (z. B. ein Versorgungssymbol) und definiert daf&uuml;r den Swaplevel 0
(nicht tauschbar) und den Addlevel <i>Request</i>.


<a name=31>
<h1>ARC</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeichnen von Kreisb&ouml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>ARC ['signal_name'] [CW | CCW] [ROUND | FLAT] [width] &#149; &#149; &#149;</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.<br>
<mb>Rechte</mb> &auml;ndert den Drehsinn.
</dl>
<b>Siehe auch</b> <a href=#37>CHANGE</a>,
<a href=#112>WIRE</a>,
<a href=#38>CIRCLE</a>
<p>
Mit dem ARC-Befehl zeichnet man Kreisb&ouml;gen. Der erste und zweite
Mausklick (linke Maustaste) definieren zwei gegen&uuml;berliegende Punkte
auf dem Kreisumfang. Danach l&auml;sst sich mit der rechten Maustaste
festlegen, ob der Bogen im Uhrzeigersinn oder im Gegenuhrzeigersinn
dargestellt werden soll. Mit dem abschlie&szlig;enden Mausklick legt man den
Winkel des Bogens fest.
<p>
Mit den Parametern CW (Clockwise) und CCW (Counterclockwise) kann man
festlegen, ob der Bogen im Uhrzeigersinn oder gegen den Uhrzeigersinn dargestellt
werden soll. ROUND bzw. FLAT bestimmt ob die Enden des Kreisbogens rund oder flach sein sollen.
<h2>Signalname</h2>
Der Parameter <tt>signal_name</tt> ist in erster Linie f&uuml;r die
Anwendung in Script-Dateien gedacht, die generierte Daten einlesen.
Wenn ein Signalname angegeben ist, wird der Kreisbogen mit
diesem Signal verbunden, und es wird keine automatische Pr&uuml;fung
durchgef&uuml;hrt.<br>
<b>Diese M&ouml;glichkeit ist mit gro&szlig;er Vorsicht
einzusetzen, da es zu Kurzschl&uuml;ssen kommen kann, wenn ein Kreisbogen so
plaziert wird, dass er unterschiedliche Signale verbindet. Bitte f&uuml;hren
Sie deshalb einen
<a href=#48>Design Rule Check</a> durch, nachdem Sie
den ARC-Befehl mit dem Parameter <tt>signal_name</tt> benutzt haben!</b>
<h2>Strichst&auml;rke</h2>
Der Parameter width gibt die Strichst&auml;rke an, er l&auml;sst sich mit
dem Befehl
<pre>
CHANGE WIDTH width;
</pre>
voreinstellen oder ver&auml;ndern und ist identisch mit der aktuellen
Strichst&auml;rke f&uuml;r Wires.
<p>
Kreisb&ouml;gen mit einem Winkel von 0 oder 360 Grad oder einem Radius
von 0 werden nicht akzeptiert.
<p>
Beispiel f&uuml;r textuelle Eingabe:
<pre>
GRID inch 1;
ARC CW (0 1) (0 -1) (1 0);
</pre>
erzeugt einen Viertelkreis im ersten Quadranten mit Mittelpunkt im Ursprung.


<a name=32>
<h1>ASSIGN</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Tastenbelegung zuweisen.
<dt>
<b>Syntax</b>
<dd>
<tt>ASSIGN</tt><br>
<tt>ASSIGN function_key befehl..;</tt><br>
<tt>ASSIGN function_key;</tt>
<p>
<tt>function_key = modifier+key</tt><br>
<tt>modifier     = </tt>jede Kombination aus <tt>S</tt> (Shift), <tt>C</tt> (Ctrl), <tt>A</tt> (Alt) und <tt>M</tt> (Cmd, nur auf Mac OS X)<br>
<tt>key          = F1..F12, A-Z, 0-9, BS</tt> (Backspace)
</dl>
<b>Siehe auch</b> <a href=#96>SCRIPT</a>,
<a href=#20>Tastatur und Maus</a>
<p>
Mit dem ASSIGN-Befehl kann man die Funktionstasten <tt>F1</tt> bis <tt>F12</tt>,
die Buchstabentasten <tt>A</tt> bis <tt>Z</tt>, die (oberen) Zifferntasten
<tt>0</tt> bis <tt>9</tt> und die <tt>Backspace</tt>-Taste (jeweils auch
in Kombination mit Zusatztasten) mit einzelnen oder mehreren
Befehlen belegen.
<p>
Der ASSIGN-Befehl ohne Parameter listet die aktuelle Tastenbelegung
in einem Dialog auf, in dem die Einstellungen auch ver&auml;ndert werden k&ouml;nnen.
<p>
Die beim Bet&auml;tigen der Taste auszuf&uuml;hrende Befehlssequenz sollte man der
Klarheit wegen in Hochkommas einschlie&szlig;en.
<p>
Soll als <tt>key</tt> eine der Tasten <tt>A-Z</tt> oder <tt>0-9</tt> verwendet
werden, so muss der <tt>modifier</tt> mindestens <tt>A</tt>, <tt>C</tt> oder <tt>M</tt> enthalten.
<table><tr><td valign="top"><img src="platforms-mac.png"></td><td valign="middle">
Der <b><tt>M</tt></b> modifier ist nur unter <b>Mac OS X</b> verf&uuml;gbar.
</td></tr></table>
<p>
Bitte beachten Sie, dass eine eventuell auf einer Taste liegende
Betriebssystem-Funktion durch den ASSIGN-Befehl &uuml;berschrieben wird
(je nach verwendetem Betriebssystem kann es sein, dass bestimmte Tastenkombinationen
nicht mit dem ASSIGN-Befehl &uuml;berschrieben werden k&ouml;nnen).<br>
Falls Sie eine Buchstabentaste zusammen mit dem Modifier <tt>A</tt> belegen (zum Beispiel
<tt>A+F</tt>), so steht ein eventueller Hotkey im Pulldown-Men&uuml; nicht mehr
zur Verf&uuml;gung.
<p>
Um eine Tastenbelegung wieder zu entfernen geben Sie <tt>ASSIGN</tt>
nur mit dem function_key Code (ohne Befehl) ein.
<h2>Beispiele</h2>
<pre>
ASSIGN F7 'change layer top; route';
ASS A+F7 'cha lay to; rou';
ASSIGN C+F10 menu add mov rou ''';''' edit;
ASSIGN CA+R 'route';
</pre>
Die beiden ersten Eingaben bewirken das gleiche, da EAGLE nicht nur
bei Befehlen, sondern auch bei den Parametern Abk&uuml;rzungen zul&auml;sst,
solange sie eindeutig sind.
<p>
Beachten Sie, dass hier z. B. der Befehl "CHANGE layer top"
mit Strichpunkt abgeschlossen ist und der ROUTE-Befehl nicht.
Im ersten Fall enth&auml;lt der Befehl n&auml;mlich alle Parameterangaben,
w&auml;hrend im zweiten Fall noch Koordinatenangaben fehlen (die dann
sinnvollerweise mit der Maus eingegeben werden). Der ROUTE-Befehl
darf also nicht mit Strichpunkt abgeschlossen werden.
<h2>Befehlsmen&uuml; einstellen</h2>
Will man mit ASSIGN eine Taste so belegen, dass sie ein
neues Men&uuml; einstellt, dann muss das im MENU-Befehl enthaltene
Trennzeichen (Strichpunkt) von jeweils drei Hochkommas eingeschlossen
sein, wie im dritten Beispiel zu sehen.
<h2>Voreinstellung der Tastenbelegung</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>F1     HELP</tt> </td><td width=20><td>Hilfe-Funktion</td></tr>
<tr><td><tt>Alt+F2 WINDOW FIT</tt>     </td><td width=20><td>Zeichnung formatf&uuml;llend darst.</td></tr>
<tr><td><tt>F2     WINDOW;</tt>        </td><td width=20><td>Bildschirminhalt auffrischen</td></tr>
<tr><td><tt>F3     WINDOW 2</tt>       </td><td width=20><td>In das Bild hineinzoomen, Fakt. 2</td></tr>
<tr><td><tt>F4     WINDOW 0.5</tt>     </td><td width=20><td>Herauszoomen um Faktor 2</td></tr>
<tr><td><tt>F5     WINDOW (@);</tt>    </td><td width=20><td>Neues Zentrum an der Position des Mauszeigers</td></tr>
<tr><td><tt>F6     GRID;</tt>          </td><td width=20><td>Raster ein-/ausblenden</td></tr>
</table>
<p>
Ausserdem sind viele n&uuml;tzliche Tastenbelegungen im Initialisierungsskript eagle.scr enthalten
und k&ouml;nnen Ihren individuellen Vorstellungen angepa&szlig;t werden.


<a name=33>
<h1>ATTRIBUTE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definition von Attributen f&uuml;r Bauteile.
<dt>
<b>Syntax</b>
<dd>
<tt>ATTRIBUTE name [ 'value' ] [ options ]</tt><br>
<tt>ATTRIBUTE part_name attribute_name</tt><br>
<tt>ATTRIBUTE part_name attribute_name 'attribute_value' [ [ orientation ] &#149; ]</tt><br>
<tt>ATTRIBUTE part_name attribute_name DELETE</tt><br>
<tt>ATTRIBUTE element_name attribute_name</tt><br>
<tt>ATTRIBUTE element_name attribute_name 'attribute_value' [ [ orientation ] &#149; ]</tt><br>
<tt>ATTRIBUTE element_name attribute_name DELETE</tt><br>
<tt>ATTRIBUTE * [ name [ 'value' ] ]</tt><br>
<tt>ATTRIBUTE * name DELETE</tt><br>
<tt>ATTRIBUTE &#149;..</tt>
</dl>
<b>Siehe auch</b> <a href=#103>TECHNOLOGY</a>,
<a href=#72>NAME</a>,
<a href=#108>VALUE</a>,
<a href=#100>SMASH</a>,
<a href=#104>TEXT</a>
<p>
Siehe Beschreibung der <tt>orientation</tt> bei <a href=#30>ADD</a>.
<p>
Ein <i>Attribut</i> ist eine beliebige Kombination aus einem <i>Namen</i> und
einem <i>Wert</i>, welche dazu benutzt werden kann, einem bestimmten Bauteil
jede Art von Information zuzuordnen.
<p>
Attribute k&ouml;nnen in der Bibliothek definiert werden (f&uuml;r einzelne Devices), im
Schaltplan oder im Board (f&uuml;r konkrete Bauteile). Attribute, die auf der Device-Ebene
definiert wurden, werden f&uuml;r jedes Bauteil dieses Typs im Schaltplan verwendet.
Im Schaltplan k&ouml;nnen jedem Bauteil weitere Attribute hinzugef&uuml;gt werden, und bestehende
Attribute von den Devices k&ouml;nnen mit anderen Werten &uuml;berschrieben werden (falls die
Attribute als <i>variabel</i> definiert wurden). Ein Element im Board hat alle
Attribute des zugeh&ouml;rigen Bauteils im Schaltplan und kann weitere, eigene Attribute
haben.
<h2>Attribute in der Bibliothek</h2>
In einer Bibliothek kann der ATTRIBUTE-Befehl dazu verwendet werden, die Attribute
einer bestimmten Technology-Variante zu definieren. Die Syntax hierf&uuml;r lautet
<pre>
ATTRIBUTE name [ 'value' ] [ options ]
</pre>
Der <tt>name</tt> darf aus beliebigen Buchstaben, Ziffern und den Zeichen
'_', '#' und '-' bestehen und beliebig lang sein; das erste Zeichen darf allerdings
nicht '-' sein. Die Gro&szlig;-/Kleinschreibung spielt bei den Namen keine Rolle, so dass
PartNo und PARTNO der gleiche Name sind. Der <tt>value</tt> darf beliebige Zeichen
enthalten und muss in Hochkommas angegeben werden.
<p>
G&uuml;ltige <tt>options</tt> sind:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>delete</tt>  </td><td width=20><td>L&ouml;scht das Attribut mit dem angegebenen Namen aus allen Technology-Varianten (in diesem Fall darf kein 'value' angegeben werden).</td></tr>
<tr><td><tt>variable</tt></td><td width=20><td>Das Attribut wird als <i>variabel</i> markiert, so dass es im Schaltplan &uuml;berschrieben werden kann (dies ist die Standardeinstellung).</td></tr>
<tr><td><tt>constant</tt></td><td width=20><td>Attribute, die als <i>konstant</i> markiert sind, k&ouml;nnen nicht im Schaltplan &uuml;berschrieben werden (es sei denn, der Anwender besteht darauf).</td></tr>
</table>
Optionen k&ouml;nnen abgek&uuml;rzt werden und Gro&szlig;-/Kleinschreibung spielt keine Rolle.
<p>
Ein bereits bestehendes Attribut kann zwischen <i>variabel</i> und <i>konstant</i>
umgeschaltet werden, ohne dass sein Wert erneut angegeben werden muss:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ATTRIBUTE ABC '123'</tt>   </td><td width=20><td>(standardm&auml;&szlig;ig variabel)</td></tr>
<tr><td><tt>ATTRIBUTE ABC constant</tt></td><td width=20><td>(ABC beh&auml;lt den Wert '123')</td></tr>
</table>
Wird der Wert eines Attributes ver&auml;ndert, so bleibt seine <i>konstant/variabel</i>-Einstellung
unver&auml;ndert (es sei denn, sie wird explizit angegeben).
<p>
Der Attributname <b>_EXTERNAL_</b> ist zur Kennzeichnung externer Devices reserviert
(siehe <a href=#76>PACKAGE</a>).
<p>
Einige spezielle Attribut-Namen sind nicht erlaubt, da sie mit den bereits existierenden
<a href=#104>Text Variablen</a> kollidieren w&uuml;rden. Ist ein Attribut
namens VALUE definiert, so wird dessen Wert zum Initialisieren des tats&auml;chlichen
Wertes eines Bauteils beim Einsetzen in den Schaltplan verwendet (vorausgesetzt,
das Device-Set hat 'Value On').
<h2>Attribute im Schaltplan</h2>
Im Schaltplan kann der ATTRIBUTE-Befehl dazu verwendet werden, einem Bauteil
Attribute zuzuweisen. Der Wert eines solchen Attributs &uuml;berschreibt dann den
des gleichnamigen Attributs aus der Bibliothek (falls das Device ein solches
Attribut hat und das &Uuml;berschreiben zul&auml;sst). Einem Bauteil k&ouml;nnen auch Attribute
zugewiesen werden, die nicht in der Bibliothek definiert wurden.
<p>
Wird nach dem Selektieren des ATTRIBUTE-Befehls auf ein Bauteil geklickt, so
erscheint ein Dialog in dem alle Attribute dieses Bauteils aufgelistet sind
und bearbeitet werden k&ouml;nnen.
<p>
Um ein Attribut vollst&auml;ndig textuell zu definieren, kann folgende Syntax benutzt werden:
<pre>
ATTRIBUTE part_name attribute_name 'attribute_value' orientation &#149;
</pre>
<p>
Bei bereits existierenden Attributen ist nur eine &Auml;nderung des Wertes m&ouml;glich;
hierzu kann folgende Syntax benutzt werden:
<pre>
ATTRIBUTE part_name attribute_name 'attribute_value';
</pre>
Beachten Sie bitte, dass im Falle eines Bauteils, das aus mehreren Gattern besteht,
tats&auml;chlich eines dieser Gatter ausgew&auml;hlt wird. Bei der Auswahl &uuml;ber einen Mausklick
ist bereits klar, welches Gatter gemeint ist, wohingegen bei der textuellen Auswahl der
vollst&auml;ndige Name bestehend aus Bauteil- und Gattername angegeben werden sollte.
Ein konkretes Bauteil kann nur ein Attribut mit einem bestimmten Namen haben, dieses
kann aber zu jedem seiner Gatter hinzugef&uuml;gt werden.
Wird nur der Bauteilname angegeben, so wird implizit das erste sichtbare Gatter
ausgew&auml;hlt.
<p>
Werden keine Koordinaten angegeben (und der Befehl mit <tt>';'</tt> abgeschlossen),
so h&auml;ngt das Verhalten davon ab, ob das gegebene Attribut f&uuml;r dieses Bauteil
bereits existiert (entweder im Device oder im Schaltplan). Existiert das Attribut
bereits, so wird lediglich sein Wert ge&auml;ndert. Falls es noch nicht existiert, so
wird ein neues Attribut mit dem gegebenen Namen und Wert angelegt und am
Aufh&auml;ngepunkt des ausgew&auml;hlten Gatters des Bauteils platziert.
<p>
Um ein Attribut von einem Bauteil zu entfernen kann der Befehl
<pre>
ATTRIBUTE part_name attribute_name DELETE
</pre>
verwendet werden.
<p>
Bei der Definition von Attributen &uuml;ber die Kommandozeile oder ein Script
verwenden Sie bitte den <a href=#37>CHANGE</a> DISPLAY Befehl
um einzustellen, welche Teile des Attributs (Name, Wert, beides oder nichts davon)
sichtbar sein sollen.
<h2>Attribute im Board</h2>
Im Board k&ouml;nnen den Bauteilen Attribute auf die gleiche Weise zugewiesen werden
wie im Schaltplan. Standardm&auml;&szlig;ig haben die Bauteile im Board alle Attribute, die
f&uuml;r das jeweils zugeh&ouml;rige Bauteil im Schaltplan (und dessen Device in der Bibliothek)
definiert wurden. Gleichnamige Attribute eines zusammengeh&ouml;renden Paares von Bauteilen
im Schaltplan und im Board haben immer den selben Wert (&uuml;ber die <a href=#372>Forward&amp;Back-Annotation</a>).
Bauteile im Board k&ouml;nnen zus&auml;tzliche Attribute erhalten, die nicht im Schaltplan
oder in der Bibliothek definiert wurden.
<h2>Globale Attribute</h2>
Globale Attribute k&ouml;nnen in Boards und Schaltpl&auml;nen definiert werden indem
als Bauteilname ein <tt>'*'</tt> eingegeben wird (was gleichbedeutend ist damit,
dass das Attribut f&uuml;r <i>alle</i> Bauteile gilt). Alternativ k&ouml;nnen die globalen
Attribute auch &uuml;ber die Men&uuml;-Option "Bearbeiten/Globale Attribute..." definiert
werden. Die globalen Attribute von Board und Schaltplan werden getrennt voneinander
behandelt und sind nicht &uuml;ber <a href=#372>Forward&amp;Back-Annotation</a>
verbunden.
<p>
Solch ein Attribut k&ouml;nnte zum Beispiel der Autor der Zeichnung sein, und kann
im Schriftfeld des Zeichnungsrahmens verwendet werden. Es wird dann auf jeder
Schaltplan-Seite angezeigt, die einen Zeichnungsrahmen enth&auml;lt in dem sich
eine gleichnamige <a href=#104>Text Variable</a> befindet.
<h2>Layer ausw&auml;hlen</h2>
Im Gegensatz zu anderen Befehlen (wie etwa WIRE) merkt sich der ATTRIBUTE-Befehl
den zuletzt verwendeten Layer selbst. Das hat den Vorteil, dass Attribute immer
im richtigen Layer landen, egal welche Layer andere Befehle verwenden. Der
Nachteil ist, dass die &uuml;bliche Vorgehensweise, den Layer in einem Script auszuw&auml;hlen,
wie etwa
<pre>
LAYER <i>Layer</i>;
WIRE (1 2) (3 4);
</pre>
hier nicht funktioniert. Der Layer muss gew&auml;hlt werden, wenn der ATTRIBUTE-Befehl
bereits aktiv ist. Dies kann folgenderma&szlig;en geschehen:
<pre>
ATTRIBUTE <i>Parameter</i>
LAYER <i>Layer</i>
<i>weitere Parameter</i>;
</pre>
Beachten Sie, dass die ATTRIBUTE-Zeile <b>nicht</b> mit einem <tt>';'</tt>
abgeschlossen ist, und dass der LAYER-Befehl in einer neuen Zeile beginnt.<br>
Die Befehle
<pre>
ATTRIBUTE
LAYER <i>Layer</i>;
</pre>
setzen den Layer f&uuml;r nachfolgende ATTRIBUTE-Befehle.
<h2>Beispiele</h2>
Zuerst m&uuml;ssen das Package und die Technology (falls es mehr als eine gibt) gew&auml;hlt werden,
dann k&ouml;nnen die Attribute f&uuml;r diese Technology definiert werden:
<pre>
PACKAGE N;
TECHNOLOGY LS;
ATTRIBUTE PartNo '12345-ABC';
ATTRIBUTE Temp '100K' constant;
ATTRIBUTE Remark 'mount manually';
</pre>


<a name=34>
<h1>AUTO</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
<a href=#137>Autorouter</a> aktivieren.
<dt>
<b>Syntax</b>
<dd>
<tt>AUTO;</tt><br>
<tt>AUTO signal_name..;</tt><br>
<tt>AUTO ! signal_name..;</tt><br>
<tt>AUTO &#149;..;</tt><br>
<tt>AUTO FOLLOWME</tt><br>
<tt>AUTO LOAD|SAVE filename;</tt>
</dl>
<b>Siehe auch</b> <a href=#99>SIGNAL</a>,
<a href=#94>ROUTE</a>,
<a href=#112>WIRE</a>,
<a href=#86>RATSNEST</a>,
<a href=#97>SET</a>
<p>
Der AUTO-Befehl aktiviert den integrierten Autorouter. Werden Signalnamen
angegeben oder Signale mit der Maus selektiert, werden nur diese Signale
verlegt. Ohne weitere Parameter verlegt der Autorouter alle Signale.
Das Zeichen "!" gibt an, dass alle Signale ausser den angegebenen zu
routen sind. Es muss vor allen Signalnamen stehen und darf nur einmal
vorkommen.
<p>
Die Optionen <tt>LOAD</tt> und <tt>SAVE</tt> k&ouml;nnen dazu verwendet werden die
Autorouter-Parameter aus der angegebenen Datei zu laden bzw. sie in diese zu speichern.
Falls <i>filename</i> nicht die Extension <tt>".ctl"</tt> hat wird diese automatisch
angef&uuml;gt.
<p>
Ohne Parameter (oder wenn das abschlie&szlig;ende <tt>';'</tt> nicht angegeben wird),
&ouml;ffnet der AUTO-Befehl einen Dialog, in dem die Steuerparameter f&uuml;r den
Routing-Algorithmus eingestellt werden k&ouml;nnen. Die spezielle Option <tt>FOLLOWME</tt>
&ouml;ffnet diesen Dialog in einem Modus, in dem nur die f&uuml;r den <a href=#94>Follow-me-Router</a>
ma&szlig;geblichen Parameter ver&auml;ndert werden k&ouml;nnen.
<h2>Beispiel</h2>
<pre>
AUTO ! GND VCC;
</pre>
Der abschlie&szlig;ende Strichpunkt ist in jedem Fall erforderlich, es sei
denn, der Autorouter wird vom Men&uuml; aus mit "Start" gestartet.
Die Aktivit&auml;ten des Autorouters k&ouml;nnen Sie am Bildschirm mitverfolgen.
<p>
Das Men&uuml; des Autorouter-Befehls erscheint nach Eingabe von AUTO ohne
abschlie&szlig;enden Strichpunkt.
<h2>Platzhalter</h2>
Falls der <tt>signal_name</tt>-Parameter angegeben wurde, so sind die Zeichen <tt>'*'</tt>, <tt>'?'</tt>
und <tt>'[]'</tt> <i>Platzhalter</i> und haben folgende Bedeutung:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>*</tt>    </td><td width=20><td>steht f&uuml;r eine beliebige Anzahl beliebiger Zeichen</td></tr>
<tr><td><tt>?</tt>    </td><td width=20><td>steht f&uuml;r genau ein Zeichen</td></tr>
<tr><td><tt>[...]</tt></td><td width=20><td>steht f&uuml;r irgend eines der Zeichen zwischen den Klammern</td></tr>
</table>
<p>
Soll eines dieser Zeichen genau so gesucht werden, wie es ist, so muss es in eckige Klammern
eingeschlossen werden. Zum Beispiel findet <tt>abc[*]ghi</tt> die Zeichenfolge <tt>abc*ghi</tt>,
aber nicht <tt>abcdefghi</tt>.
<p>
Ein Bereich von Zeichen kann als <tt>[a-z]</tt> angegeben werden, was f&uuml;r eines der Zeichen
aus dem Bereich <tt>'a'</tt>...<tt>'z'</tt> steht.
<h2>Polygone</h2>
Beim Starten des Autorouters werden alle <a href=#81>Polygone</a> neu
freigerechnet.
<h2>Protokolldatei</h2>
Informationen zum Routing-Vorgang enth&auml;lt die Datei name.pro, die
ebenfalls automatisch angelegt wird.
<h2>Routing-Fl&auml;che</h2>
Der Autorouter legt ein umschlie&szlig;endes Rechteck um alle Objekte des Boards
und nimmt die Gr&ouml;&szlig;e dieses Rechtecks als maximale
Route-Fl&auml;che. Wires im Dimension-Layer stellen f&uuml;r den Autorouter
Sperrlinien dar. Das heisst, mit geschlossenen Linienz&uuml;gen in diesem Layer kann man
den Route-Bereich begrenzen.
<h2>Signale</h2>
Als Signale erkennt der Autorouter Wires und Polygone in den Layern Top, Bottom und
Route2...15, sowie die mit SIGNAL definierten Luftlinien.
<h2>Sperrfl&auml;chen</h2>
Objekte in den Layern bRestrict, tRestrict und
vRestrict werden als Sperrfl&auml;chen f&uuml;r L&ouml;t- und Best&uuml;ckungsseite sowie
f&uuml;r Durchkontaktierungen (Vias) behandelt.
<p>
Falls der Autorouter keine Signale in einem Layer verlegen soll, ist
in das Feld f&uuml;r die Vorzugsrichtung "N/A" einzutragen.
<h2>Wahl des Rasters</h2>
Bei der Wahl des Rasters ist zu beachten, dass m&ouml;glichst keine Pads f&uuml;r
den Router "unsichtbar" werden. Das heisst, jedes Pad soll mindestens
einen Routing-Rasterpunkt belegen, sonst kann es passieren, dass der
Autorouter eine Verbindung nicht legen kann, die ansonsten ohne
Probleme zu verlegen w&auml;re - einfach weil er das entsprechende Pad
nicht auf seinem Raster darstellen kann.
<h2>Abbruch</h2>
Wird der Autorouter durch einen Klick auf den STOP-Button abgebrochen, so
werden die bis dahin noch nicht verlegten Luftlinien nicht automatisch neu
berechnet. Benutzen hierzu Sie den <a href=#86>RATSNEST</a>-Befehl.


<a name=35>
<h1>BOARD</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Erzeugt eine Board-Datei aus einem Schaltplan.
<dt>
<b>Syntax</b>
<dd>
<tt>BOARD [ grid ]</tt>
</dl>
<b>Siehe auch</b> <a href=#49>EDIT</a>
<p>
Der BOARD-Befehl erzeugt eine Layout-Datei aus einem Schaltplan.
<p>
Wenn die Platine bereits existiert, wird sie in ein Layout-Editor-Fenster
geladen.
<p>
Wenn die Platine nicht existiert, werden Sie gefragt, ob Sie eine
neue Datei anlegen wollen.
Wird der <tt>grid</tt> Parameter angegeben, so werden die Bauteile in dem
angegebenen Raster platziert, wie in
<pre>
BOARD 5mm
</pre>
womit die Bauteile in einem 5mm Raster platziert w&uuml;rden (Default ist
50mil). Die Zahl muss mit Einheit angegeben werden und der Maximalwert
ist 10mm.
<p>
Der BOARD-Befehl &uuml;berschreibt niemals eine existierende Platinen-Datei.
Wenn eine Datei mit diesem Namen existiert, muss sie erst mit
<a href=#89>REMOVE</a> gel&ouml;scht werden, bevor der
BOARD-Befehl sie neu anlegen kann.
<h2>Platine aus Schaltplan erzeugen</h2>
Wird eine Platine zum erstenmal geladen, pr&uuml;ft das Programm, ob im
selben Verzeichnis ein Schaltplan mit demselben Namen existiert. Wenn
ja, fragt das Programm, ob aus dem Schaltplan die Platine erstellt
werden soll.<br>
Wenn ein Schaltplan geladen ist, k&ouml;nnen Sie die zugeh&ouml;rige Platine
erzeugen, indem Sie
<pre>
edit .brd
</pre>
in die Kommandozeile des Editor-Fensters eintippen.
<p>
Alle relevanten Daten der Schaltplan-Datei (name.sch) werden dann in eine
Board-Datei (name.brd) konvertiert. Das neue Board wird automatisch mit
einer Gr&ouml;&szlig;e von 160x100mm
(<a href=#378>Light Edition</a>: 100x80mm)
angelegt.
Alle Packages mit den im
Schaltplan definierten Verbindungen sind links neben der leeren Platine
plaziert. Power-Pins sind bereits verbunden
(siehe <a href=#79>PIN</a>-Befehl).
<p>
Falls Sie andere als die standardm&auml;&szlig;ig angelegten Platinenumrisse ben&ouml;tigen,
brauchen Sie einfach nur die entsprechenden Linien zu l&ouml;schen und die
gew&uuml;nschten Umrisse mit dem <a href=#112>WIRE</a>-Befehl in den
Layer <i>Dimension</i> zu zeichnen. W&auml;hlen Sie dazu bitte eine
Strichbreite von 0, da es sich hierbei nur um Hilfslinien handelt.
<p>
Eine Board-Datei kann nicht angelegt werden:
<ul>
<li>Wenn sich Gates im Schaltplan befinden, die aus einem Device ohne
Package stammen (Fehlermeldung: "Bauteil ... hat kein Package!"). Ausnahme:
wenn nur Pins mit Direction "Sup" enthalten sind (Supply-Symbole).
<li>Wenn sich Gates im Schaltplan befinden, die aus einem Device
stammen, f&uuml;r das nicht allen Pins ein Geh&auml;use-Pad zugeordnet ist
(Fehlermeldung: "... hat nicht angeschlossene Pins"). Ausnahme:
Device ohne Pins (z. B. Zeichnungsrahmen).
</ul>


<a name=36>
<h1>BUS</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeichnen von Bussen im Schaltplan.
<dt>
<b>Syntax</b>
<dd>
<tt>BUS [bus_name] &#149; [curve | @radius] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Rechte</mb> &auml;ndert den Knickwinkel (siehe <a href=#97>SET Wire_Bend</a>).<br>
<mb>Shift+Rechte</mb> kehrt die Richtung des Weiterschaltens des Knickwinkels um.<br>
<mb>Ctrl+Rechte</mb> schaltet zwischen korrespondierenden Knickwinkeln hin und her.
</dl>
<b>Siehe auch</b> <a href=#73>NET</a>,
<a href=#72>NAME</a>,
<a href=#97>SET</a>
<p>
Mit dem Befehl BUS zeichnet man Busse in den Bus-Layer eines Schaltplans.
Der Busname hat die Form
<pre>
SYNONYM:Teilbus,Teilbus,..
</pre>
wobei SYNONYM ein beliebiger Name sein darf.
Teilbus ist entweder ein Netzname oder ein Busname mit Index in der Form:
<pre>
Name[LowestIndex..HighestIndex]
</pre>
Folgende Bedingungen m&uuml;ssen erf&uuml;llt sein:
<p>
0 &lt;= LowestIndex &lt;= HighestIndex &lt;= 511
<p>
Wird ein Teilbus mit einem Index verwendet, darf der Name nicht mit einer
Zahl enden, da sonst nicht klar w&auml;re, welche Zahl zum Namen und welche zum
Index geh&ouml;rten.
<p>
Wenn der Bus auf einem anderen Bus abgesetzt wird, endet die Linie an dieser
Stelle. Dieses Verhalten kann &uuml;ber "<tt>SET AUTO_END_NET OFF;</tt>" oder
durch Deselektieren der Option "Netze und Busse automatisch beenden" unter "Optionen/Einstellungen/Verschiedenes"
abgeschaltet werden.
<p>
Wird der <i>curve</i> oder <i>@radius</i> Parameter angegeben, so kann ein Kreisbogen als Teil des Busses
gezeichnet werden (siehe die ausf&uuml;hrliche Beschreibung beim <a href=#112>WIRE</a>-Befehl).
<h2>Beispiele f&uuml;r Busnamen</h2>
<pre>
A[0..15]
RESET
DB[0..7],A[3..4]
ATBUS:A[0..31],B[0..31],RESET,CLOCK,IOSEL[0..1]
</pre>
Gibt man keinen Busnamen an, wird ein Name der Form B$1 automatisch
vergeben. Dieser Name l&auml;sst sich zu jeder Zeit mit dem NAME-Befehl
ver&auml;ndern. Die Breite der Linien, die einen Bus darstellen, l&auml;sst
sich z. B. mit
<pre>
SET BUS_WIRE_WIDTH 40;
</pre>
auf 40 Mil einstellen (Default: 30 Mil).
<h2>Negierte Signale</h2>
Der Name eines negierten Signals ("active low") kann &uuml;berstrichen dargestellt werden,
wenn ihm ein Ausrufezeichen (<tt>'!'</tt>) vorangestellt wird, wie in
<pre>
  ATBUS:A[0..31],B[0..31],!RESET,CLOCK,IOSEL[0..1]
</pre>
was als
<pre>
                          _____
  ATBUS:A[0..31],B[0..31],RESET,CLOCK,IOSEL[0..1]
</pre>
dargestellt w&uuml;rde.
Einzelheiten hierzu finden Sie in der Beschreibung des <a href=#104>TEXT</a>-Befehls.


<a name=37>
<h1>CHANGE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Auml;ndern von Parametern.
<dt>
<b>Syntax</b>
<dd>
<tt>CHANGE option &#149; &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Rechte</mb> &auml;ndert Parameter der Gruppe.
</dl>
Der CHANGE-Befehl dient generell dazu, Eigenschaften von Objekten
zu &auml;ndern oder voreinzustellen. Objekte, die schon in der Zeichnung
vorhanden sind, werden einfach der Reihe nach mit der Maus selektiert,
nachdem der Befehl und der entsprechende Parameter vorher eingegeben
(bzw. aus einem Men&uuml; mit der Maus ausgew&auml;hlt) wurden.
<p>
Nachfolgend plazierte Objekte erhalten die mit CHANGE ge&auml;nderten
Eigenschaften. Damit ist es m&ouml;glich, mit diesem Befehl Parameter
voreinzustellen.
<p>
Alle Zahlenangaben beziehen sich auf die aktuelle Ma&szlig;einheit (siehe GRID).
<h2>Gruppe &auml;ndern</h2>
Will man den CHANGE-Befehl auf eine Gruppe ausf&uuml;hren, definiert
man zuerst die Gruppe mit dem <a href=#56>GROUP</a>-Befehl, dann gibt man den CHANGE-Befehl
mit den entsprechenden Parametern ein und klickt die Gruppe anschlie&szlig;end
mit der rechten Maustaste an.
<h2>M&ouml;glichkeiten des CHANGE-Befehls</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Layer wechseln         </td><td width=20><td><tt>CHANGE LAYER name | number</tt></td></tr>
<tr><td>Text &auml;ndern            </td><td width=20><td><tt>CHANGE TEXT [ text ]</tt></td></tr>
<tr><td>Texth&ouml;he               </td><td width=20><td><tt>CHANGE SIZE value</tt></td></tr>
<tr><td>Textst&auml;rke             </td><td width=20><td><tt>CHANGE RATIO ratio</tt></td></tr>
<tr><td>Text Zeilenabstand     </td><td width=20><td><tt>CHANGE LINEDISTANCE value</tt></td></tr>
<tr><td>Text Font              </td><td width=20><td><tt>CHANGE FONT VECTOR | PROPORTIONAL | FIXED</tt></td></tr>
<tr><td>Text Ausrichtung       </td><td width=20><td><tt>CHANGE ALIGN BOTTOM | LEFT | CENTER | TOP | RIGHT</tt></td></tr>
<tr><td>Wire-Breite            </td><td width=20><td><tt>CHANGE WIDTH value</tt></td></tr>
<tr><td>Wire-Linientyp         </td><td width=20><td><tt>CHANGE STYLE value</tt></td></tr>
<tr><td>Arc-Ende               </td><td width=20><td><tt>CHANGE CAP ROUND | FLAT</tt></td></tr>
<tr><td>Pad-Form               </td><td width=20><td><tt>CHANGE SHAPE SQUARE | ROUND | OCTAGON | LONG | OFFSET</tt></td></tr>
<tr><td>Pad-/Via-/Smd-Flags    </td><td width=20><td><tt>CHANGE STOP | CREAM | THERMALS | FIRST  OFF | ON</tt></td></tr>
<tr><td>Pad-/Via-Durchmesser   </td><td width=20><td><tt>CHANGE DIAMETER diameter</tt></td></tr>
<tr><td>Pad-/Via/Hole-Bohrd.   </td><td width=20><td><tt>CHANGE DRILL value</tt></td></tr>
<tr><td>Via Layer              </td><td width=20><td><tt>CHANGE VIA from-to</tt></td></tr>
<tr><td>Smd-Ma&szlig;e               </td><td width=20><td><tt>CHANGE SMD width height</tt></td></tr>
<tr><td>Smd-Abrundung          </td><td width=20><td><tt>CHANGE ROUNDNESS value</tt></td></tr>
<tr><td>Pin-Parameter          </td><td width=20><td><tt>CHANGE DIRECTION NC | IN | OUT | IO | OC | HIZ | SUP | PAS | PWR</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE FUNCTION NONE | DOT | CLK | DOTCLK</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE LENGTH POINT | SHORT | MIDDLE | LONG</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE VISIBLE BOTH | PAD | PIN | OFF</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE SWAPLEVEL number</tt></td></tr>
<tr><td>Polygon-Parameter      </td><td width=20><td><tt>CHANGE THERMALS OFF | ON</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE ORPHANS OFF | ON</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE ISOLATE distance</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE POUR SOLID | HATCH | CUTOUT</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE RANK value</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE SPACING distance</tt></td></tr>
<tr><td>Gate-Parameter         </td><td width=20><td><tt>CHANGE SWAPLEVEL number</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE ADDLEVEL NEXT | MUST | ALWAYS | CAN | REQUEST</tt></td></tr>
<tr><td>Netzklasse             </td><td width=20><td><tt>CHANGE CLASS number | name</tt></td></tr>
<tr><td>Package-Variante       </td><td width=20><td><tt>CHANGE PACKAGE part_name [device_name] | 'device_name' [part_name]</tt></td></tr>
<tr><td>Technologie            </td><td width=20><td><tt>CHANGE TECHNOLOGY part_name [device_name] | 'device_name' [part_name]</tt></td></tr>
<tr><td>Attribute-Anzeige      </td><td width=20><td><tt>CHANGE DISPLAY OFF | VALUE | NAME | BOTH</tt></td></tr>
<tr><td>Frame-Parameter        </td><td width=20><td><tt>CHANGE COLUMS value</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE ROWS value</tt></td></tr>
<tr><td>                       </td><td width=20><td><tt>CHANGE BORDER NONE | BOTTOM | RIGHT | TOP | LEFT | ALL</tt></td></tr>
<tr><td>Label                  </td><td width=20><td><tt>CHANGE XREF OFF | ON</tt></td></tr>
<tr><td>Dimension-Typ          </td><td width=20><td><tt>CHANGE DTYPE PARALLEL | HORIZONTAL | VERTICAL | RADIUS | DIAMETER | ANGLE | LEADER</tt></td></tr>
<tr><td>Dimension-Einheit      </td><td width=20><td><tt>CHANGE DUNIT [MIC | MM | MIL | INCH] [OFF | ON] [precision]</tt></td></tr>
<tr><td>Dimension-Linien       </td><td width=20><td><tt>CHANGE DLINE width [ extension_width [ extension_length [ extension_offset ]]]
(Hilfslinienwerte k&ouml;nnen auf AUTO gesetzt werden. Nicht zu ver&auml;ndernde Werte k&ouml;nnen mit '-' angegeben werden.)</tt></td></tr>
<tr><td>Populate               </td><td width=20><td><tt>CHANGE POPULATE OFF | ON (ist nur im Board ohne aktiver F/B-Annotation verf&uuml;gbar)</tt></td></tr>
</table>


<a name=38>
<h1>CIRCLE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Kreis in eine Zeichnung einf&uuml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>CIRCLE &#149; &#149;..      </tt>[Kreismitte, Radius]<br>
<tt>CIRCLE width &#149; &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.
</dl>
<b>Siehe auch</b> <a href=#37>CHANGE</a>,
<a href=#112>WIRE</a>
<p>
Mit dem CIRCLE-Befehl zeichnet man Kreise in den aktiven Layer.
<p>
Der CIRCLE-Befehl in den Layern tRestrict, bRestrict
und vRestrict dient zum Anlegen von Sperrfl&auml;chen. Dabei
sollte eine Linienst&auml;rke (width) von 0 gew&auml;hlt werden.
<p>
Der Parameter "width" gibt die Strichst&auml;rke des Kreises an.
Er entspricht demselben Parameter des WIRE-Befehls und kann mit dem
Befehl
<pre>
CHANGE WIDTH breite;
</pre>
ge&auml;ndert bzw. voreingestellt werden. Dabei ist <i>breite</i> der
gew&uuml;nschte Wert in der gegenw&auml;rtigen Einheit.
<p>
Kreise mit Strichst&auml;rke 0 werden gef&uuml;llt dargestellt.
<p>
Der Radius des Kreises ist auf 1000mm begrenzt.
<h2>Beispiel f&uuml;r Parameterangabe in Textform</h2>
<pre>
GRID inch 1;
CIRCLE (0 0) (1 0);
</pre>
erzeugt einen Kreis mit einem Radius von 1 Zoll um den Ursprung (0 0).


<a name=39>
<h1>CLASS</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definieren und W&auml;hlen von Netzklassen.
<dt>
<b>Syntax</b>
<dd>
<tt>CLASS</tt><br>
<tt>CLASS number|name</tt><br>
<tt>CLASS number [ name [ width [ clearance [ drill ] ] ] ] [ number:clearance .. ]</tt>
</dl>
<b>Siehe auch</b> <a href=#139>Design Rules</a>,
<a href=#73>NET</a>,
<a href=#99>SIGNAL</a>,
<a href=#37>CHANGE</a>
<p>
Der CLASS-Befehl wird zur Definition von Netzklassen verwendet.
<p>
Ohne Angabe von Parametern, wird ein Dialog ge&ouml;ffnet, der es erlaubt Netzklassen festzulegen.
<p>
Wird nur <tt>number</tt> oder <tt>name</tt> angegeben, w&auml;hlt man die Netzklasse mit der
entsprechenden Nummer bzw. dem Namen f&uuml;r die folgenden NET- und SIGNAL-Befehle vor.
<p>
Wird <tt>number</tt> und <tt>name</tt> angegeben, werden dieser Netzklasse
die folgenden Werte f&uuml;r die Parameter zugeordnet. Diese
Netzklasse ist gleichzeitig f&uuml;r die folgenden NET- und SIGNAL-Befehle vorgew&auml;hlt.
Werden nach <tt>name</tt> nicht alle Parameter angegeben, gelten die Werte
der Reihe nach f&uuml;r width, clearance, drill bzw. interspace. Soll beispielsweise nur drill ge&auml;ndert
werden, m&uuml;ssen also auch die Parameter f&uuml;r width und clearance angegeben werden.
<p>
Wird <tt>number</tt> negativ gew&auml;hlt, l&ouml;scht man die Netzklasse mit dem Absolutwert
der angegebenen <tt>number</tt>.
Die Default-Netzklasse <tt>0</tt> kann man nicht l&ouml;schen.
<p>
Bei den Namen der Netzklassen wird nicht zwischen Gro&szlig;- und Kleinbuchstaben unterschieden.
SUPPLY hat z. B. dieselbe Bedeutung wie Supply oder SuPpLy.
<p>
Werden mehrere Netzklassen in einer Zeichnung verwendet, braucht
der Autorouter l&auml;nger um seine Arbeit zu erledigen. Daher ist es sinnvoll nur soviele
Netzklassen wie unbedingt n&ouml;tig zu verwenden (die Anzahl der tats&auml;chlich benutzten Netzklassen
ist ausschlaggebend, nicht die Anzahl der definierten Netzklassen).
<p>
Um Probleme bei CUT-und-PASTE-Aktionen zwischen verschiedenen Zeichnungen zu
vermeiden, ist es sinnvoll den unterschiedlichen Netzklassen in verschiedenen
Zeichnungen dieselben Nummern zu geben.
<p>
Module verwenden dieselben Netzklassen wie der Schaltplan selbst.
<p>
Wenn ein Netz eines <a href=#70>MODULE</a>s eine elektrische Verbindung &uuml;ber
einen <a href=#82>PORT</a> besitzt, wird die Netzklasse diese Netzes durch die
Netzklasse des am Port angschlossenen Netzes &uuml;berschrieben.
<p>
Der Autorouter verlegt die Signal in der Reihenfolge der ben&ouml;tigten Breite (width +
clearance), beginnend mit denen, die am meisten Platz ben&ouml;tigen. Der Bus-Router
verlegt nur Signale mit Netzklasse <tt>0</tt>.
<p>
F&uuml;r bestehende Netze/Signale kann CLASS mit dem CHANGE-Befehl ge&auml;ndert werden.
<h2>Width</h2>
Der <i>width</i>-Parameter bestimmt die Mindestbreite, die alle Objekte in dieser
Netzklasse haben m&uuml;ssen.
<h2>Clearance</h2>
Der <i>clearance</i>-Parameter bestimmt den Mindestabstand zwischen Objekten
verschiedener Signale in dieser Netzklasse zu Objekten in anderen Netzklassen.
<h2>Drill</h2>
Der <i>drill</i>-Parameter bestimmt den Mindest-Bohrdurchmesser, den alle Objekte
in dieser Netzklasse haben m&uuml;ssen (bezieht sich nur auf Objekte, die auch tats&auml;chlich
einen <i>drill</i>-Parameter haben, wie etwa Pads und Vias).
<h2>Clearance zwischen Netzklassen</h2>
Wird eine Clearance in der Form <tt>number:clearance</tt> angegeben, so definiert
sie den Mindestabstand zwischen Signalen in dieser Netzklasse und solchen in der
Netzklasse mit der angegebenen <tt>number</tt>. Der Befehl
<pre>
CLASS 3 1:0.6mm 2:0.8mm
</pre>
definiert einen Mindestabstand von 0.6mm zwischen Signalen in den Netzklassen 1 und 3,
sowie einen von 0.8mm zwischen Signalen in den Netzklassen 2 und 3. Beachten Sie bitte,
dass die Nummern in <tt>number:clearance</tt> kleiner oder gleich der Nummer der
Netzklasse selbst (<tt>'3'</tt> im obigen Beispiel) sein m&uuml;ssen. Demnach w&auml;re
<pre>
CLASS 3 1:0.6mm 2:0.8mm 3:0.2mm
</pre>
ebenfalls g&uuml;ltig, w&auml;hrend
<pre>
CLASS 3 1:0.6mm 2:0.8mm 3:0.2mm 4:0.5mm
</pre>
nicht erlaubt ist


<a name=40>
<h1>CLOSE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Schlie&szlig;t ein Editor-Fenster.
<dt>
<b>Syntax</b>
<dd>
<tt>CLOSE</tt>
</dl>
<b>Siehe auch</b> <a href=#74>OPEN</a>,
<a href=#49>EDIT</a>,
<a href=#113>WRITE</a>,
<a href=#96>SCRIPT</a>
<p>
Der CLOSE-Befehl schlie&szlig;t ein Editor-Fenster. Wenn die geladene Datei
ver&auml;ndert worden ist, werden Sie gefragt, ob sie abgespeichert werden
soll.
<p>
Dieser Befehl ist in erster Linie f&uuml;r Script-Dateien erforderlich.


<a name=41>
<h1>CONNECT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zuordnung von Pins und Pads.
<dt>
<b>Syntax</b>
<dd>
<tt>CONNECT</tt><br>
<tt>CONNECT [ ALL | ANY ] gate_name.pin_name pad_name..</tt><br>
<tt>CONNECT [ ALL | ANY ] pin_name pad_name..</tt>
</dl>
<b>Siehe auch</b> <a href=#83>PREFIX</a>,
<a href=#74>OPEN</a>,
<a href=#40>CLOSE</a>,
<a href=#96>SCRIPT</a>
<p>
Dieser Befehl wird im Device-Editier-Modus angewendet. Er dient dazu,
den Pins des Schaltplan-Symbols (Device), das gegenw&auml;rtig bearbeitet
wird, die entsprechenden Pads des zugeh&ouml;rigen Geh&auml;uses zuzuweisen.
Zuvor muss mit dem PACKAGE-Befehl festgelegt worden sein, welches
Package f&uuml;r das Device verwendet werden soll.
<p>
Wird der CONNECT-Befehl ohne Parameter aufgerufen, so erscheint ein
Dialog in dem die Pad/Pin-Zuweisungen interaktiv definiert werden k&ouml;nnen.
<h2>Device hat ein Gatter</h2>
Ist im Device nur ein Gatter vorhanden, kann der Parameter gate_name
entfallen, z.B.
<pre>
CONNECT gnd 1 rdy 2 phi1 3 !irq 4 nc1 5 ...
</pre>
<h2>Device hat mehrere Gatter</h2>
Sind im Device mehrere Gatter vorhanden, sind als Parameter gate_name
und pin_name (mit Punkt als Trennzeichen) sowie pad_name anzugeben,
z.B.:
<pre>
CONNECT A.I1     1   A.I2   2   A.O  3;
CONNECT B.I1     4   B.I2   5   B.O  6;
CONNECT C.I1    13   C.I2  12   C.O  11;
CONNECT D.I1    10   D.I2   9   D.O  8;
CONNECT PWR.GND  7;
CONNECT PWR.VCC  14;
</pre>
In diesem Fall werden die Anschl&uuml;sse der vier NAND-Gatter eines
7400 zugewiesen. Das Device enth&auml;lt f&uuml;nf Gatter mit den Bezeichnungen
A, B, C, D, PWR. Die Eing&auml;nge der Gatter hei&szlig;en im Schaltplan
I1 und I2; der Ausgang heisst O.
<p>
Der CONNECT-Befehl kann beliebig oft ausgef&uuml;hrt werden. Er kann
alle Pin/Pad-Zuweisungen enthalten oder nur einen Teil davon. Jeder
neue CONNECT-Befehl &uuml;berschreibt die bisherigen Definitionen f&uuml;r die
angegebenen Pins.
<p>
Beachten Sie bitte, dass bei einer gro&szlig;en Zahl von Verbindungen innerhalb
eines Devices der CONNECT-Befehl wesentlich schneller arbeitet, wenn alle
Verbindungen in einem einzigen Aufruf angegeben werden, so wie im Beispiel
unten gezeigt.
<h2>Mehrere Pads am gleichen Pin angeschlossen</h2>
Manche Bauteile, wie etwa Leistungsverst&auml;rker oder BGA-Chips, k&ouml;nnen
mehrere Pads haben die intern verbunden sind, zum Beispiel zur besseren
W&auml;rmeableitung oder um h&ouml;here Str&ouml;me zu erm&ouml;glichen. Der CONNECT-Befehl
kann diese F&auml;lle ber&uuml;cksichtigen, indem einfach alle betreffenden Pad-Namen,
getrennt durch Leerzeichen (und daher in einfache Hochkommas eingeschlossen)
angegeben werden:
<pre>
CONNECT ALL I1 '1 3 5';
CONNECT ANY O1 '2 4 6';
</pre>
Im ersten Beispiel ist der Pin <tt>I1</tt> mit den drei Pads <tt>1</tt>,
<tt>3</tt> und <tt>5</tt> verbunden. Wird der Pin <tt>I1</tt> im Schaltplan
mit einem Netz verbunden, so m&uuml;ssen all drei Pads im Board explizit mit dem
entsprechenden Signal verbunden werden.<br>
Das Schl&uuml;sselwort <tt>ANY</tt> im zweiten Beispiel bedeutet, dass irgend
eines (oder auch alle) der Pads <tt>2</tt>, <tt>4</tt> oder <tt>6</tt> an das
Signal angeschlossen werden k&ouml;nnen. Es ist sogar erlaubt, diese interne Verbindung
als "Br&uuml;cke" zu verwenden, indem ein Segment des Signals zum Beispiel an
Pad <tt>2</tt> angeschlossen wird, w&auml;hrend der Rest des Signals mit Pad <tt>6</tt>
verbunden wird - ohne eine explizite externe Verbindung zwischen diesen beiden
Pads. Nat&uuml;rlich sollten Sie sich bei der Verwendung von <tt>ANY</tt> im
CONNECT-Befehl dar&uuml;ber im Klaren sein, ob das entsprechende Bauteil es
vertr&auml;gt, wenn Querstr&ouml;me durch seine Pads flie&szlig;en. Im Zweifelsfall verwenden
Sie lieber <tt>ALL</tt> (was auch der Standardwert ist und weggelassen werden kann.).
<p>
Sollte ein Pin-Name mit einem der Schl&uuml;sselworte <tt>ALL</tt> oder <tt>ANY</tt>
kollidieren, so muss der Pin-Name in einfache Hochkommas eingeschlossen werden.
Sobald eines dieser Schl&uuml;sselworte in einem CONNECT-Befehl vorkommt, gilt es
f&uuml;r alle nachfolgenden Pin/Pad-Verbindungen, bis ein anderes Schl&uuml;sselwort
auftaucht:
<pre>
CONNECT 'A' '1' 'B' '2' ANY 'C' '3 4 5 6' 'D' '7 8' ALL 'E' '9 10 11';
</pre>
<p>
Der <a href=#86>RATSNEST</a>- und <a href=#34>AUTO</a>-Befehl
ber&uuml;cksichtigt die <tt>ALL</tt> und <tt>ANY</tt> F&auml;lle entsprechend.
<p>
Im CONNECT-Dialog erzeugt der "Connect"-Button eine neue Verbindung zwischen
dem selektierten Pin und den selektierten Pads. Es k&ouml;nnen mehrere Pads selektiert
sein, die dann alle mit dem selektierten Pin verbunden werden. Benutzen sie die
Ctrl- und Shift-Tasten in der &uuml;blichen Weise, um mehrere Pads zu selektieren.<br>
Der "Append"-Button f&uuml;gt die selektierten Pads zu der aktuellen Verbindung hinzu.<br>
Der "Disconnect"-Button trennt die aktuelle Verbindung auf und verschiebt den Pin
und die Pads zur&uuml;ck in ihre jeweiligen Listen. Sie bleiben dabei selektiert, um
auf einfache Weise &Auml;nderungen vornehmen zu k&ouml;nnen. Ein Disconnect unmittelbar
gefolgt von einem Connect f&uuml;hrt zur gleichen Konfiguration wie vor dem Disconnect
(und umgekehrt).
Enth&auml;lt eine Verbindung mehr als ein Pad, so zeigt ein Icon an ob irgend eines
oder alle Pads extern an ein Signal angeschlossen werden m&uuml;ssen. Klicken Sie auf
das Icon um den Modus umzuschalten. Wenn ein solcher Listeneintrag aufgeklappt ist,
so werden alle Pads einzeln angezeigt und ein Klick auf Disconnect mit einem dieser
Pads selektiert l&ouml;st nur dieses eine Pad von der Verbindung.
<h2>Gate- oder Pin-Namen mit Punkten</h2>
Soll ein Gate- oder ein Pin-Name einen Punkt enthalten, kann dieser ohne
weiteres verwendet werden. Es sind keine besonderen Zeichen (Esc-Character
oder Anf&uuml;hrungszeichen) n&ouml;tig.
<h2>Beispiel</h2>
<pre>
ed 6502.dev;
prefix 'IC';
package dil40;
connect gnd 1 rdy 2 phi1 3 !irq 4 nc1 5 !nmi 6 \
        sync 7 vcc 8  a0 9 a1 10 a2 11 a3 12 a4 \
        13 a5 14 a6 15 a7 16 a8 17 a9 18 a10 19 \
        a11 20 p$0 21 a12 22 a13 23 a14 24 a15 \
        25 d7 26 d6 27 d5 28 d4 29 d3 30 d2 31 \
        d1 32 d0 33 r/w 34 nc2 35 nc3 36 phi0 37 \
        so 38 phi2 39 !res 40;
</pre>
Hier sorgt das Zeichen "\" am Zeilenende daf&uuml;r, dass
am Beginn der n&auml;chsten Zeile keine Zeichenfolge mit einem Befehl
verwechselt werden kann. Als Bestandteil eines Pin-Namens dr&uuml;ckt
das Zeichen "!" aus, dass es sich um ein
invertiertes Signal handelt (z.B. "!irq").
<p>
Eine Verwechslung mit Befehlen kann man auch vermeiden, indem man
Parameter in Hochkommas einschlie&szlig;t.


<a name=42>
<h1>COPY</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Kopieren von Objekten.
<dt>
<b>Syntax</b>
<dd>
<tt>COPY &#149; &#149;..</tt><br>
<tt>COPY deviceset@library [name]</tt><br>
<tt>COPY package@library [name]</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Linke</mb> selektiert ein Objekt an seinem Aufh&auml;ngepunkt.<br>
<mb>Ctrl+Rechte</mb> selektiert die Gruppe.<br>
<mb>Mittlere</mb> spiegelt das selektierte Objekt bzw. die Gruppe.<br>
<mb>Rechte</mb> dreht das selektierte Objekt bzw. die Gruppe.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#56>GROUP</a>,
<a href=#43>CUT</a>,
<a href=#78>PASTE</a>,
<a href=#30>ADD</a>,
<a href=#60>INVOKE</a>,
<a href=#81>POLYGON</a>
<p>
Mit dem COPY-Befehl lassen sich Objekte selektieren und
anschlie&szlig;end an eine andere Stelle derselben Zeichnung kopieren,
oder Objekte zwischen Bibliotheken kopieren.
Beim Kopieren von Bauteilen generiert EAGLE einen neuen Namen und
beh&auml;lt den Wert (Value) bei. Beim Kopieren von Signalen (Wires),
Bussen und Netzen wird der Name beibehalten. In allen anderen F&auml;llen
wird ein neuer Name generiert.
<h2>Kopieren in die Zwischenablage</h2>
Traditionell kopierte der COPY-Befehl in EAGLE nur Objekte, indem man
sie mit der Maus anklickte und innerhalb der selben Zeichnung absetzte.
Der COPY-Befehl kopierte auch Objekte zwischen Bibliotheken. Vor Version 6
kopierte er jedoch nicht die selektierte Gruppe in die Zwischenablage, so
wie dies andere Windows-Programme tun. In EAGLE wurde hierf&uuml;r der
<a href=#43>CUT</a>-Befehl verwendet. Ungl&uuml;cklicherweise hat dies
Windows-Anwender immer wieder irritiert, so dass seit Version 6 der COPY-Befehl auch
die selektierte Gruppe von Objekten in die Zwischenablage der Systems kopiert,
wobei die restliche Funktionalit&auml;t voll erhalten bleibt. Falls Sie dies nicht
w&uuml;nschen, k&ouml;nnen Sie mit dem <a href=#97>SET</a>-Befehl
<pre>
SET Cmd.Copy.ClassicEagleMode 1
</pre>
das fr&uuml;here Verhalten des COPY-Befehls (und auch des <a href=#43>CUT</a>-Befehls)
wieder herstellen.
<h2>Leitungen kopieren</h2>
Kopiert man Wires oder Polygone, die zu einem Signal geh&ouml;ren, dann
geh&ouml;rt die Kopie zum selben Signal. Bitte beachten Sie, dass aus diesem
Grund der DRC keinen Fehler feststellt, wenn z. B. zwei Wires mit COPY
&uuml;berlappend plaziert werden.<br>
Wenn einer der Endpunkte des kopierten Wires auf dem Source-Segment liegt,
so wird der Wire mit diesem Segment verbunden. Wenn nicht, wird daf&uuml;r ein
eigenes Segment angelegt (siehe auch 'Kopieren und Konnektivit&auml;t').
<h2>Bauteile kopieren</h2>
Beim Kopieren eines Bauteils in einem Schaltplan wird immer eine komplette
neue Instanz dieses Bauteils hinzugef&uuml;gt, auch wenn nur ein einzelnes Gatter
eines aus mehreren Gattern bestehenden Bauteils selektiert wurde. Zus&auml;tzlich
zu dem selektierten Gatter werden all jene Gatter des zugeh&ouml;rigen Devices,
welche Add-Level MUST oder ALWAYS haben, automatisch auch hinzugef&uuml;gt.
<p>
Wenn Sie lediglich ein weiteres Gatter eines aus mehreren Gattern bestehenden
Bauteils verwenden wollen, sollten Sie stattdessen den
<a href=#60>INVOKE</a>-Befehl benutzen.
<h2>Bibliothekselemente kopieren</h2>
Durch Angabe von <tt>COPY deviceset@library</tt> oder <tt>COPY package@library</tt>
kann ein Device-Set oder ein Package aus einer gegebenen Bibliothek in die aktuell
geladene Bibliothek kopiert werden. <tt>library </tt> darf entweder direkt der Bibliotheksname
oder der volle Name mit Pfadangabe sein (vgl.  <a href=#30>ADD</a>-Befehl).
Um Namenskonflikte zu vermeiden, k&ouml;nnen Sie die Endung <tt>[.dev]</tt> am Device-Set-
bzw. <tt>[.pac]</tt> am Package-Namen anf&uuml;gen.
Wird zus&auml;tzlich noch <tt>name</tt> angegeben, so erh&auml;lt das kopierte Objekt den angegebenen Namen.
Dies kann ebenso &uuml;ber das <a href=#14>Kontext-Men&uuml;</a> der
Bibliotheksobjekte oder &uuml;ber <i>Drag&amp;Drop</i> aus der Baumansicht des Control
Panels erfolgen.
<p>
<b>Beachten Sie bitte, dass etwaige existierende Bibliotheksobjekte (Device-Sets,
Symbole oder Packages), die von dem kopierten Bibliotheksobjekt verwendet werden,
automatisch upgedatet werden.</b>
<h2>Eine Gruppe kopieren</h2>
Das Kopieren einer Gruppe durch Anklicken mit der rechten Maustaste wird durch
eine implizite <a href=#43>CUT</a>-Operation, gefolgt von einem
<a href=#78>PASTE</a> realisiert.
<h2>Objekte auf eine andere Seite kopieren</h2>
Um Objekte auf eine andere Seite des gleichen Schaltplans zu kopieren, m&uuml;ssen Sie diese
mit <a href=#56>GROUP</a> gruppieren, den <a href=#42>COPY</a>-Befehl
(oder <a href=#43>CUT</a>) ausf&uuml;hren, auf die Ziel-Seite wechseln
und dort <a href=#78>PASTE</a> machen.
<h2>Kopieren und Konnektivit&auml;t</h2>
Das Kopieren von Wires &auml;ndert nicht ihre Zugeh&ouml;rigkeit zu Segmenten oder Signalen.
Wenn Sie beispielsweise ein Netz kopieren und dieses bei einem anderen Netz positionieren,
wird es nicht mit diesem Netz verbunden. Das Gleiche gilt bei Segmenten desselben Netzes, Bussen etc.
Um Verbindungen zu schaffen, verwenden Sie <a href=#72>NAME</a>
oder <a href=#61>JUNCTION</a>.


<a name=43>
<h1>CUT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Gruppe in die Zwischenablage kopieren.
<dt>
<b>Syntax</b>
<dd>
<tt>CUT &#149;</tt><br>
<tt>CUT;</tt>
</dl>
<b>Siehe auch</b> <a href=#78>PASTE</a>,
<a href=#56>GROUP</a>
<p>
Teile einer Zeichnung (z. B. auch eine ganze Platine) lassen sich
mit Hilfe der Befehle GROUP, CUT und PASTE in andere Zeichnungen
&uuml;bernehmen.
<p>
Zuerst definiert man eine Gruppe (GROUP). Dann aktiviert man den Befehl
CUT, gefolgt von einem Referenzpunkt (Mausklick oder Angabe einer
Koordinate (x y)) der die selektierten Objekte in die Zwischenablage kopiert.
<tt>CUT;</tt> setzt den Referenzpunkt automatisch etwa in der Mitte der
selektierten Objekte (genauer: am n&auml;chstgelegenen Rasterpunkt).
Jetzt kann man die Zeichnung wechseln
und mit PASTE den Inhalt der Zwischenablage in die neue Zeichnung kopieren. Falls
erforderlich, werden neue Namen generiert. Der Pufferinhalt bleibt
erhalten und kann mit weiteren PASTE-Befehlen erneut kopiert werden.
<h2>Referenzpunkt</h2>
Wird beim CUT-Befehl mit der Maus ein Punkt angeklickt, dann befindet
sich beim PASTE-Befehl der Mauszeiger an dieser Stelle der Gruppe
(genauer: am n&auml;chstgelegenen Rasterpunkt). Ansonsten befindet
sich der Mauszeiger bei PASTE etwa in der Mitte der Gruppe.
<h2>Hinweis</h2>
Im Gegensatz zu anderen (Windows-) Programmen entfernt der
CUT-Befehl von EAGLE die markierte Gruppe nicht physikalisch aus der
Zeichnung, sondern kopiert die Gruppe lediglich in die Zwischenablage.
Ungl&uuml;cklicherweise hat dies Windows-Anwender immer wieder irritiert,
so dass seit Version 6 der CUT-Befehl nicht mehr im Pulldown-Men&uuml; und der
Toolbar mit den Befehls-Buttons erscheint (in der Befehlszeile und in Scripts ist
er weiterhin verf&uuml;gbar). Windows-Anwender werden einfach den <a href=#42>COPY</a>-Befehl
verwenden um die selektierte Gruppe von Objekten in die System-Zwischenablage
zu kopieren. Allerdings k&ouml;nnen sie dabei keinen Referenzpunkt f&uuml;r die
Selektion der Gruppe festlegen. Sie wird immer in der Mitte ihres
umschlie&szlig;enden Rechtecks selektiert. Die Verwendung eines expliziten
Referenzpunktes ist nur m&ouml;glich mit dem CUT-Befehl.
Falls Sie dies nicht w&uuml;nschen, k&ouml;nnen Sie mit dem <a href=#97>SET</a>-Befehl
<pre>
SET Cmd.Copy.ClassicEagleMode 1
</pre>
das fr&uuml;here Verhalten des CUT-Befehls (und auch des <a href=#42>COPY</a>-Befehls)
wieder herstellen.


<a name=44>
<h1>DELETE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
L&ouml;schen von Objekten.
<dt>
<b>Syntax</b>
<dd>
<tt>DELETE &#149;..</tt><br>
<tt>DELETE name ..</tt><br>
<tt>DELETE SIGNALS</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Shift+Linke</mb> l&ouml;scht das &uuml;bergeordnete Objekt in der Hierarchie.<br>
<mb>Ctrl+Linke</mb> l&ouml;scht die Verbindungsstelle zweier Wires.<br>
<mb>Ctrl+Rechte</mb> l&ouml;scht die Gruppe.
</dl>
<b>Siehe auch</b> <a href=#92>RIPUP</a>,
<a href=#48>DRC</a>,
<a href=#56>GROUP</a>
<p>
Der DELETE-Befehl l&ouml;scht das selektierte Objekt aus der Zeichnung.
<p>
Bauteile, Pads, Smds, Pins und Gatter lassen sich
auch mit ihrem Namen selektieren. Das ist vor allem dann n&uuml;tzlich,
wenn sich das Objekt ausserhalb des gerade dargestellten Bildausschnitts
befindet. Beim Selektieren eines aus mehreren Gattern bestehenden Bauteils
im Schaltplan muss der volle, aus dem Bauteil- und dem jeweiligen Gatternamen
bestehende Name angegeben werden.
<p>
Attribute von Bauteilen k&ouml;nnen dadurch selektiert werden, dass die Kombination
aus Bauteilname und Attributname angegeben wird, wie etwa <tt>R5&gt;VALUE</tt>.
<p>
Mit der rechten Maustaste wird eine zuvor mit <a href=#56>GROUP</a>
definierte Gruppe gel&ouml;scht.
<p>
Nach dem L&ouml;schen einer Gruppe k&ouml;nnen Luftlinien, die durch das Entfernen
von Bauelementen neu entstanden sind, "&uuml;brigbleiben", da diese nicht in der
urspr&uuml;nglich definierten Gruppe enthalten waren. In solchen F&auml;llen sollte
mit <a href=#86>RATSNEST</a> eine Neuberechnung der Luftlinien
durchgef&uuml;hrt werden.
<p>
Bei aktiver <a href=#372>Forward&amp;Back-Annotation</a> k&ouml;nnen
im Board keine Wires oder Vias aus Signalen gel&ouml;scht werden, die an
Bauelemente angeschlossen sind. Ebenso k&ouml;nnen keine Bauelemente gel&ouml;scht
werden, an die Signale angeschlossen sind. &Auml;nderungen dieser Art m&uuml;ssen
im Schaltplan vorgenommen werden.
<p>
Um eine bereits verlegte Verbindung im Board wieder in eine Luftlinie
zu verwandeln, verwenden Sie den <a href=#92>RIPUP</a>-Befehl.
<p>
Der DELETE-Befehl wirkt nur auf sichtbare Layer (siehe
DISPLAY-Befehl).
<h2>L&ouml;schen von Wire-Verbindungsstellen</h2>
Wird der DELETE-Befehl mit gedr&uuml;ckter <tt>Ctrl</tt>-Taste auf die Verbindungsstelle
zweier Wires angewendet, so werden diese zu einem einzelnen, geradlinigen Wire
zusammengefasst. Die beiden Wires m&uuml;ssen dazu im gleichen Layer liegen, die gleiche
Breite, den gleichen Linien-Typ und runde Enden (im Falle von Kreisb&ouml;gen) haben.
<h2>L&ouml;schen von Polygon-Kanten</h2>
Bei Polygonen l&ouml;scht der DELETE-Befehl jeweils eine Ecke. Sind
nur noch drei Ecken vorhanden, wird das ganze Polygon gel&ouml;scht.
<h2>L&ouml;schen von Bauelementen</h2>
Bauelemente auf der Top-Seite lassen sich nur l&ouml;schen, wenn der
tOrigins-Layer sichtbar ist und wenn (bei aktiver
<a href=#372>Forward&amp;Back-Annotation</a>) keine Signale
mit dem Element verbunden sind (siehe auch
<a href=#91>REPLACE</a>). Entsprechend lassen sich
Bauelemente auf der Bottom-Seite nur l&ouml;schen, wenn der bOrigins-Layer
eingeblendet ist.
<h2>L&ouml;schen von Junction-Punkten, Netzen und Bussen</h2>
Es gelten folgende Regeln:
<ul>
<li>Zerf&auml;llt ein Bus-Segment in zwei Teilsegmente, so behalten beide
den urspr&uuml;nglichen Namen.
<li>Zerf&auml;llt ein Netz-Segment in zwei Teilsegmente,
so beh&auml;lt das gr&ouml;&szlig;ere der beiden Teilsegmente den urspr&uuml;nglichen
Namen, w&auml;hrend das kleinere einen (neuen) generierten Namen erh&auml;lt.
<li>Labels geh&ouml;ren nach der Trennung zum jeweils n&auml;chstgelegenen
Segment.
<li>Wird ein Junction-Punkt gel&ouml;scht, so wird das Netz an dieser
Stelle aufgetrennt. Pr&uuml;fen Sie im Zweifelsfall mit SHOW nach,
welches Segment welchen Namen erhalten hat; falls die umgekehrte Namensgebung
gew&uuml;nscht wird, l&auml;sst sie sich mit dem NAME-Befehl leicht
erreichen.
</ul>
<h2>L&ouml;schen von Supply-Symbolen</h2>
Wird das letzte Supply-Symbol einer gegebenen Versorgungsspannung von einem
Netzsegment, das den Namen dieses Supply-Symbols tr&auml;gt, gel&ouml;scht, erh&auml;lt dieses
Netzsegment einen neuen, automatisch generierten Namen (sofern kein anderes
Supply-Symbol mehr diesem Segment zugeordnet ist) oder den Namen eines noch
verbleibenden anderen Supply-Symbols.
<h2>L&ouml;schen von Signalen</h2>
Selektiert man mit dem DELETE-Befehl Wires oder Vias, die zu
einem Signal geh&ouml;ren, dann sind drei F&auml;lle zu unterscheiden:
<ul>
<li>Das Signal wurde aufgetrennt und zerf&auml;llt in zwei Teile. EAGLE
vergibt dann intern f&uuml;r das kleinere Teilsignal einen neuen Namen
und beh&auml;lt den bisherigen Namen f&uuml;r das gr&ouml;&szlig;ere Teilsignal
bei.
<li>Das Signal wurde von einem Ende her gel&ouml;scht. Das verbleibende
Teilsignal beh&auml;lt seinen bisherigen Namen.
<li>Das Signal bestand nur noch aus einer Verbindung. Es ist dann ganz
gel&ouml;scht, und der bisherige Name existiert nicht mehr.
</ul>
Werden Wires oder Vias eines Signals gel&ouml;scht, das Polygone enth&auml;lt, dann
bleiben alle Polygone in dem Teil des Signals, der den urspr&uuml;nglichen
Namen beh&auml;lt (normalerweise der "gr&ouml;&szlig;ere" Teil).
<h2>Alle Signale l&ouml;schen</h2>
<p>
DELETE SIGNALS kann dazu verwendet werden, alle Signale aus einer
Platine zu entfernen, um z. B. eine neue oder ge&auml;nderte Netzliste
einzulesen. Es werden nur solche Signale entfernt, die an Pads angeschlossen
sind. Andere (wie z.B. Eckwinkel im Top- und Bottom-Layer, die intern
auch als Signal behandelt werden) bleiben unber&uuml;hrt.
<p>
Falls ein Bauteil gel&ouml;scht werden soll, das den Namen SIGNALS tr&auml;gt,
so muss dieser in einfache Hochkommas gesetzt werden.
<h2>L&ouml;schen von &uuml;bergeordneten Objekten</h2>
Wird ein Objekt mit gedr&uuml;ckter <tt>Shift</tt>-Taste angeklickt, so wird das in der Hierarchie
n&auml;chsth&ouml;here Objekt gel&ouml;scht. Im Einzelnen gilt dies f&uuml;r folgende Objekte:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>Gatter</tt>  </td><td width=20><td>L&ouml;scht das gesamte Bauteil, in dem sich dieses Gatter befindet (auch wenn die Gatter auf mehrere Schaltplan-Seiten verteilt sind). Bei aktiver Forward&amp;Backannotation werden die Leiterbahnen, die an dem Bauteil im Board angeschlossen sind, nicht in Luftlinien umgewandelt (was beim L&ouml;schen einzelner Gatter geschehen w&uuml;rde), ausgenommen die F&auml;lle wo ein Pin des gel&ouml;schten Bauteils nur direkt mit genau einem anderen Pin und keinem Net-Wire verbunden ist</td></tr>
<tr><td><tt>Polygon&nbsp;Wire</tt> </td><td width=20><td>L&ouml;scht das gesamte Polygon</td></tr>
<tr><td><tt>Net/Bus&nbsp;Wire</tt> </td><td width=20><td>L&ouml;scht das gesamte Netz- bzw. Bus-Segment</td></tr>
</table>
<p>
Der DRC erzeugt unter Umst&auml;nden Fehlerpolygone, die man nicht mit DELETE
l&ouml;schen kann, sondern mit DRC Clear.


<a name=45>
<h1>DESCRIPTION</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert die Beschreibung einer Zeichnung oder eines Bibliotheksobjekts.
<dt>
<b>Syntax</b>
<dd>
<tt>DESCRIPTION [ * ] [ description_string; ]</tt><br>
<tt>DESCRIPTION ** [ description_string; ]</tt>
</dl>
<b>Siehe auch</b> <a href=#41>CONNECT</a>,
<a href=#76>PACKAGE</a>,
<a href=#108>VALUE</a>
<p>
Mit diesem Befehl erzeugt oder editiert man die Beschreibung einer Zeichnung oder eines Bibliotheksobjekts.
<p>
<tt>description_string</tt> kann <a href=#370>HTML</a>-Steuerzeichen enthalten.
<p>
Die erste nicht leere Zeile von <tt>description_string</tt> wird als Kurzbeschreibung
(<i>headline</i>) im Control Panel angezeigt.
<p>
Der DESCRIPTION-Befehl ohne Angabe von Parametern &ouml;ffnet einen Dialog, der das
Editieren des Textes erlaubt. Der obere Teil des Dialogs zeigt den formatierten Text,
sofern er Steuerzeichen des <a href=#370>HTML</a>-Formats enth&auml;lt,
w&auml;hrend der untere Teil f&uuml;r die Eingabe des Textes genutzt wird. Ganz oben im Dialog
sehen Sie das Feld <i>headline</i>. In diesem wird die Kurzbeschreibung ohne
HTML-Steuerzeichen angezeigt.
<p>
Normalerweise bearbeitet der DESCRIPTION-Befehl die Beschreibung des Objektes, welches
gerade editiert wird, wie etwa ein Device Set, Package, Symbol, Board oder Sheet.
Falls es in einer Bibliothek noch kein gerade editiertes Object gibt (wie es nach dem
Laden einer Bibliothek der Fall ist), so wird die Bescheibung der Bibliothek
bearbeitet.
<p>
Um explizit die Beschreibung einer Bibliothek zu bearbeiten, auch wenn bereits ein
Device Set, Package oder Symbol bearbeitet wird, geben Sie einen Stern (<tt>'*'</tt>)
als ersten Parameter des DESCRIPTION-Befehls ein. Auf diese Weise kann auch die
Beschreibung eines Schaltplans angesprochen werden anstelle der des gerade bearbeiteten
Sheets.
<p>
Um die Beschreibung des aktuellen <a href=#70>MODULE</a> zu bearbeiten,
geben Sie zwei Sterne (<tt>'**'</tt>) als ersten Parameter des DESCRIPTION-Befehls ein.
<h2>Beispiel</h2>
<pre>
DESCRIPTION '&lt;b&gt;Quad NAND&lt;/b&gt;&lt;p&gt;\nFour NAND gates with 2 inputs each.';
</pre>
Das Resultat sieht so aus:
<p>
<b>Quad NAND</b><p>
Four NAND gates with 2 inputs each.


<a name=46>
<h1>DIMENSION</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
F&uuml;gt Bema&szlig;ungen zu einer Zeichnung hinzu.
<dt>
<b>Syntax</b>
<dd>
<tt>DIMENSION [dtype] &#149; &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.<br>
<mb>Rechte</mb> &auml;ndert die Ausrichtung.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung des Weiterschaltens der Ausrichtung um.<br>
<mb>Ctrl+Linke</mb> beim Beginn oder Ende einer Bema&szlig;ung selektiert kein Objekt.<br>
</dl>
<b>Siehe auch</b> <a href=#112>WIRE</a>,
<a href=#37>CHANGE</a>,
<a href=#38>CIRCLE</a>,
<a href=#58>HOLE</a>
<p>
Der DIMENSION-Befehl dient zum Bema&szlig;en einer Zeichnung.
Er kann entweder auf ein Objekt angewendet werden, oder beliebige
Bema&szlig;ungen zeichnen.
<p>
Wird mit dem ersten Mausklick ein Objekt selektiert, so wird eine daf&uuml;r
passende Bema&szlig;ung wie folgt gew&auml;hlt:
<p>
<table cellspacing=5>
<tr><td>gerader Wire</td>  <td width=20><td>lineare Bema&szlig;ung, die den Abstand der Endpunkte des Wires anzeigt</td></tr>
<tr><td>gebogener Wire</td><td width=20><td>radiale Bema&szlig;ung, die den Radius des Kreisbogens anzeigt</td></tr>
<tr><td>Circle</td>        <td width=20><td>Durchmesser-Bema&szlig;ung, die den Durchmesser des Kreises anzeigt</td></tr>
<tr><td>Hole</td>          <td width=20><td>Durchmesser-Bema&szlig;ung, die den Durchmesser des Lochs anzeigt</td></tr>
</table>
<p>
Wird kein Objekt selektiert, oder wird ein Wire an einem seiner Endpunkte
selektiert, so wird ein Bema&szlig;ungs-Objekt gem&auml;&szlig; dem aktuellen "dtype"
Parameter erzeugt.
Falls dies nicht die gew&uuml;nschte Ausrichtung ist, so kann mit der rechten
Maustaste durch die verschiedenen Ausrichtungstypen geschaltet werden.
<p>
Um eine beliebige Bema&szlig;ung auch in der N&auml;he eines Objektes zeichnen zu k&ouml;nnen,
welches normalerweise eine bestimmte Art von Bema&szlig;ung ausl&ouml;sen w&uuml;rde, dr&uuml;cken
die beim ersten Mausklick die <tt>Ctrl</tt>-Taste. Dies kann auch bei der
Verwendung des DIMENSION-Befehls in einem Script n&uuml;tzlich sein (durch
Angabe des 'C'-Steuerzeichens in der ersten Koordinate), um sicherzstellen,
dass die Bema&szlig;ung genau wie erw&uuml;nscht erfolgt.
<p>
Die Art und Weise, wie ein Bema&szlig;ungs-Objekt dargestellt wird (Linien, Einheit, Aufl&ouml;sung),
kann mit "CHANGE DLINE/DUNIT" oder in seinem Eigenschaftendialog eingestellt werden.
Beachten Sie dabei, dass der Parameter "Einheit" die Einheit vorgibt, in der
die Zahlenwerte des Bema&szlig;ungs-Objekts angezeigt werden.
<h2>Ausrichtung</h2>
Jedes Bema&szlig;ungs-Objekt hat drei Koordinaten, die seine Referenzpunkte
und ggf. einen Ausrichtungspunkt definieren. Wie diese Koordinaten
konkret f&uuml;r die Darstellung eines Bema&szlig;ungs-Objekts verwendet werden
h&auml;ngt von der Ausrichtung ("dtype") ab.
<p>
<b>Parallel</b>
<p>
Eine <i>parallel</i> Bema&szlig;ung zeigt den Abstand zwischen ihrem ersten und
zweiten Referenzpunkt an. Die Ma&szlig;linie verl&auml;uft parallel zu der Geraden
durch die Referenzpunkte, und geht durch den Ausrichtungspunkt. Die genaue
Position des Ausrichtungspunkts spielt keine Rolle, da nur sein Abstand
zu der Geraden durch die Referenzpunkte benutzt wird.
Wird eine parallele Bema&szlig;ung neu erzeugt oder ver&auml;ndert, so wird der
Ausrichtungspunkt normalisiert, so dass er in der Mitte der Ma&szlig;linie liegt.
<p>
<b>Horizontal</b>
<p>
Wie <i>parallel</i>, aber die Ma&szlig;linie verl&auml;uft nur in X-Richtung
und zeigt nur den X-Abstand der Referenzpunkte an.
<p>
<b>Vertical</b>
<p>
Wie <i>horizontal</i>, aber f&uuml;r Y.
<p>
<b>Radius</b>
<p>
Eine <i>radius</i> Bema&szlig;ung zeigt den Abstand zwischen ihrem ersten und zweiten
Referenzpunkt an. Der erste Referenzpunkt liegt am Mittelpunkt des Kreisbogens,
f&uuml;r den diese Bema&szlig;ung gezeichnet wurde. Der zweite Punkt liegt auf dem
Kreisbogen.
Liegt der Ausrichtungspunkt zwischen den beiden Referenzpunkten, so wird die
Ma&szlig;linie zwischen den Referenzpunkten dargestellt, also "innerhalb" des Kreisbogens.
Ansonsten wird die Ma&szlig;linie "au&szlig;erhalb" des Kreisbogens dargestellt.
Falls der Bema&szlig;ungstext zu lang ist um innerhalb des Radius-Bema&szlig;ung dargestellt
zu werden, so wird die Ma&szlig;linie ebenfalls au&szlig;en dargestellt.
Eine Radius-Bema&szlig;ung zeigt automatisch ein Kreuz an ihrem ersten Referenzpunkt
(dem Mittelpunkt des Keisbogens) an.
Wird eine Radius-Bema&szlig;ung neu erzeugt oder ver&auml;ndert, so wird der
Ausrichtungspunkt normalisiert, so dass er f&uuml;r eine "innere" Bema&szlig;ung in der Mitte
der Ma&szlig;linie liegt, f&uuml;r eine "&auml;u&szlig;ere" gleich hinter dem Ma&szlig;pfeil.
<p>
<b>Diameter</b>
<p>
Eine <i>diameter</i> Bema&szlig;ung zeigt den Abstand zwischen ihrem ersten und
zweiten Referenzpunkt an. Die beiden Punkte liegen an gegen&uuml;berliegenden
Seiten auf dem Umfang des Kreises, so dass ihr Abstand dem Kreisdurchmesser
entspricht.
Liegt der Ausrichtungspunkt zwischen den beiden Referenzpunkten, so wird die
Ma&szlig;linie zwischen den Referenzpunkten dargestellt, also "innerhalb" des Kreises.
Ansonsten wird die Ma&szlig;linie "au&szlig;erhalb" des Kreises dargestellt, so wie bei
einer <i>parallel</i> Bema&szlig;ung.
Falls der Bema&szlig;ungstext zu lang ist um innerhalb der Durchmesser-Bema&szlig;ung dargestellt
zu werden, so wird die Ma&szlig;linie ebenfalls au&szlig;en dargestellt.
Eine Durchmesser-Bema&szlig;ung zeigt automatisch ein Kreuz an ihrem ersten Referenzpunkt
(dem Mittelpunkt des Keises) an.
Wird eine Durchmesser-Bema&szlig;ung neu erzeugt oder ver&auml;ndert, so wird der
Ausrichtungspunkt normalisiert, so dass er f&uuml;r eine "innere" Bema&szlig;ung an der
selben Stelle liegt wie der zweite Punkt, f&uuml;r eine "&auml;u&szlig;ere" in der Mitte der
Ma&szlig;linie.
<p>
<b>Angle</b>
<p>
Eine <i>angle</i> Bema&szlig;ung zeigt den Winkel zwischen ihrem zweiten und dritten
Referenzpunkt an, gegen den Uhrzeigersinn gemessen vom ersten Referenzpunkt
aus gesehen (dem Mittelpunkt des Kreisbogens).
Wird eine Winkel-Bema&szlig;ung neu erzeugt oder ver&auml;ndert, so wird der
zweite Referenzpunkt normalisiert, so dass er den gleichen Abstand vom ersten
Punkt hat wie der dritte.
<p>
<b>Leader</b>
<p>
Eine <i>leader</i> Bema&szlig;ung kann dazu benutzt werden, um einen Hinweis in einer
Zeichnung anzubringen.
Am ersten Punkt befindet sich ein Pfeil, und der zweite und dritte Punkt
definieren eine (geknickte) Linie. Es wird keine Ma&szlig;zahl dargestellt.
Sie k&ouml;nnen den <a href=#104>TEXT</a>-Befehl benutzen um beliebigen
Text zu platzieren.
<h2>Selektion</h2>
Ein Bema&szlig;ungs-Objekt kann an jedem seiner drei Punkte selektiert werden.


<a name=47>
<h1>DISPLAY</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Ausw&auml;hlen der sichtbaren Layer.
<dt>
<b>Syntax</b>
<dd>
<tt>DISPLAY</tt><br>
<tt>DISPLAY [option] layer_number..</tt><br>
<tt>DISPLAY [option] layer_name..</tt>
</dl>
<b>Siehe auch</b> <a href=#63>LAYER</a>,
<a href=#84>PRINT</a>
<p>
G&uuml;ltige options sind: ALL, NONE, LAST, ? und ??
<p>
Mit dem DISPLAY-Befehl w&auml;hlt man diejenigen Layer aus, die auf
dem Bildschirm sichtbar sein sollen. Dabei darf als Parameter die
Layer-Nummer oder der Layer-Name angegeben werden (auch gemischt).
Gibt man den Parameter ALL an, werden alle Layer sichtbar. Mit dem
Parameter NONE kann man alle Layer ausblenden. Beispiel:
<pre>
DISPLAY NONE BOTTOM
</pre>
Nach diesem Befehl ist nur der Bottom-Layer sichtbar.
<p>
Wird der Parameter LAST angegeben, so werden die zuvor sichtbaren Layer dargestellt.
<p>
Bitte beachten Sie, dass von den Signal-Layern (1 bis 16) nur diejenigen
zur Verf&uuml;gung stehen, die im Layer-Setup in den <a href=#139>Design Rules</a>
eingetragen sind.
<p>
Stellt man dem Layer-Namen oder der Layer-Nummer ein Minuszeichen
voran, wird er ausgeblendet. Beispiel:
<pre>
DISPLAY BOTTOM -TOP -3
</pre>
In diesem Fall wird Bottom eingeblendet, und Top sowie der Layer mit
der Nummer 3 werden ausgeblendet.
<p>
Manche Befehle (PAD, SMD, SIGNAL, ROUTE) aktivieren automatisch
bestimmte Layer.
<p>
Wird der DISPLAY-Befehl ohne Parameter aufgerufen, so erscheint ein
Dialog in dem alle Einstellungen vorgenommen werden k&ouml;nnen.
<h2>Nicht definierte Layer</h2>
Die Optionen '?' und '??' werden verwendet, zu kontollieren, was passiert,
wenn ein nicht definierter Layer &uuml;ber DISPLAY aufgerufen wird. Jeder nicht
definierte Layer, der einem '?' folgt, erzeugt eine Warnmeldung, die der Benutzer
entweder best&auml;tigen kann oder mit Cancel den DISPLAY-Befehl abbrechen kann.
Nicht definierte Layer, die nach '??' folgen, werden kommentarlos ignoriert.
Diese Optionen sind besonders beim Schreiben von Script-Dateien n&uuml;tzlich, die
in der Lage sein sollen beliebige Dateien zu modifizieren, unabh&auml;ngig davon welche
Layer in der Datei letztendlich definiert wurden.
<pre>
DISPLAY TOP BOTTOM ? MYLAYER1 MYLAYER2 ?? OTHER WHATEVER
</pre>
Im Beispiel oben m&uuml;ssen die Layer TOP und BOTTOM definiert sein. Ansonsten wird der
Befehl mit einer Fehlermeldung abgebrochen. Das Fehlen von MYLAYER1 und MYLAYER2 wird in einer
Warnung angezeigt. Die Aktion kann vom Benutzer abgebrochen werden. Die Layer OTHER und
WHATEVER werden angezeigt, wenn vorhanden, ansonsten werden sie einfach ignoriert.
<p>
Die Optionen '?' und '??' d&uuml;rfen in einer Befehlssequenz beliebig oft verwendet werden.
<h2>Pads und Vias</h2>
Verwendet man Pads und Vias mit unterschiedlichen Formen in den einzelnen
Layern, werden alle Formen, die in den sichtbaren (&uuml;ber DISPLAY aktivierten)
Signal-Layern verwendet werden, &uuml;bereinander dargestellt.
<p>
W&auml;hlt man f&uuml;r den Layer 17 (Pads) bzw. 18 (Vias) die Farbe 0 (das entspricht
der Hintergrundfarbe), werden Pads und Vias in der Farbe
und dem F&uuml;llmuster des jeweiligen Signal-Layers gezeichnet. Ist kein
Signal-Layer eingeblendet, werden auch keine Pads oder Vias dargestellt.
<p>
W&auml;hlt man f&uuml;r den Layer 17 (Pads) bzw. 18 (Vias) eine andere Farbe und es ist
kein Signal-Layer sichtbar, werden Pads und Vias in der Form des obersten
und untersten Signal-Layers dargestellt.
<p>
Das gilt auch f&uuml;r Ausdrucke mit PRINT.
<h2>Objekte selektieren</h2>
Um Objekte selektieren zu k&ouml;nnen (z. B. mit MOVE,
DELETE) muss der entsprechende Layer sichtbar sein. Elemente in
Platinen lassen sich nur selektieren, wenn der tOrigins-Layer (bzw.
bOrigins bei gespiegelten Elementen) sichtbar ist!
<p>
Vermeiden Sie die Layer-Namen ALL und NONE, sowie Namen, die mit einem
Minuszeichen beginnen.
<h2>Parameter-Aliase</h2>
Parameter-Aliase k&ouml;nnen dazu benutzt werden, bestimmte Parameter-Einstellungen des DISPLAY-Befehls
zu definieren, die sp&auml;ter unter einem gegebenen Namen angesprochen werden k&ouml;nnen.
Die Aliase k&ouml;nnen auch benutzt werden indem Sie auf den DISPLAY-Button klicken
und die Maustaste gedr&uuml;ckt halten bis die Liste erscheint.
Ein Klick auf den Button mit der rechten Maustaste l&auml;&szlig;t die Liste ebenfalls erscheinen.
<p>
Die Syntax zur Bearbeitung dieser Aliase ist:
<dl>
<dt>
<tt>DISPLAY = <i>name</i> <i>parameter</i></tt>
<dd>
Definiert den Alias <i>name</i>, der in die angegebenen <i>parameter</i>
expandiert wird. Der <i>name</i> darf aus beliebig vielen Buchstaben, Ziffern
und Unterstrichen bestehen, und Gro&szlig;-/Kleinschreibung spielt keine Rolle.
Er muss mit einem Buchstaben oder Unterstrich beginnen und darf keines der
Options-Schl&uuml;sselworte sein.
<dt>
<tt>DISPLAY = <i>name</i> @</tt>
<dd>
Definiert den Alias <i>name</i>, der in die aktuelle Parameter-Einstellung
des Befehls expandiert wird.
<dt>
<tt>DISPLAY = ?</tt>
<dd>
Erfragt vom Benutzer einen Namen zur Definition eines Aliases f&uuml;r
die aktuelle Parameter-Einstellung des Befehls.
<dt>
<tt>DISPLAY = <i>name</i></tt>
<dd>
&Ouml;ffnet den DISPLAY-Dialog und erlaubt es dem Benutzer einen
Satz von Layern einzustellen, der als Alias unter dem angegebenen
Namen gespeichert wird.
<dt>
<tt>DISPLAY = <i>name</i>;</tt>
<dd>
L&ouml;scht den Alias mit dem angegebenen Namen.
<dt>
<tt>DISPLAY <i>name</i></tt>
<dd>
Expandiert den Alias mit dem angegebenen Namen und f&uuml;hrt den DISPLAY-Befehl
mit dem resultierenden Satz von Parametern aus. Der <i>name</i> kann
abgek&uuml;rzt werden und es d&uuml;rfen andere Parameter vor und nach dem
Alias angegeben werden (auch andere Aliase). Beachten Sie bitte,
dass im Falle einer abgek&uuml;rzten Eingabe Aliase Vorrang vor anderen Schl&uuml;sselw&ouml;rtern
des Befehls haben.
</dl>
Beispiel:
<p>
<tt>DISPLAY = MyLayers None Top Bottom Pads Vias Unrouted</tt>
<p>
Definiert den Alias "MyLayers" der, wenn er wie in
<p>
<tt>DISPLAY myl</tt>
<p>
benutzt wird, genau die Layer Top, Bottom, Pads, Vias und Unrouted anzeigt
(ohne den "None"-Parameter w&uuml;rden die angegebenen Layer zus&auml;tzlich zu den
bereits sichbaren angezeigt).
Beachten Sie bitte die abgek&uuml;rzte Verwendung des Aliases,
und dass die Gro&szlig;-/Kleinschreibung keine Rolle spielt.


<a name=48>
<h1>DRC</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Design Rule Check (Platine pr&uuml;fen)
<dt>
<b>Syntax</b>
<dd>
<tt>DRC</tt><br>
<tt>DRC &#149; &#149; ;</tt><br>
<tt>DRC LOAD|MERGE|SAVE filename;</tt><br>
<tt>DRC *</tt>
</dl>
<b>Siehe auch</b> <a href=#139>Design Rules</a>,
<a href=#39>CLASS</a>,
<a href=#97>SET</a>,
<a href=#50>ERC</a>,
<a href=#51>ERRORS</a>
<p>
Der DRC-Befehl pr&uuml;ft das Layout gegen&uuml;ber einem g&uuml;ltigen Satz von <a href=#139>Design Rules</a>.
<p>
Beachten Sie bitte, dass elektrisch nicht relevante Objekte (Wires in Packages, Rechtecke,
Kreise und Texte) untereinander nicht auf Mindestabstandsverletzungen ("Clearance")
gepr&uuml;ft werden.
<p>
Die gefundenen Fehler werden als Fehlerpolygone in den zugeh&ouml;rigen Layern dargestellt
und k&ouml;nnen mit dem <a href=#51>ERRORS</a>-Befehl bearbeitet werden.
<p>
Geben Sie den DRC-Befehl ohne weitere Parameter an, &ouml;ffnet sich der Design-Rules-Dialog.
Von hier aus kann man die Design Rules einstellen und die Pr&uuml;fung starten.
<p>
Wird der DRC-Befehl mit zwei Koordinatenpaaren angegeben (oder im DRC-Dialog der
Button Select angeklickt), pr&uuml;ft der DRC nur innerhalb des angegebenen Rechtecks.
Es werden nur die Fehler angezeigt, die innerhalb des Rechteck liegen.
<p>
Falls Sie DRC-Fehler erhalten, die auch nach einer entsprechenden
&Auml;nderung der <a href=#139>Design Rules</a> nicht verschwinden,
&uuml;berpr&uuml;fen Sie bitte die <a href=#39>Netzklasse</a> des beanstandeten
Objektes. M&ouml;glicherweise wird der Fehler wegen eines der Parameter dieser Klasse
gemeldet.
<p>
Um alle Fehlerpolygone zu l&ouml;schen verwenden Sie
<pre>
ERRORS CLEAR
</pre>
<p>
Die Optionen <tt>LOAD</tt> und <tt>SAVE</tt> k&ouml;nnen dazu verwendet werden die
Design Rules aus der angegebenen Datei zu laden bzw. sie in diese zu speichern.
Falls <i>filename</i> nicht die Extension <tt>".dru"</tt> hat wird diese automatisch
angef&uuml;gt. Die Option <tt>MERGE</tt> kann dazu verwendet werden, einzelne Design Rules
Parameter zu &uuml;berschreiben (die anderen bleiben dabei unver&auml;ndert).
<p>
Wird beim DRC-Befehl ein Stern ('*') als erster Parameter eingegeben, so
&ouml;ffnet sich der Design Rules Dialog und erlaubt ein bearbeiten der Design
Rules, ohne dass beim Schlie&szlig;en des Dialogs ein DRC ausgef&uuml;hrt wird.
<h2>SET-Befehle, die den DRC beeinflussen</h2>
Der SET-Befehl kann dazu verwendet werden, um das Verhalten des DRC-Befehls
zu ver&auml;ndern:
<pre>
SET DRC_FILL fill_name;
</pre>
Legt das f&uuml;r die DRC-Fehlerpolygone verwendete F&uuml;llmuster
fest. Default: LtSlash.


<a name=49>
<h1>EDIT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Lade-Befehl.
<dt>
<b>Syntax</b>
<dd>
<tt>EDIT name</tt><br>
<tt>EDIT name.ext</tt><br>
<tt>EDIT .ext</tt><br>
<tt>EDIT .sX [ .sY ]</tt><br>
<tt>EDIT name.mod</tt><br>
<tt>EDIT name.m2</tt><br>
<tt>EDIT .m3</tt><br>
<tt>EDIT modX.m3 modY.m1</tt>
</dl>
<b>Siehe auch</b> <a href=#74>OPEN</a>,
<a href=#40>CLOSE</a>,
<a href=#35>BOARD</a>,
<a href=#70>MODULE</a>
<p>
Der EDIT-Befehl wird verwendet, um eine Platine oder einen Schaltplan
zu editieren bzw. neu anzulegen. Ausserdem dient der Befehl dazu,
Symbole, Devices und Packages zu laden, wenn man eine Bibliothek bearbeitet.
<p>
Der EDIT-Befehl wird auch zum Erzeugen oder Editieren eines Moduls in einem Schaltplan verwendet.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>EDIT name.brd</tt>  </td><td width=20><td>l&auml;dt eine Platine</td></tr>
<tr><td><tt>EDIT name.sch</tt>  </td><td width=20><td>l&auml;dt einen Schaltplan</td></tr>
<tr><td><tt>EDIT name.pac</tt>  </td><td width=20><td>l&auml;dt ein Package</td></tr>
<tr><td><tt>EDIT name.sym</tt>  </td><td width=20><td>l&auml;dt ein Symbol</td></tr>
<tr><td><tt>EDIT name.dev</tt>  </td><td width=20><td>l&auml;dt ein Device</td></tr>
<tr><td><tt>EDIT .s3</tt>       </td><td width=20><td>l&auml;dt Seite 3 eines Schaltplans</td></tr>
<tr><td><tt>EDIT .s5 .s2 </tt>  </td><td width=20><td>verschiebt Seite 5 vor Seite 2 und l&auml;dt sie (falls Seite 5 nicht existiert, wird eine neue Seite vor Seite 2 eingef&uuml;gt)</td></tr>
<tr><td><tt>EDIT .s2 .s5 </tt>  </td><td width=20><td>verschiebt Seite 2 vor Seite 5 und l&auml;dt sie (falls Seite 5 nicht existiert, wird Seite 2 zur letzten Seite)</td></tr>
<tr><td><tt>EDIT name.mod</tt>  </td><td width=20><td>l&auml;dt (oder erzeugt) ein Modul in einem Schaltplan</td></tr>
<tr><td><tt>EDIT name.m2</tt>   </td><td width=20><td>l&auml;dt (oder erzeugt) Seite 2 eines Moduls</td></tr>
<tr><td><tt>EDIT .m3</tt>       </td><td width=20><td>l&auml;dt (oder erzeugt) Seite 3 des aktuellen Moduls</td></tr>
<tr><td><tt>EDIT .s2 modY.m1</tt>  </td><td width=20><td>verschiebt Seite 2 vor Seite 1 von Modul 'modY' und l&auml;dt sie</td></tr>
<tr><td><tt>EDIT modX.m3 modY.m1</tt>  </td><td width=20><td>verschiebt Seite 3 von Modul 'modX' vor Seite 1 von Modul 'modY' und l&auml;dt sie</td></tr>
</table>
<p>
Platzhalter in Namen sind erlaubt (z. B. edit *.brd).
<p>
Gibt man EDIT ohne weitere Parameter ein, k&ouml;nnen Sie die Datei oder
das Objekt mit Hilfe des sich &ouml;ffnenden Men&uuml;s w&auml;hlen.
<p>
Um von einem Schaltplan zu einer Platine mit dem gleichen Namen zu
wechseln, kann man den Befehl
<pre>
EDIT .brd
</pre>
verwenden. Umgekehrt kommt man von der Platine in den entsprechenden
Schaltplan mit
<pre>
EDIT .sch
</pre>
Eine andere Seite eines Schaltplans kann man mit
<pre>
EDIT .sX
</pre>
(X ist die Seitennummer) oder mit Hilfe der Combo-Box in der Action-Toolbar laden.
Falls die angegebene Seitennummer nicht existiert, wird eine neue Seite angelegt.
<p>
Sie k&ouml;nnen auch zwischen Schaltplanseiten wechseln indem Sie auf ein Icon in
der Vorschau f&uuml;r Schaltplanseiten klicken. Drag&amp;drop in der Vorschau
erlaubt es, Seiten umzusortieren.
<p>
Will man Symbole, Devices oder Packages editieren, dann ist zuerst
eine Bibliothek mit OPEN zu &ouml;ffnen und dann der entsprechende
EDIT-Befehl zu geben.
<h2>Welches Verzeichnis?</h2>
Der EDIT-Befehl holt Dateien aus dem
<a href=#15>Projektverzeichnis</a>.


<a name=50>
<h1>ERC</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Electrical Rule Check (Pr&uuml;fung auf elektrische Fehler).
<dt>
<b>Syntax</b>
<dd>
<tt>ERC</tt>
</dl>
<b>Siehe auch</b> <a href=#48>DRC</a>,
<a href=#51>ERRORS</a>,
<a href=#373>Konsistenzpr&uuml;fung</a>
<p>
Dieser Befehl pr&uuml;ft Schaltpl&auml;ne auf elektrische Fehler. Die
Ergebnisse werden im <a href=#51>ERRORS</a> Dialog angezeigt.
<h2>Konsistenzpr&uuml;fung</h2>
Der ERC-Befehl f&uuml;hrt auch eine
<a href=#373>Konsistenzpr&uuml;fung</a>
zwischen Schaltplan und zugeh&ouml;riger Platine durch, sofern die
Board-Datei vor dem Start des ERC geladen worden ist. Als Ergebnis des
ERC wird die automatische
<a href=#372>Forward&amp;Back-Annotation</a>
ein- oder ausgeschaltet, abh&auml;ngig davon, ob die Dateien konsistent
sind oder nicht.
<p>
Bitte beachten Sie, dass der ERC Unterschiede zwischen impliziten Power-Pins und
Supply-Pins im Schaltplan und den tats&auml;chlichen Signalverbindungen im Layout
feststellen kann. Solche Unstimmigkeiten k&ouml;nnen entstehen, wenn Sie die
Supply-Pins im Schaltplan modifizieren, nachdem Sie mit dem BOARD-Befehl eine
Platinen-Datei erzeugt haben. Wenn die Power-Pins nur "implizit" verbunden sind,
k&ouml;nnen diese &Auml;nderungen nicht immer in das Layout &uuml;bertragen werden.<br>
Werden solche Fehler festgestellt, bleibt die <a href=#372>Forward&amp;Back-Annotation</a>
weiterhin erhalten. Allerdings m&uuml;ssen die Supply-Pins &uuml;berpr&uuml;ft werden!


<a name=51>
<h1>ERRORS</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeigt Fehler, die vom ERC bzw. DRC gefunden wurden.
<dt>
<b>Syntax</b>
<dd>
<tt>ERRORS</tt><br>
<tt>ERRORS CLEAR</tt>
</dl>
<b>Siehe auch</b> <a href=#50>ERC</a>,
<a href=#48>DRC</a>
<p>
Zur Auswertung der vom ERC bzw. DRC gefundenen Fehler dient der Befehl ERRORS.
Wird er aktiviert, dann &ouml;ffnet sich ein Fenster, in dem
alle gefundenen Fehler aufgelistet sind.
Wurde f&uuml;r die geladene Zeichnung noch kein ERC bzw. DRC durchgef&uuml;hrt, so wird
zun&auml;chst die entsprechende Pr&uuml;fung automatisch gestartet.
<p>
Die Liste im ERRORS-Dialog besteht aus bis zu vier Abschnitten, die jeweils
<i>Konsistenzfehler</i>, <i>Fehler</i>, <i>Warnungen</i> bzw. <i>Gebilligte</i>
Meldungen enthalten.
<p>
Selektiert man einen Eintrag aus der Liste,
wird die jeweilige Meldung durch eine Bezugslinie im Zeichenfenster angezeigt.
<p>
Ein Doppelklick auf einen Fehlereintrag zentriert die Zeichenfl&auml;che auf die
Position des Fehlers. Aktivieren Sie die Option "Zentriert", geschieht dies
automatisch.
<h2>Eine Meldung als behandelt markieren</h2>
Der <i>Behandelt</i> Button markiert eine Meldung als behandelt. Sie ist zwar noch
in der Liste enthalten, aber es erfolgt keine Fehleranzeige im Zeichenfenster mehr
(ausser wenn der Listeneintrag selektiert wird). Hierdurch k&ouml;nnen Meldungen nach
Behebung des jeweiligen Problems als "abgearbeitet" gekennzeichnet werden, ohne
die Pr&uuml;fung erneut durchzuf&uuml;hren. Nach dem n&auml;chsten ERC bzw. DRC verschwindet die
Meldung entweder ganz, oder sie wird wieder als unbehandelt markiert, falls das
Problem immer noch besteht.
<h2>Eine Meldung billigen</h2>
Falls ein Fehler bzw. eine Warnung nicht behoben werden kann, aber offensichtlich
kein wirkliches Problem darstellt (was der Benutzer zu entscheiden hat), kann Sie
durch Dr&uuml;cken des Buttons <i>Billigen</i> in den Abschnitt <i>Gebilligt</i> verschoben
werden. Meldungen in diesem Abschnitt erzeugen keine Fehleranzeigen im Zeichenfenster
(ausser wenn der Listeneintrag selektiert wird) und sind implizit als "behandelt"
markiert. Falls nach dem n&auml;chsten ERC bzw. DRC die entsprechenden Probleme nicht mehr
bestehen, werden die zugeh&ouml;rigen Meldung in diesem Abschnitt gel&ouml;scht.
Alle gebilligten Meldungen werden in der Zeichnungsdatei mit abgespeichert um zu
dokumentieren, welche Meldungen vom Benutzer explizit als unproblematisch
eingestuft wurden. Beachten Sie bitte, dass Konsistenzfehler nicht gebilligt werden
k&ouml;nnen - diese m&uuml;ssen auf jeden Fall behoben werden um die
<a href=#372>Forward&amp;Back-Annotation</a> zu aktivieren.
<h2>Die Liste l&ouml;schen</h2>
Der <i>Alle l&ouml;schen</i> Button l&ouml;scht alle Eintr&auml;ge aus der Liste, bis auf die
gebilligten Meldungen. Hierdurch k&ouml;nnen die Fehleranzeigen im Zeichenfenster
abgestellt werden. Der n&auml;chste ERC bzw. DRC erzeugt die Meldungen wieder, sofern
sie dann noch zutreffen.
<p>
Die Liste kann auch durch Eingabe des Befehls
<pre>
ERRORS CLEAR
</pre>
gel&ouml;scht werden.


<a name=52>
<h1>EXPORT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
ASCII- und Grafik-Dateien erzeugen.
<dt>
<b>Syntax</b>
<dd>
<tt>EXPORT SCRIPT    filename;</tt><br>
<tt>EXPORT NETLIST   filename;</tt><br>
<tt>EXPORT NETSCRIPT filename;</tt><br>
<tt>EXPORT PARTLIST  filename;</tt><br>
<tt>EXPORT PINLIST   filename;</tt><br>
<tt>EXPORT DIRECTORY filename;</tt><br>
<tt>EXPORT IMAGE     filename|CLIPBOARD [MONOCHROME|WINDOW] resolution;</tt>
</dl>
<b>Siehe auch</b> <a href=#96>SCRIPT</a>,
<a href=#95>RUN</a>
<p>
Der EXPORT-Befehl dient dazu, EAGLE-Daten in Form von Textdateien
(ASCII-Dateien) zur Verf&uuml;gung zu stellen oder Grafikdaten aus der
aktuellen Zeichnung zu erzeugen.
<p>
Standardm&auml;&szlig;ig wird die erzeugte Datei in das <b>Projekt</b>-Verzeichnis
geschrieben.
<p>
Der EXPORT-Befehl erzeugt folgende Textdateien:
<h2>SCRIPT</h2>
Die mit OPEN ge&ouml;ffnete Bibliothek
wird als Script-Datei ausgegeben. Damit besteht die M&ouml;glichkeit,
Bibliotheken mit einem Text-Editor zu bearbeiten und anschlie&szlig;end
wieder einzulesen.
<p>
Wenn mit EXPORT eine Bibliothek in eine Script-Datei verwandelt und
dieses anschlie&szlig;end wieder eingelesen wird, so sollte daf&uuml;r
eine NEUE (leere!) Bibliothek ge&ouml;ffnet werden, da es sonst vorkommen
kann, dass Objekte mehrfach definiert werden! Der Vorgang des Script-Einlesens
kann u. U. erheblich beschleunigt werden, wenn vorher
<pre>
Set Undo_Log Off;
</pre>
eingegeben wird (nicht vergessen, es nachher wieder einzuschalten,
da sonst kein Undo m&ouml;glich ist!).
<h2>NETLIST</h2>
Gibt eine Netzliste des geladenen Schaltplans oder der geladenen Platine
aus. Es werden nur Netze ber&uuml;cksichtigt, die mit Elementen verbunden
sind.
<h2>NETSCRIPT</h2>
Gibt die Netzliste des geladenen Schaltplans in Form einer Script-Datei
aus, das in eine Platine (mit bereits plazierten Elementen bzw. mit
durch <tt>DELETE SIGNALS</tt> gel&ouml;schten Signalen) eingelesen werden
kann.
Beachten Sie bitte, dass zum Einlesen des Scripts in die Platine kein
mit dieser Platine konsistenter Schaltplan geladen sein darf.
<h2>PARTLIST</h2>
Gibt eine Bauteile-Liste des Schaltplans oder der Platine aus. Es
werden nur Bauteile mit Pins/Pads ber&uuml;cksichtigt.
<h2>PINLIST</h2>
Gibt eine Liste mit den Pad- und Pin-Namen aller Bauteile aus, die zu
jedem Pin die Direction sowie den Namen des angeschlossenen Netzes enth&auml;lt.
<h2>DIRECTORY</h2>
Gibt das Inhaltsverzeichnis der gerade ge&ouml;ffneten Bibliothek aus.
<h2>IMAGE</h2>
Bei der Ausgabe eines <i>IMAGE</i> wird eine Grafikdatei mit der
angegebenen Datei-Erweiterung erzeugt. Folgende Formate sind verf&uuml;gbar:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>.bmp</tt></td>   <td width=20><td>Windows-Bitmap-Datei</td></tr>
<tr><td><tt>.png</tt></td>   <td width=20><td>Portable-Network-Graphics-Datei</td></tr>
<tr><td><tt>.pbm</tt></td>   <td width=20><td>Portable-Bitmap-Datei</td></tr>
<tr><td><tt>.pgm</tt></td>   <td width=20><td>Portable-Grayscale-Bitmap-Datei</td></tr>
<tr><td><tt>.ppm</tt></td>   <td width=20><td>Portable-Pixelmap-Datei</td></tr>
<tr><td><tt>.tif</tt></td>   <td width=20><td>TIFF-Datei</td></tr>
<tr><td><tt>.xbm</tt></td>   <td width=20><td>X-Bitmap-Datei</td></tr>
<tr><td><tt>.xpm</tt></td>   <td width=20><td>X-Pixmap-Datei</td></tr>
</table>
<p>
Der <i>resolution</i>-Parameter definiert die Bildaufl&ouml;sung (in 'dpi').
<p>
Ist <i>filename</i> der besondere Name CLIPBOARD (egal ob gro&szlig;- oder klein geschrieben),
wird das Bild in die Zwischenablage des Systems kopiert.
<p>
Das optionale Schl&uuml;sselwort <i>MONOCHROME</i> erzeugt ein schwarz/wei&szlig;es Bild.
<p>
Das optionale Schl&uuml;sselwort <i>WINDOW</i> erzeugt ein Bild des momentan im
Editor-Fenster sichtbaren Ausschnitts. Ohne dieses Schl&uuml;sselwort enth&auml;lt das
Bild die gesamte Zeichnung.
<h2>Weitere Formate</h2>
Eine Reihe von weiteren Formaten wie DXF oder Hyperlynx k&ouml;nnen mit Hilfe von ULPs exportiert werden.
Sie k&ouml;nnen von der Kommandozeile aus mit dem <a href=#95>RUN-Befehl</a> gestartet werden.
Unter 'Datei/Exportieren' sind einige dieser Export-Formate ebenso verf&uuml;gbar.


<a name=53>
<h1>FRAME</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Rahmen in eine Zeichnung einf&uuml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>FRAME [ columns [ rows ] ] [ borders ] &#149; &#149;</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.
</dl>
<b>Siehe auch</b> <a href=#62>LABEL</a>
<p>
Der FRAME-Befehl erzeugt einen Rahmen mit nummerierten Spalten und Zeilen.
Die beiden Punkte definieren zwei gegen&uuml;berliegende Ecken des Rahmens.
Mit der mittleren Maustaste k&ouml;nnen Sie den Layer w&auml;hlen, in den der
Rahmen gezeichnet wird.
<p>
Der <tt>columns</tt>-Parameter definiert die Zahl der Spalten des Rahmens.
Es k&ouml;nnen bis zu 127 Spalten verwendet werden. Standardm&auml;&szlig;ig werden die
Spalten von links nach rechts durchnummeriert. Falls der Wert f&uuml;r <tt>columns</tt>
negativ ist, l&auml;uft die Nummerierung von rechts nach links.
<p>
Der <tt>rows</tt>-Parameter definiert die Zahl der Zeilen des Rahmens.
Es k&ouml;nnen bis zu 26 Zeilen verwendet werden. Die Zeilen werden von oben nach
unten mit Buchstaben bezeichnet, beginnend mit 'A'. Falls der Wert f&uuml;r <tt>rows</tt>
negativ ist, l&auml;uft die Bezeichnung von unten nach oben. Wird <tt>rows</tt>
angegeben, so muss vorher auch <tt>columns</tt> angegeben werden.
<p>
Wird der <tt>borders</tt>-Parameter angegeben, so legt dieser fest auf welchen
Seiten des Rahmens ein Rand mit Zahlen bzw. Buchstaben angezeigt wird. G&uuml;ltige
Werte hierf&uuml;r sind <tt>Left</tt>, <tt>Top</tt>, <tt>Right</tt> und <tt>Bottom</tt>.
Standardm&auml;&szlig;ig wir der Rand an allen vier Seiten des Rahmens angezeigt. Sobald eine
dieser Optionen angegeben wird, wird der Rand nur an den gew&uuml;nschten Seiten
dargestellt. Die speziellen Werte <tt>None</tt> und <tt>All</tt> k&ouml;nnen benutzt
werden um an keiner bzw. allen Seiten einen Rand darzustellen.
<p>
Eine Zeichnung kann zwar mehrere Rahmen enthalten, f&uuml;r die Ermittlung der Positionen
von Bauteilen und Netzen wird aber immer nur der erste benutzt. Diese Positionen
k&ouml;nnen zum Beispiel in einem <a href=#144>User Language</a> Programm
verwendet werden um eine Liste aller Bauteile mit Ihren Positionen im jeweiligen
Rahmen auszugeben.
Sie werden auch benutzt zur automatischen Berechnung von Querverweisen
bei <a href=#62>Labels</a>.
<p>
Aufgrund der speziellen Bedeutung des Rahmens hat dieser keine eigene Rotation
und reagiert auch nicht auf den <a href=#93>ROTATE</a>-Befehl
<p>
Ein Rahmen kann direkt in eine Board- oder Schaltplanzeichnung eingef&uuml;gt werden.
Normalerweise werden Sie aber eher ein spezielles Symbol bzw. Package erzeugen,
welches eventuell auch noch ein Schriftfeld enth&auml;lt, und das Sie dann in allen
Ihren Zeichnungen verwenden k&ouml;nnen. Die mitgelieferte Bibliothek "frames" enth&auml;lt
bereits einige solcher Zeichnungsrahmen.
<h2>Beispiel</h2>
<pre>
FRAME 10 5 TOP LEFT &#149; &#149;
</pre>
erzeugt einen Rahmen mit 10 Spalten (nummeriert von links nach rechts) und
5 Zeilen (markiert von oben nach unten mit 'A' bis 'E'), bei dem die Spalten-
und Zeilenmarkierungen nur am oberen und linken Rand dargestellt werden.


<a name=54>
<h1>GATESWAP</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Auml;quivalente Gates vertauschen.
<dt>
<b>Syntax</b>
<dd>
<tt>GATESWAP &#149; &#149;..;</tt><br>
<tt>GATESWAP gate_name gate_name..;</tt>
</dl>
<b>Siehe auch</b> <a href=#30>ADD</a>
<p>
Mit diesem Befehl kann man Gates in einem Schaltplan vertauschen.
Dabei m&uuml;ssen die beiden Gates identisch sein (dieselben Pins haben)
und in der Device-Definition denselben Swaplevel (gr&ouml;&szlig;er
als 0) bekommen haben. Sind diese Bedingungen erf&uuml;llt, k&ouml;nnen
auch Gates aus unterschiedlichen Devices vertauscht werden.
<p>
Der als Parameter anzugebende Name ist der im Schaltplan sichtbare
Name (z. B. U1A f&uuml;r Gate A im Bauteil U1).
<p>
Wird ein Bauteil durch den GATESWAP-Befehl "unbenutzt", wird
es automatisch aus dem Schaltplan entfernt.


<a name=55>
<h1>GRID</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Rasterdarstellung und -einheit einstellen.
<dt>
<b>Syntax</b>
<dd>
<tt>GRID option..;</tt><br>
<tt>GRID;</tt>
<dt>
<b>Tastatur</b>
<dd>
<tt>F6: GRID;</tt>   schaltet das Raster ein bzw. aus.
</dl>
<b>Siehe auch</b> <a href=#96>SCRIPT</a>
<p>
Mit dem GRID-Befehl definiert man, ob und wie das Raster auf dem
Bildschirm dargestellt wird. Ausserdem legt dieser Befehl die
verwendete Rastereinheit fest.
<pre>
GRID;
</pre>
schaltet das Raster ein bzw. aus.
<p>
Objekte lassen sich nur auf dem eingestellten Raster
plazieren. F&uuml;r Platinen im Zollraster darf deshalb z. B. kein
mm-Raster verwendet werden.
<p>
Folgende options sind m&ouml;glich:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>GRID ON;</tt>        </td><td width=20><td>Raster darstellen</td></tr>
<tr><td><tt>GRID OFF;</tt>       </td><td width=20><td>Raster ausschalten</td></tr>
<tr><td><tt>GRID DOTS;</tt>      </td><td width=20><td>Raster als Punkte darstellen</td></tr>
<tr><td><tt>GRID LINES;</tt>     </td><td width=20><td>Raster als Linien darstellen</td></tr>
<tr><td><tt>GRID MIC;</tt>       </td><td width=20><td>Rastereinheit ist Mikrometer</td></tr>
<tr><td><tt>GRID MM;</tt>        </td><td width=20><td>Rastereinheit ist mm</td></tr>
<tr><td><tt>GRID MIL;</tt>       </td><td width=20><td>Rastereinheit ist Mil (0.001 Inch)</td></tr>
<tr><td><tt>GRID INCH;</tt>      </td><td width=20><td>Rastereinheit ist Inch (Zoll)</td></tr>
<tr><td><tt>GRID FINEST;</tt>    </td><td width=20><td>Raster auf kleinstm&ouml;glichen Wert einstellen</td></tr>
<tr><td><tt>GRID grid_size;</tt> </td><td width=20><td>Rasterabstand in der aktuellen Einheit</td></tr>
<tr><td><tt>GRID LAST;</tt>      </td><td width=20><td>Setzt die Grid-Parameter auf die zuletzt</td></tr>
<tr><td>                     </td><td width=20><td>eingestellten Werte</td></tr>
<tr><td><tt>GRID DEFAULT;</tt>   </td><td width=20><td>Einstellung auf Standardwerte</td></tr>
<tr><td><tt>GRID grid_size grid_multiple;</tt> </td><td width=20><td></td></tr>
<tr><td>                     </td><td width=20><td>grid_size = Rasterabstand</td></tr>
<tr><td>                     </td><td width=20><td>grid_multiple = Rasterfaktor</td></tr>
<tr><td><tt>GRID ALT ...;</tt>   </td><td width=20><td>Definiert das alternative Grid</td></tr>
</table>
<h2>Beispiele</h2>
<pre>
Grid mm;
Set Diameter_Menu 1.0 1.27 2.54 5.08;
Grid Last;
</pre>
In diesem Fall kann man zur zuletzt eingestellten Grid-Definition
zur&uuml;ckkehren, ohne sie zu kennen.
<pre>
GRID mm 1 10;
</pre>
gibt an, dass ein Rasterabstand von 1 mm eingestellt und jede
zehnte Rasterlinie angezeigt werden soll.
<p>
Beim GRID-Befehl sind auch mehrere Parameter zul&auml;ssig:
<pre>
GRID inch 0.05 mm;
</pre>
Der erste Zahlenwert im GRID-Befehl entspricht dem
Rasterabstand, der zweite (falls vorhanden) dem Rasterfaktor.
<p>
Hier wird das Raster zun&auml;chst auf 0.05 Zoll eingestellt, dann
wird die Koordinatenanzeige auf mm umgestellt.
Die Koordinaten werden in diesem Fall zwar in mm angezeigt,
trotzdem ist das Raster nach wie vor auf 1/20 Zoll eingestellt!
<pre>
GRID DEFAULT;
</pre>
Setzt das Raster auf den Standardwert f&uuml;r den aktuellen Zeichnungstyp.
<pre>
GRID mil 50 2 lines on alt mm 1 mil;
</pre>
Definiert ein 50 mil Raster das als Linien dargestellt wird (wobei nur jede zweite Linie sichtbar ist) und setzt das
alternative Raster auf eine Gr&ouml;&szlig;e von 1 mm, angezeigt in mil.
<p>
Ein Druck auf die <tt>Alt</tt>-Taste schaltet auf das alternative Grid um.
Dies kann typischerweise ein feineres Raster als das normale sein, wodurch es
zum Beispiel schnell und einfach m&ouml;glich ist etwas in einem dicht belegten Gebiet
fein zu positionieren, wof&uuml;r das normal Raster zu grob w&auml;re.
Das alternative Grid bleibt so lange aktiv, wie die <tt>Alt</tt>-Taste gedr&uuml;ckt
gehalten wird.
<h2>Parameter-Aliase</h2>
Parameter-Aliase k&ouml;nnen dazu benutzt werden, bestimmte Parameter-Einstellungen des GRID-Befehls
zu definieren, die sp&auml;ter unter einem gegebenen Namen angesprochen werden k&ouml;nnen.
Die Aliase k&ouml;nnen auch benutzt werden indem Sie auf den GRID-Button klicken
und die Maustaste gedr&uuml;ckt halten bis die Liste erscheint.
Ein Klick auf den Button mit der rechten Maustaste l&auml;&szlig;t die Liste ebenfalls erscheinen.
<p>
Die Syntax zur Bearbeitung dieser Aliase ist:
<dl>
<dt>
<tt>GRID = <i>name</i> <i>parameter</i></tt>
<dd>
Definiert den Alias <i>name</i>, der in die angegebenen <i>parameter</i>
expandiert wird. Der <i>name</i> darf aus beliebig vielen Buchstaben, Ziffern
und Unterstrichen bestehen, und Gro&szlig;-/Kleinschreibung spielt keine Rolle.
Er muss mit einem Buchstaben oder Unterstrich beginnen und darf keines der
Options-Schl&uuml;sselworte sein.
<dt>
<tt>GRID = <i>name</i> @</tt>
<dd>
Definiert den Alias <i>name</i>, der in die aktuelle Parameter-Einstellung
des Befehls expandiert wird.
<dt>
<tt>GRID = ?</tt>
<dd>
Erfragt vom Benutzer einen Namen zur Definition eines Aliases f&uuml;r
die aktuellen Grid-Parameter.
<dt>
<tt>GRID = <i>name</i></tt>
<dd>
&Ouml;ffnet den GRID-Dialog und erlaubt es dem Benutzer einen
Satz von Parametern einzustellen, der als Alias unter dem angegebenen
Namen gespeichert wird.
<dt>
<tt>GRID = <i>name</i>;</tt>
<dd>
L&ouml;scht den Alias mit dem angegebenen Namen.
<dt>
<tt>GRID <i>name</i></tt>
<dd>
Expandiert den Alias mit dem angegebenen Namen und f&uuml;hrt den GRID-Befehl
mit dem resultierenden Satz von Parametern aus. Der <i>name</i> kann
abgek&uuml;rzt werden und es d&uuml;rfen andere Parameter vor und nach dem
Alias angegeben werden (auch andere Aliase). Beachten Sie bitte,
dass im Falle einer abgek&uuml;rzten Eingabe Aliase Vorrang vor anderen Schl&uuml;sselw&ouml;rtern
des Befehls haben.
</dl>
Beispiel:
<p>
<tt>GRID = MyGrid inch 0.1 lines on</tt>
<p>
Definiert den Alias "MyGrid" der, wenn er wie in
<p>
<tt>GRID myg</tt>
<p>
benutzt wird, das aktuelle Grid auf die angegebenen Parameter einstellt.
Beachten Sie bitte die abgek&uuml;rzte Verwendung des Aliases,
und dass die Gro&szlig;-/Kleinschreibung keine Rolle spielt.


<a name=56>
<h1>GROUP</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definieren einer Gruppe.
<dt>
<b>Syntax</b>
<dd>
<tt>GROUP &#149;..</tt><br>
<tt>GROUP ALL</tt><br>
<tt>GROUP;</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Linke&amp;Ziehen</mb> definiert eine rechteckige Gruppe.<br>
<mb>Shift+Linke</mb> f&uuml;gt die neue Gruppe zu einer bestehenden hinzu.<br>
<mb>Ctrl+Linke</mb> invertiert die Gruppenzugeh&ouml;rigkeit des selektierten Objekts.<br>
<mb>Ctrl+Shift+Linke</mb> invertiert die Gruppenzugeh&ouml;rigkeit des in der Hierarchie n&auml;chsth&ouml;heren Objekts.<br>
<mb>Rechte</mb> schlie&szlig;t das Gruppen-Polygon.
</dl>
<b>Siehe auch</b> <a href=#37>CHANGE</a>,
<a href=#43>CUT</a>,
<a href=#78>PASTE</a>,
<a href=#68>MIRROR</a>,
<a href=#44>DELETE</a>
<p>
Mit dem GROUP-Befehl definiert man eine Gruppe von Objekten,
auf die man anschlie&szlig;end bestimmte Befehle anwenden kann. Nat&uuml;rlich
kann auch eine ganze Zeichnung als Gruppe definiert werden.
<p>
Die Objekte selektiert man, indem man nach Aktivieren des
GROUP-Befehls mit der Maus ein Rechteck aufzieht oder ein Polygon zeichnet, das mit dem Bet&auml;tigen
der rechten Maustaste geschlossen wird. In die Gruppe werden nur
Objekte aus den sichtbaren Layern &uuml;bernommen.
<p>
Das Schl&uuml;sselwort <tt>ALL</tt> kann dazu benutzt werden eine Gruppe zu
definieren, die die gesamte Zeichnungsfl&auml;che einschlie&szlig;t.
<p>
Zur Gruppe geh&ouml;ren:
<ul>
<li>alle Objekte mit einem Aufh&auml;ngepunkt, deren Aufh&auml;ngepunkt innerhalb des Polygons liegt;
<li>alle Objekte mit zwei Aufh&auml;ngepunkten, von denen mindestens ein Endpunkt innerhalb des Polygons liegt;
<li>alle Kreise, deren Mittelpunkt innerhalb des Polygons liegt;
<li>alle Rechtecke, von denen mindestens ein Eckpunkt innerhalb des Polygons liegt.
</ul>
<h2>Gruppe bewegen</h2>
Um eine Gruppe zu bewegen, verwendet man den MOVE-Befehl mit der
rechten Maustaste. Bewegt werden alle Objekte, die vorher
mit dem GROUP-Befehl selektiert worden sind. Wires, von denen nur ein
Eckpunkt innerhalb des Polygons liegt, werden an diesem Ende bewegt,
w&auml;hrend das andere fest bleibt. "H&auml;ngt" die Gruppe am Mauszeiger, l&auml;sst sie
sich wiederum mit der rechten Maustaste rotieren.
<p>
Die Gruppendefinition bleibt wirksam, bis eine neue Zeichnung geladen
wird oder bis der Befehl
<pre>
GROUP;
</pre>
ausgef&uuml;hrt wird.
<h2>Gruppe erweitern</h2>
Wenn Sie bei einem beliebigen Mausklick zur Definition einer Gruppe die <tt>Shift</tt>-Taste
dr&uuml;cken, so wird die neu definierte Gruppe zur bereits vorhandenen hinzugef&uuml;gt
(falls es bereits eine gibt).
<h2>Einzelne Objekte</h2>
Durch Anklicken eines einzelnen Objekts bei gedr&uuml;ckter <tt>Ctrl</tt>-Taste ist es
m&ouml;glich, die Gruppenzugeh&ouml;rigkeit dieses Objekts zu invertieren. Wird dabei zus&auml;tzlich
auch noch die <tt>Shift</tt>-Taste gedr&uuml;ckt, so wird die Gruppenzugeh&ouml;rigkeit
des in der Hierarchie n&auml;chsth&ouml;heren Objekts invertiert. Klicken Sie beispielsweise
mit dem GROUP-Befehl bei gedr&uuml;ckter <tt>Ctrl</tt>- und <tt>Shift</tt>-Taste im
Schaltpan auf eine Netz-Linie, so wird die Gruppenzugeh&ouml;rigkeit des gesamten Segments
invertiert.


<a name=57>
<h1>HELP</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Hilfe-Seite anzeigen.
<dt>
<b>Syntax</b>
<dd>
<tt>HELP</tt><br>
<tt>HELP command</tt>
<dt>
<b>Tastatur</b>
<dd>
<tt>F1: HELP</tt>   ruft die kontextsensitive Hilfe-Funktion auf.
</dl>
Dieser Befehl ruft ein Hilfe-Fenster mit Hinweisen zum Programm auf,
die vom momentanen Status abh&auml;ngig sind (kontextsensitiv).
<p>
Wird im HELP-Befehl ein Befehlsname (<tt>command</tt>) angegeben, dann erh&auml;lt
man die Beschreibung dieses Befehls.
<h2>Beispiel</h2>
<pre>
HELP GRID;
</pre>
Es erscheint die Beschreibung des GRID-Befehls.


<a name=58>
<h1>HOLE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Bohrloch in Platine oder Package einf&uuml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>HOLE drill &#149;..</tt>
</dl>
<b>Siehe auch</b> <a href=#110>VIA</a>,
<a href=#77>PAD</a>,
<a href=#37>CHANGE</a>
<p>
Mit diesem Befehl definiert man Bohrungen ohne Durchkontaktierung
in Platinen oder Packages. Der Parameter drill gibt den Bohrdurchmesser
in der aktuellen Einheit an. Er darf maximal 200 mm (ca. 7.7840 Zoll)
betragen.
<h2>Beispiel</h2>
<pre>
HOLE 0.20 &#149;
</pre>
Falls die eingestellte Ma&szlig;einheit "Inch" ist, hat das
Hole einen Durchmesser von 0.20 Zoll.
<p>
Der eingegebene Bohrdurchmesser (gilt auch f&uuml;r Pads und Vias)
bleibt f&uuml;r nachfolgende Operationen erhalten. Er kann mit dem
Befehl
<pre>
CHANGE DRILL value &#149;
</pre>
ver&auml;ndert werden.
<p>
Ein Hole kann nur selektiert werden, wenn der Holes-Layer
eingeblendet ist (DISPLAY).
<p>
Eine Bohrung (Hole) erzeugt das zugeh&ouml;rige Bohrsymbol im Layer Holes
und einen Kreis mit dem entsprechenden Durchmesser im Layer Dimension.
Die Zuordnung von Symbolen zu bestimmten Bohrdurchmessern kann im
"Optionen/Einstellungen/Bohrsymbole" Dialog ge&auml;ndert werden. Der Kreis im Dimension-Layer ist
besonders f&uuml;r den Autorouter wichtig, der den eingestellten
Mindestabstand zwischen Vias/Wires und Dimension-Linien damit auch zum
Bohrloch einh&auml;lt.
<p>
In den Layern tStop und bStop erzeugen Holes die L&ouml;tstopmaske, deren
Durchmesser sich aus den <a href=#139>Design Rules</a> ergibt.


<a name=59>
<h1>INFO</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Eigenschaften von Objekten anzeigen und ver&auml;ndern.
<dt>
<b>Syntax</b>
<dd>
<tt>INFO &#149;..</tt><br>
<tt>INFO name ..</tt>
</dl>
<b>Siehe auch</b> <a href=#37>CHANGE</a>,
<a href=#98>SHOW</a>
<p>
Der INFO-Befehl gibt zu einem Objekt umfassende Informationen, z.B. Wire-Breite, Layer und so weiter.
In diesem Dialog k&ouml;nnen die Objekt-Eigenschaften auch ver&auml;ndert werden.
<p>
Bauteile, Pads, Smds, Pins und Gatter lassen sich
auch mit ihrem Namen selektieren. Das ist vor allem dann n&uuml;tzlich,
wenn sich das Objekt ausserhalb des gerade dargestellten Bildausschnitts
befindet. Beim Selektieren eines aus mehreren Gattern bestehenden Bauteils
im Schaltplan muss der volle, aus dem Bauteil- und dem jeweiligen Gatternamen
bestehende Name angegeben werden.
<p>
Attribute von Bauteilen k&ouml;nnen dadurch selektiert werden, dass die Kombination
aus Bauteilname und Attributname angegeben wird, wie etwa <tt>R5&gt;VALUE</tt>.
<p>
Die Koordinaten eines rotierten Rechtecks sind nicht ver&auml;nderbar.


<a name=60>
<h1>INVOKE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Bestimmte Gates von Bauteilen holen.
<dt>
<b>Syntax</b>
<dd>
<tt>INVOKE &#149; orientation &#149;</tt><br>
<tt>INVOKE Part_Name Gate_Name orientation &#149;</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> spiegelt das Gate.<br>
<mb>Rechte</mb> dreht das Gate.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#42>COPY</a>,
<a href=#30>ADD</a>
<p>
Addlevel und Orientation siehe ADD-Befehl.
<p>
Will man gezielt ein bestimmtes Gate eines Bauelements in den Schaltplan
holen (z.B. ein Power-Gate mit Addlevel Request), dann
benutzt man den INVOKE-Befehl.
<p>
Ein Gate kann man aktivieren, indem man
<ul>
<li>den Namen eines Bauelements angibt (etwa INVOKE IC5) und das gew&uuml;nschte Gate aus einem Popup-Men&uuml; ausw&auml;hlt,
<li>den Elementnamen und den Gate-Namen angibt (etwa INVOKE IC5 POWER),
<li>das vorhandene Gate mit der Maus anklickt und das gew&uuml;nschte Gate aus einem Popup-Men&uuml; ausw&auml;hlt.
</ul>
Mit dem abschlie&szlig;enden Mausklick positioniert man das neue Gate.
<p>
Wird im Dialog ein bereits aktiviertes Gate selektiert, so wechselt der Default-Button
zu "Anzeigen" und ein Klick darauf zoomt das Editor-Fenster auf das selektierte Gate,
wobei wenn n&ouml;tig auch auf die entsprechende Seite gewechselt wird.
<h2>Gates auf verschiedenen Seiten</h2>
Soll ein Gate aus einem Bauelement geholt werden, das sich auf einer
anderen Seite des Schaltplans befindet, ist als Parameter der Name
des Bauelements anzugeben. In diesem Fall zeigt die rechte Spalte
des Popup-Men&uuml;s, auf welchen Seiten sich die verwendeten Gates
befinden.


<a name=61>
<h1>JUNCTION</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Markierungspunkt f&uuml;r zusammengeh&ouml;rige Netze setzen.
<dt>
<b>Syntax</b>
<dd>
<tt>JUNCTION &#149;..</tt>
</dl>
<b>Siehe auch</b> <a href=#73>NET</a>
<p>
L&ouml;schen von Junctions, siehe DELETE-Befehl.
<p>
Mit diesem Befehl lassen sich die Kreuzungspunkte zusammengeh&ouml;riger
Netze mit einem Punkt markieren. Ein Junction-Punkt l&auml;sst sich
nur auf einem Netz plazieren. Wird ein Junction-Punkt an einer Stelle
gesetzt, an der sich unterschiedliche Netze kreuzen, dann wird der
Benutzer gefragt, ob er die Netze verbinden will.
<p>
Wird eine Netzlinie auf einem Punkt abgesetzt auf dem schon mindestens zwei
weitere Netzlinien und/oder Pins liegen, wird automatisch ein Verbindungspunkt
(Junction) gesetzt. Diese Funktion kann &uuml;ber "<tt>SET AUTO_JUNCTION OFF;</tt>" oder
durch Deselektieren des Punkts "Junctions automatisch setzen" im Men&uuml; "Optionen/Einstellungen/Verschiedenes" abgeschaltet
werden.
<p>
Auf dem Bildschirm werden Junctions immer mit mindestens f&uuml;nf
Pixel Durchmesser dargestellt, damit sie auch in kleinen Zoom-Stufen
noch sichtbar sind.


<a name=62>
<h1>LABEL</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Busse und Netze beschriften.
<dt>
<b>Syntax</b>
<dd>
<tt>LABEL [XREF] [orientation] &#149; &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.<br>
<mb>Rechte</mb> dreht das Label.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#72>NAME</a>,
<a href=#36>BUS</a>
<p>
Mit diesem Befehl kann man den Namen eines Busses oder Netzes im Schaltplan an eine beliebige Stelle plazieren. Der erste Mausklick sorgt daf&uuml;r,
dass der Name des selektierten Busses oder Netzes "am Mauszeiger
h&auml;ngenbleibt". Der Text kann dann mit der rechten Maustaste
rotiert werden. Mit der mittleren Maustaste w&auml;hlt man den Ziel-Layer
f&uuml;r den Label-Text aus. Der zweite Mausklick mit der linken Maustaste
plaziert den Text an eine beliebige Stelle.
<p>
Als Option kann die Schreibrichtung (orientation)
auch textuell angegeben werden. Das ist vor allem f&uuml;r Script-Dateien
sinnvoll. Die entsprechenden Schl&uuml;sselw&ouml;rter sind im <a href=#30>ADD</a>-Befehl
aufgef&uuml;hrt (R0, R90 usw.).
<p>
Es k&ouml;nnen beliebig viele Labels je Bus/Signal plaziert werden.
<p>
Label-Texte lassen sich nicht mit CHANGE TEXT &auml;ndern.
<p>
Labels werden vom Programm wie Texte behandelt, aber ihr "Wert"
entspricht immer dem Namen des zugeh&ouml;rigen Busses oder Netzes.
&Auml;ndert man den Namen eines Busses/Netzes mit dem NAME-Befehl,
dann &auml;ndern sich automatisch alle zugeh&ouml;rigen Labels.
<p>
Selektiert man beim SHOW-Befehl einen Bus, ein Netz oder ein Label,
dann werden alle zugeh&ouml;rigen Busse, Netze bzw. Labels hell dargestellt.
<h2>Querverweis-Labels</h2>
Wird das optionale Schl&uuml;sselwort <tt>XREF</tt> angegeben, so wird das Label
ein "Querverweis-Label". Querverweis-Labels k&ouml;nnen in Schaltpl&auml;nen mit
mehreren Seiten benutzt werden, um anzuzeigen welches die n&auml;chste Seite ist,
auf der ein bestimmtes Netz vorkommt (bitte beachten Sie, dass dies nur f&uuml;r
Netze gilt, nicht f&uuml;r Busse!).
Das <tt>XREF</tt>-Schl&uuml;sselwort ist haupts&auml;chlich f&uuml;r die Verwendung in Scripts
gedacht. Normalerweise richtet sich diese Einstellung danach, was vorher mit
<a href=#37>CHANGE XREF</a> bzw. durch Anklicken der Xref-Schaltfl&auml;che
in der Parameter-Toolbar gew&auml;hlt wurde.
<p>
Das Format, in welchem ein Querverweis-Label angezeigt wird, kann &uuml;ber die
"Format f&uuml;r Querverweis-Labels" Zeichenfolge im Dialog "Optionen/Einstellungen/Verschiedenes"
oder &uuml;ber den <a href=#97>SET</a> Befehl festgelegt werden.
Folgende Platzhalter sind definiert und k&ouml;nnen in beliebiger Reihenfolge verwendet werden:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%F</tt></td>  <td width=20><td>aktiviert das Zeichnen eines Rahmens um das Label</td></tr>
<tr><td><tt>%N</tt></td>  <td width=20><td>der Name des Netzes</td></tr>
<tr><td><tt>%S</tt></td>  <td width=20><td>die n&auml;chste Seitennummer</td></tr>
<tr><td><tt>%C</tt></td>  <td width=20><td>die Spalte auf der n&auml;chsten Seite</td></tr>
<tr><td><tt>%R</tt></td>  <td width=20><td>die Zeile auf der n&auml;chsten Seite</td></tr>
</table>
<p>
Das Standard-Format ist <tt>"%F%N/%S.%C%R"</tt>. Neben den definierten Platzhaltern
k&ouml;nnen Sie auch beliebige andere ASCII-Zeichen verwenden.
<p>
Die Werte f&uuml;r Spalte und Zeile sind nur verf&uuml;gbar, wenn auf der n&auml;chsten Seite,
auf der das Netz vorkommt, ein <a href=#53>Zeichnungsrahmen</a>
platziert wurde. Wird <tt>%C</tt> oder <tt>%R</tt> benutzt und es befindet sich
kein Rahmen auf der Seite, zeigen sie ein Fragezeichen (<tt>'?'</tt>) an.
<p>
Bei der Ermittlung der Spalte und Zeile eines Netzes auf einer Schaltplanseite
wird zun&auml;chst die Spalte und dann die Zeile innerhalb dieser Spalte betrachtet.
Hierbei haben XREF-Labels Vorrang vor normalen Labels, und diese wiederum Vorrang
vor Netz-Wires.
F&uuml;r h&ouml;here Seitennummern werden die Rahmen-Koordinaten des am weitesten links oben
liegenden Feldes genommen, w&auml;hrend f&uuml;r niedrigere Nummern die des am weitesten
rechts unten liegenden Feldes genommen werden.
<p>
Die Orientierung eines Querverweis-Labels bestimmt ob es auf eine "h&ouml;here" oder
"niedrigere" Seitennummer verweist. Labels mit einer Orientierung von R0 oder R270
zeigen zum rechten bzw. unteren Rand der Zeichnung und beziehen sich daher auf
eine h&ouml;here Seitennummer. Entsprechend verweisen Labels mit einer Orientierung
von R90 oder R180 auf eine niedrigere Seitennummer. Hat ein Label eine Orientierung
von R0 oder R270, aber das Netz, an dem es h&auml;ngt, kommt auf keiner h&ouml;heren Seite
vor, so wird stattdessen ein Verweis auf die n&auml;chst niedrigere Seite angezeigt
(entsprechendes gilt f&uuml;r R90 und R180).
Kommt das Netz ausschlie&szlig;lich auf der aktuellen Seite vor, so wird keinerlei
Querverweis angezeigt, sondern nur der Netzname (mit Rahmen, falls das Format
den <tt>%F</tt> Platzhalter enth&auml;lt).
<p>
Ein Querverweis-Label, welches auf das Ende eines Netz-Wires platziert wird,
verbindet sich mit dem Wire, so dass sich der Wire mit dem Label mitbewegt
und umgekehrt.
<p>
Das Format f&uuml;r Querverweis-Labels wird in der Schaltplan-Zeichnung gespeichert.
<p>
Ein Querverweis-Label kann entweder mit dem <a href=#37>CHANGE</a>-Befehl
oder &uuml;ber seinen <i>Eigenschaften</i>-Dialog in ein normales Label verwandelt werden.
<h2>Layer ausw&auml;hlen</h2>
Im Gegensatz zu anderen Befehlen (wie etwa WIRE) merkt sich der LABEL-Befehl
den zuletzt verwendeten Layer selbst. Das hat den Vorteil, dass Labels immer
im richtigen Layer landen, egal welche Layer andere Befehle verwenden. Der
Nachteil ist, dass die &uuml;bliche Vorgehensweise, den Layer in einem Script auszuw&auml;hlen,
wie etwa
<pre>
LAYER <i>Layer</i>;
WIRE (1 2) (3 4);
</pre>
hier nicht funktioniert. Der Layer muss gew&auml;hlt werden, wenn der LABEL-Befehl
bereits aktiv ist. Dies kann folgenderma&szlig;en geschehen:
<pre>
LABEL <i>Parameter</i>
LAYER <i>Layer</i>
<i>weitere Parameter</i>;
</pre>
Beachten Sie, dass die LABEL-Zeile <b>nicht</b> mit einem <tt>';'</tt>
abgeschlossen ist, und dass der LAYER-Befehl in einer neuen Zeile beginnt.<br>
Die Befehle
<pre>
LABEL
LAYER <i>Layer</i>;
</pre>
setzen den Layer f&uuml;r nachfolgende LABEL-Befehle.


<a name=63>
<h1>LAYER</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Wechseln und Definieren von Layern.
<dt>
<b>Syntax</b>
<dd>
<tt>LAYER layer_number</tt><br>
<tt>LAYER layer_name</tt><br>
<tt>LAYER layer_number layer_name</tt><br>
<tt>LAYER [??] -layer_number</tt>
</dl>
<b>Siehe auch</b> <a href=#47>DISPLAY</a>
<h2>Zeichenebene ausw&auml;hlen</h2>
Der LAYER-Befehl mit einem Parameter dient dazu, den (vorhandenen)
Layer auszuw&auml;hlen, in den gezeichnet werden soll. Wird der Befehl
aus dem Men&uuml; ausgew&auml;hlt, &ouml;ffnet sich ein Popup-Men&uuml;,
in dem man den gew&uuml;nschten Layer selektieren kann. Bei Eingabe
&uuml;ber die Tastatur ist als Parameter die Layer-Nummer oder der
Layer-Name (wie er im Popup-Men&uuml; erscheint) zul&auml;ssig.
<p>
Der ROUTE-Befehl &auml;ndert den aktiven Layer automatisch.
<p>
Bestimmte Layer stehen nicht in allen Betriebsarten zur Verf&uuml;gung,
da sie nicht &uuml;berall einen Sinn haben.
<p>
Bitte beachten Sie, dass von den Signal-Layern (1 bis 16) nur diejenigen
zur Verf&uuml;gung stehen, die im Layer-Setup in den <a href=#139>Design Rules</a>
eingetragen sind.
<h2>Layer definieren</h2>
Der LAYER-Befehl mit zwei Parametern dient dazu, einen neuen Layer
zu definieren oder einen vorhandenen umzubenennen.
Die Eingabe von z.B.:
<pre>
LAYER 101 BEISPIEL;
</pre>
erzeugt einen neuen Layer mit der Nummer 101 und dem Namen BEISPIEL.
<p>
Werden in einer Zeichnung Bibliothekselemente plaziert (mit ADD oder
REPLACE), die zus&auml;tzliche Layer enthalten, dann werden diese Layer
automatisch in der Zeichnung angelegt.
<p>
Die vordefinierten Layer haben spezielle Bedeutung. Man kann zwar
ihren Namen &auml;ndern, aber ihre besondere Funktion bleibt aufgrund
ihrer Nummer erhalten.
<p>
Wenn Sie eigene Layer definieren, sollten Sie nur die
Layer-Nummern ab 100 verwenden. Bei kleineren Nummern kann es sein,
dass Sie in sp&auml;teren EAGLE-Versionen spezielle Bedeutung bekommen.
<h2>Layer l&ouml;schen</h2>
Der LAYER-Befehl mit dem der Layer-Nummer vorangestellten Minuszeichen
l&ouml;scht den Layer mit dieser Nummer, z. B.:
<pre>
LAYER -103;
</pre>
l&ouml;scht den Layer mit der Nummer 103. Voraussetzung ist, dass
der Layer leer ist. Ist das nicht der Fall, wird die Fehlermeldung
<p>
   "layer is not empty: #"
<p>
ausgegeben, wobei # die Layer-Nummer repr&auml;sentiert.
Falls Sie jegliche Fehlermeldungen beim L&ouml;schen eines Layers
vermeiden wollen, so k&ouml;nnen Sie die Option '??' angeben. Das kann
in Scripts n&uuml;tzlich sein, die bestimmte Layer zu l&ouml;schen versuchen,
wo es aber keinen Fehler darstellt wenn ein Layer nicht leer oder
&uuml;berhaupt nicht vorhanden ist.
<h2>Vordefinierte EAGLE-Layer, nach Layer-Nummern geordnet</h2>
<h3>Layout</h3>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>1   Top       </td><td width=20><td>Leiterbahnen oben</td></tr>
<tr><td>2   Route2    </td><td width=20><td>Innenlage</td></tr>
<tr><td>3   Route3    </td><td width=20><td>Innenlage</td></tr>
<tr><td>4   Route4    </td><td width=20><td>Innenlage</td></tr>
<tr><td>5   Route5    </td><td width=20><td>Innenlage</td></tr>
<tr><td>6   Route6    </td><td width=20><td>Innenlage</td></tr>
<tr><td>7   Route7    </td><td width=20><td>Innenlage</td></tr>
<tr><td>8   Route8    </td><td width=20><td>Innenlage</td></tr>
<tr><td>9   Route9    </td><td width=20><td>Innenlage</td></tr>
<tr><td>10  Route10   </td><td width=20><td>Innenlage</td></tr>
<tr><td>11  Route11   </td><td width=20><td>Innenlage</td></tr>
<tr><td>12  Route12   </td><td width=20><td>Innenlage</td></tr>
<tr><td>13  Route13   </td><td width=20><td>Innenlage</td></tr>
<tr><td>14  Route14   </td><td width=20><td>Innenlage</td></tr>
<tr><td>15  Route15   </td><td width=20><td>Innenlage</td></tr>
<tr><td>16  Bottom    </td><td width=20><td>Leiterbahnen unten</td></tr>
<tr><td>17  Pads      </td><td width=20><td>Pads (bedrahtete Bauteile)</td></tr>
<tr><td>18  Vias      </td><td width=20><td>Vias (durchgehend)</td></tr>
<tr><td>19  Unrouted  </td><td width=20><td>Luftlinien</td></tr>
<tr><td>20  Dimension </td><td width=20><td>Platinen-Umrisse (und Kreise f&uuml;r Holes)</td></tr>
<tr><td>21  tPlace    </td><td width=20><td>Best&uuml;ckungsdruck oben</td></tr>
<tr><td>22  bPlace    </td><td width=20><td>Best&uuml;ckungsdruck unten</td></tr>
<tr><td>23  tOrigins  </td><td width=20><td>Aufh&auml;ngepunkte oben (Kreuz automatisch generiert)</td></tr>
<tr><td>24  bOrigins  </td><td width=20><td>Aufh&auml;ngepunkte unten (Kreuz automatisch generiert)</td></tr>
<tr><td>25  tNames    </td><td width=20><td>Servicedruck oben (Bauteile-Namen, NAME)</td></tr>
<tr><td>26  bNames    </td><td width=20><td>Servicedruck unten (Bauteile-Namen, NAME)</td></tr>
<tr><td>27  tValues   </td><td width=20><td>Bauteile-Werte oben (VALUE)</td></tr>
<tr><td>28  bValues   </td><td width=20><td>Bauteile-Werte unten (VALUE)</td></tr>
<tr><td>29  tStop     </td><td width=20><td>L&ouml;tstopmaske oben  (automatisch generiert)</td></tr>
<tr><td>30  bStop     </td><td width=20><td>L&ouml;tstopmaske unten   (automatisch generiert)</td></tr>
<tr><td>31  tCream    </td><td width=20><td>Lotpaste oben</td></tr>
<tr><td>32  bCream    </td><td width=20><td>Lotpaste unten</td></tr>
<tr><td>33  tFinish   </td><td width=20><td>Veredelung oben</td></tr>
<tr><td>34  bFinish   </td><td width=20><td>Veredelung unten</td></tr>
<tr><td>35  tGlue     </td><td width=20><td>Klebemaske oben</td></tr>
<tr><td>36  bGlue     </td><td width=20><td>Klebemaske unten</td></tr>
<tr><td>37  tTest     </td><td width=20><td>Test- und Abgleichinformationen oben</td></tr>
<tr><td>38  bTest     </td><td width=20><td>Test- und Abgleichinformationen unten</td></tr>
<tr><td>39  tKeepout  </td><td width=20><td>Sperrfl&auml;chen f&uuml;r Bauteile oben</td></tr>
<tr><td>40  bKeepout  </td><td width=20><td>Sperrfl&auml;chen f&uuml;r Bauteile unten</td></tr>
<tr><td>41  tRestrict </td><td width=20><td>Sperrfl&auml;chen f&uuml;r Leiterbahnen oben</td></tr>
<tr><td>42  bRestrict </td><td width=20><td>Sperrfl&auml;chen f&uuml;r Leiterbahnen unten</td></tr>
<tr><td>43  vRestrict </td><td width=20><td>Sperrfl&auml;chen f&uuml;r Vias</td></tr>
<tr><td>44  Drills    </td><td width=20><td>Bohrungen, durchkontaktiert</td></tr>
<tr><td>45  Holes     </td><td width=20><td>Bohrungen, nicht durchkontaktiert</td></tr>
<tr><td>46  Milling   </td><td width=20><td>CNC-Fr&auml;ser-Daten (geschlitzte Pads)</td></tr>
<tr><td>47  Measures  </td><td width=20><td>Bema&szlig;ungen</td></tr>
<tr><td>48  Document  </td><td width=20><td>allgemeine Dokumentation</td></tr>
<tr><td>49  Reference </td><td width=20><td>Passermarken</td></tr>
<tr><td>51  tDocu     </td><td width=20><td>Bauteiledokumentation oben</td></tr>
<tr><td>52  bDocu     </td><td width=20><td>Bauteiledokumentation unten</td></tr>
</table>
<h3>Schaltplan</h3>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>91  Nets      </td><td width=20><td>Netze</td></tr>
<tr><td>92  Busses    </td><td width=20><td>Busse</td></tr>
<tr><td>93  Pins      </td><td width=20><td>Anschlusspunkte f&uuml;r Schaltplansymbole</td></tr>
<tr><td>              </td><td width=20><td>mit Zusatzinformationen</td></tr>
<tr><td>94  Symbols   </td><td width=20><td>Umrisse der Schaltplansymbole</td></tr>
<tr><td>95  Names     </td><td width=20><td>Namen bei Schaltplansymbolen</td></tr>
<tr><td>96  Values    </td><td width=20><td>Werte/Typenbezeichnung bei Schaltplansymbolen</td></tr>
<tr><td>97  Info      </td><td width=20><td>Allgemeine Informationen</td></tr>
<tr><td>98  Guide     </td><td width=20><td>Hilfslinien</td></tr>
</table>
<p>
Layer k&ouml;nnen immer mit ihrem Namen oder Nummer angegeben werden.


<a name=64>
<h1>LOCK</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Verriegelt die Position und Orientierung eines Bauteils im Board.
<dt>
<b>Syntax</b>
<dd>
<tt>LOCK &#149;..</tt><br>
<tt>LOCK name ..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Rechte</mb> wirkt auf die Gruppe.<br>
<mb>Shift+Linke</mb> macht die Verriegelung wieder r&uuml;ckg&auml;ngig ("entriegelt" das Bauteil).<br>
<mb>Ctrl+Shift+Rechte</mb> "entriegelt" alle Bauteile in der Gruppe.
</dl>
<b>Siehe auch</b> <a href=#71>MIRROR</a>,
<a href=#71>MOVE</a>,
<a href=#93>ROTATE</a>
<a href=#100>SMASH</a>
<p>
Der LOCK-Befehl kann auf Bauteile in einem Board angewendet werden
und verhindert, dass diese bewegt, gedreht oder gespiegelt werden k&ouml;nnen.
Dies ist n&uuml;tzlich f&uuml;r Dinge wie Steckerleisten, die an einer genau festgelegten
Stelle montiert werden m&uuml;ssen und nicht unbeabsichtigt verschoben werden
d&uuml;rfen.
<p>
Der Aufh&auml;ngepunkt eines verriegelten Bauteils wird als 'x' dargestellt,
um anzuzeigen, dass das Bauteil verriegelt ist.
<p>
Wird eine Gruppe bewegt, die verriegelte Bauteile enth&auml;lt, so bewegen
sich diese Bauteile (sowie die an ihren Pads endenden Wires) nicht mit der
Gruppe mit.
<p>
Losgel&ouml;ste Texte eines verriegelten Bauteils k&ouml;nnen weiterhin einzeln
bewegt werden, bewegen sich aber nicht als Teil einer Gruppe mit.
<p>
Bauteile lassen sich
auch mit ihrem Namen selektieren. Das ist vor allem dann n&uuml;tzlich,
wenn sich das Objekt ausserhalb des gerade dargestellten Bildausschnitts
befindet.
<p>
Ein "verriegeltes" Bauteil kann "entriegelt" werden, indem es bei gedr&uuml;ckter
<tt>Shift</tt>-Taste (und nat&uuml;rlich aktiviertem LOCK-Befehl) angeklickt wird.


<a name=65>
<h1>MARK</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Marke in der Zeichenfl&auml;che definieren.
<dt>
<b>Syntax</b>
<dd>
<tt>MARK &#149;</tt><br>
<tt>MARK;</tt>
</dl>
<b>Siehe auch</b> <a href=#55>GRID</a>
<p>
Mit dem MARK-Befehl definiert man einen Punkt in der Zeichenfl&auml;che,
der als Bezugspunkt zum Ausmessen von Strecken dienen kann. Die
Koordinaten relativ zu diesem Punkt werden in der gegenw&auml;rtig
eingestellten Einheit (GRID) links oben auf dem Bildschirm mit
vorangestelltem 'R' angezeigt. Der Bezugspunkt wird als wei&szlig;es
Kreuz dargestellt. Um genau messen zu k&ouml;nnen, sollten Sie vorher ein
Raster einstellen das fein genug ist.
<p>
Die Eingabe 'MARK;' schaltet die Marke ein oder aus.


<a name=66>
<h1>MEANDER</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Gleicht L&auml;ngenunterschiede zwischen Differential Pairs aus und verl&auml;ngert Signal-Segmente.
<dt>
<b>Syntax</b>
<dd>
<tt>MEANDER [length] &#149; ..</tt><br>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Linke</mb> misst die L&auml;nge des selektierten Signal-Segments.<br>
<mb>Ctrl+Shift+Linke</mb> misst die maximale L&auml;nge der selektierten Signal-Segmente.<br>
<mb>Rechte</mb> schaltet um zwischen symmetrischen und asymmetrischen M&auml;andern.
</dl>
<b>Siehe auch</b> <a href=#94>ROUTE</a>
<p>
Der MEANDER-Befehl dient zum Ausgleichen der L&auml;nge von Signalen eines Differential
Pairs.
Hierf&uuml;r klicken Sie auf einen Wire eines Differential Pairs und bewegen den Mauszeiger
weg vom Anklickpunkt. Wenn die beiden Signale unterschiedlich lang sind und der
Anklickpunkt und die aktuelle Mausposition gen&uuml;gend weit voneinander entfernt sind,
wird eine Sequenz von Wires in Form eines "M&auml;anders" gezeichnet, welche die L&auml;nge
des k&uuml;rzeren Signal-Segments erh&ouml;ht.
Eine Anzeige am Mauszeiger zeigt die Ziel-L&auml;nge an (das ist die L&auml;nge des l&auml;ngeren
Signal-Segments), sowie die Abweichung (in Prozent) der beiden Signale vom Ziel-Wert.
<p>
Der M&auml;ander beginnt am ersten Anklickpunkt und erstreckt sich bis zum zweiten
Punkt, an den der Mauszeiger bewegt wird. Die maximale Breite des M&auml;anders wird
durch den Abstand des Mauszeigers von dem selektierten Wire bestimmt.
<p>
Falls ein einzelner M&auml;ander nicht ausreicht, um die L&auml;ngen auszugleichen, k&ouml;nnen Sie
weitere M&auml;ander an anderen Stellen einf&uuml;gen.
<p>
Zu jeder Zeit k&ouml;nnen Sie in der Kommandozeile einen Wert <tt>length</tt> f&uuml;r die
Ziel-L&auml;nge eingeben. Das ist f&uuml;r alle Signale, nicht nur f&uuml;r Differential Pairs, anwendbar.
<p>
Beim M&auml;andrieren eines Differential Pairs mit vorgegebenem Ziel-Wert wird zuerst
versucht, den L&auml;ngenunterschied der beiden Signal-Segmente des Differential Pairs
auszugleichen, und anschlie&szlig;end die Gesamtl&auml;nge beider Segmente auf den gegebenen
Wert zu erh&ouml;hen.
<p>
Um die Ziel-Vorgabe zur&uuml;ckzusetzen k&ouml;nnen Sie entweder den MEANDER-Befehl neu starten,
oder in der Kommandozeile einen Wert von <tt>0</tt> eingeben.
<h2>Signal-L&auml;ngen messen</h2>
Wenn Sie mit gedr&uuml;ckter <tt>Ctrl</tt>-Taste auf einen Signal-Wire klicken, so wird
die L&auml;nge dieses Signal-Segments berechnet und am Bildschirm in einer kleinen
Anzeige nahe der Mausposition angezeigt. Damit k&ouml;nnen Sie die L&auml;nge eines Signal-Segments
messen und diesen Wert als Zielvorgabe f&uuml;r das M&auml;andrieren eines anderen Segments
verwenden.
<p>
F&uuml;hren Sie die Messung mit gedr&uuml;ckten <tt>Ctrl+Shift</tt>-Tasten durch, so wird die
maximale L&auml;nge dieses und aller vorhergehenden Segmente genommen. Damit k&ouml;nnen Sie
auf einfache Weise die maximale L&auml;nge mehrerer Bus-Signale bestimmen und dann jedes
davon auf diese L&auml;nge bringen.
<h2>Symmetrische und asymmetrische M&auml;ander</h2>
Standardm&auml;&szlig;ig wird ein M&auml;ander symmetrisch generiert, das hei&szlig;t er ersteckt sich zu
beiden Seiten entlang des selektierten Wires. Falls das nicht das ist, was Sie
brauchen (entweder weil nur auf einer Seite Platz ist, oder weil der l&auml;ngere der
beiden Wires eines Differential Pairs nicht noch weiter verl&auml;ngert werden soll)
k&ouml;nnen Sie durch Dr&uuml;cken der rechten Maustaste auf den asymmetrischen Modus umschalten.
Die aktuelle Mausposition entscheidet dar&uuml;ber, auf welcher Seite des Wires der
M&auml;ander angelegt wird. Bewegen Sie die Maus hin und her um die passende Position
zu finden.
<h2>L&auml;ngen-Toleranz</h2>
Der Wert, der in den Design Rules unter
"Misc/Max. L&auml;ngenunterschied in Differential Pairs" definiert ist, wird dazu benutzt,
die Farbe der Anzeige der L&auml;ngenabweichungen beim Zeichnen eines M&auml;anders zu
bestimmen. Wird die Prozentzahl in Gr&uuml;n angezeigt, so liegt das betreffende Segment
innerhalb der gegebenen Toleranz. Ansonsten wird sie in Rot dargestellt.
Der Standardwert f&uuml;r diesen Parameter ist 10mm.


<a name=67>
<h1>MENU</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Text-Men&uuml;leiste ver&auml;ndern.
<dt>
<b>Syntax</b>
<dd>
<tt>MENU option ..;</tt><br>
<tt>MENU;</tt>
</dl>
<b>Siehe auch</b> <a href=#32>ASSIGN</a>,
<a href=#96>SCRIPT</a>
<p>
Mit dem MENU-Befehl kann man das Text-Men&uuml; nach eigenen W&uuml;nschen
&auml;ndern.
<p>
Die vollst&auml;ndige Spezifikation f&uuml;r den <tt>option</tt>-Parameter ist:
<pre>
option    := command | submenu | delimiter
command   := [ icon ] text1 [ ':' text2 ]
submenu   := [ icon ] text '{' option [ '|' option ] '}'
icon      := '[' filename ']'
delimiter := '---'
</pre>
Eine Option des MENU-Befehls kann ein einfacher Befehl sein, wie z. B.
<pre>
MENU Display Grid;
</pre>
der die Befehle <tt>Display</tt> und <tt>Grid</tt> als Inhalt des Text-Men&uuml;s definiert.
<tt>Display</tt> und <tt>Grid</tt> werden sowohl als Men&uuml;text als auch als Kommando interpretiert.<br>
Sie kann auch ein selbstdefinierter Befehl sein, wie z. B.
<pre>
MENU 'MyDisp : Display None Top Bottom Pads Vias;' 'MyGrid : Grid mil 100 lines on;';
</pre>
Das Text-Men&uuml; enth&auml;lt die beiden selbstdefinierten Befehle <tt>MyDisp</tt> und <tt>MyGrid</tt>.
Nach Anklicken eines Buttons im Men&uuml; wird die nach <tt>':'</tt> definierte Befehlssequenz
(<tt>text2</tt>, s.o.) der entsprechenden Option ausgef&uuml;hrt.<br>
Sie kann auch eine Schaltfl&auml;che erzeugen, die Untermen&uuml;s enthalten kann, wie z. B.
<pre>
MENU 'Grid { Fine : Grid inch 0.001; | Coarse : Grid inch 0.1; }';
</pre>
Es wird ein Button mit dem Namen <tt>Grid</tt> erzeugt, der nach dem Anklicken ein
Untermen&uuml; mit den beiden Optionen <tt>Fine</tt> und <tt>Coarse</tt> enth&auml;lt.<br>
Das <tt>'|'</tt> ist als Trennzeichen nur bei Untermen&uuml;-Eintr&auml;gen erforderlich (<tt>submenu</tt>, s.o.).
<p>
Die besondere Option <tt>'---'</tt> kann man verwenden, um einen Trennstrich im Men&uuml;
zu erzeugen. Das f&ouml;rdert die &Uuml;bersichtlichkeit im Men&uuml;.
<p>
Ein Befehls-Button kann ein Icon anzeigen, indem dem Button-Text der Dateiname
eines Icons in eckigen Klammern vorangestellt wird, wie in
<pre>
MENU '[/path/to/myicon.png] Set a fine grid : Grid inch 0.001;';
</pre>
Hier zeigt der Button nur das angegebene Icon an und "Set a fine grid" wird
als "Direkthilfe" verwendet, die angezeigt wird, wenn der Mauszeiger &uuml;ber
den Button bewegt wird. Der Dateiname muss nicht zus&auml;tzlich in Hochkommas gesetzt werden
(etwa um Leerzeichen zu maskieren).<br>
Wird ein Icon in einem Untermen&uuml; verwendet, etwa in
<pre>
MENU 'Grid { [/path/to/myicon.png] Set a fine grid : Grid inch 0.001; }';
</pre>
so werden, wie bei anderen Men&uuml;s auch, sowohl das Icon als auch der Text angezeigt.<br>
Enth&auml;lt der Dateiname des Icons keinen Verzeichnispfad, so wird es im aktuellen
Arbeitsverzeichnis und im EAGLE 'bin'-Verzeichnis gesucht.
<p>
Bitte beachten Sie, dass jede <i>option</i>, die mehr als ein Wort oder einen Text,
der als Befehl interpretiert werden kann, enth&auml;lt, in einfache Hochkommas eingeschlossen
werden muss.
Wenn Sie den MENU-Befehl in einer Script-Datei verwenden, um ein komplexes Text-Men&uuml;
zu definieren und dabei die Men&uuml;-Definition zur besseren Lesbarkeit &uuml;ber mehrere Zeilen
verteilen wollen, ist es notwendig, die Zeilen mit einem Backslash (<tt>'\'</tt>) zu beenden,
wie z. B.
<pre>
MENU 'Grid {\
             Fine : Grid inch 0.001; |\
             Coarse : Grid inch 0.1;\
           }';
</pre>
<h2>Beispiele</h2>
<pre>
MENU Move Delete Rotate Route ';' Edit;
</pre>
erzeugt ein Men&uuml;, das die Befehle Move bis Route, den Strichpunkt
als Befehlsabschlusszeichen und den Edit-Befehl enth&auml;lt.
<p>
Der Befehl
<pre>
MENU;
</pre>
stellt wieder das Standard-Men&uuml; ein.
Beachten Sie, dass der Eintrag ';' immer im Men&uuml; enthalten sein sollte.
Er wird zum Beenden vieler Befehle ben&ouml;tigt.
<p>
Komplexes Beispiel:
<p>
<pre>
MENU '[draw.png] Draw {\
                        Wire {\
                               Continous : CHANGE STYLE Continuous; WIRE |\
                               DashDot :  CHANGE STYLE DashDot; WIRE |\
                               Help : HELP WIRE;\
                             }|\
                        Rectangle {\
                                    RECT |\
                                    Help : HELP RECT; \
                                  }\
                       }\
      [export.png] Export {\
                            Script : EXPORT SCRIPT |\
                            Image : EXPORT IMAGE\
                          }\
      MyScript : SCRIPT MyScript.scr;';
</pre>
Dieses Men&uuml; besteht aus den 3 Eintr&auml;gen Draw, Export und MyScript, wobei Draw und Export
Untermen&uuml;s haben und mit Icons versehen sind. Draw besteht aus den Untermen&uuml;s Wire und Rectangle,
wobei Wire aus den Eintr&auml;gen Continous, DashDot und Help und Rectangle aus den Eintr&auml;gen
RECT (Text und Befehl RECT) und Help zusammengesetzt sind. <br>
Das Untermen&uuml; von Export hat die Eintr&auml;ge Script und Image.


<a name=68>
<h1>MIRROR</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Objekte spiegeln.
<dt>
<b>Syntax</b>
<dd>
<tt>MIRROR &#149;..</tt><br>
<tt>MIRROR name..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Rechte</mb> spiegelt die Gruppe.
</dl>
<b>Siehe auch</b> <a href=#93>ROTATE</a>,
<a href=#64>LOCK</a>,
<a href=#104>TEXT</a>
<p>
Mit dem MIRROR-Befehl k&ouml;nnen Objekte an der y-Achse gespiegelt
und damit z.B. auf der L&ouml;tseite der Platine plaziert werden.
<p>
Bauteile, Pads, Smds und Pins lassen sich
auch mit ihrem Namen selektieren. Das ist vor allem dann n&uuml;tzlich,
wenn sich das Objekt ausserhalb des gerade dargestellten Bildausschnitts
befindet.
<p>
Attribute von Bauteilen k&ouml;nnen dadurch selektiert werden, dass die Kombination
aus Bauteilname und Attributname angegeben wird, wie etwa <tt>R5&gt;VALUE</tt>.
<p>
Das Spiegeln von Packages ist nur mit eingeblendetem tOrigins- bzw.
bOrigins-Layer m&ouml;glich.
<p>
Beim Spiegeln von Elementen werden die angeschlossenen
Wires auf den Au&szlig;enlagen mitgespiegelt (Achtung auf Kurzschl&uuml;sse!). Vias werden
dabei nicht automatisch gesetzt.
<p>
Beachten Sie bitte, dass Objekte auf Innenlagen (2...15) beim Spiegeln
ihren Layer nicht wechseln. Gleiches gilt auch f&uuml;r Vias.
<p>
Bauteile k&ouml;nnen nicht gespiegelt werden, wenn sie <a href=#64>gelockt</a> sind,
oder wenn eines ihrer angeschlossenen Pads aus der erlaubten Fl&auml;che hinausstehen w&uuml;rde
(falls sie eine <a href=#378>eingeschr&auml;nkte Version</a> von EAGLE verwenden).
<h2>Gruppe spiegeln</h2>
Will man eine Gruppe spiegeln, definiert man zuerst die Gruppe mit
dem GROUP-Befehl, dann selektiert man den MIRROR-Befehl und klickt
mit der rechten Maustaste die Gruppe an. Sie wird dann um die senkrechte
Achse durch den dem Mauszeiger n&auml;chstgelegenen Rasterpunkt gespiegelt.
<p>
Wires, Circles, Pads und Polygone lassen sich
nicht explizit spiegeln (als Bestandteile von Gruppen werden sie
mitgespiegelt).
<h2>Text spiegeln</h2>
Text auf der L&ouml;tseite (Layer 'Bottom' und 'bPlace') wird automatisch
gespiegelt, so dass er dann sp&auml;ter, wenn man die Platine von der
L&ouml;tseite her betrachtet, richtig lesbar ist.
<p>
Im Schaltplan f&uuml;hrt das Spiegeln eines Textes dazu, dass er auf der anderen
Seite seines Aufh&auml;ngepunktes dargestellt wird; er bleibt aber nach wie vor normal
lesbar.


<a name=69>
<h1>MITER</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Wire-Verbindungsstellen abschr&auml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>MITER [radius] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Linke&amp;Ziehen</mb> modifiziert die Abschr&auml;gung dynamisch.<br>
<mb>Rechte</mb> schaltet zwischen runder und gerader Abschr&auml;gung hin und her.
</dl>
<b>Siehe auch</b> <a href=#102>SPLIT</a>,
<a href=#112>WIRE</a>,
<a href=#94>ROUTE</a>,
<a href=#81>POLYGON</a>
<p>
Der MITER-Befehl dient dazu die Verbindungsstelle zweier Wires abzuschr&auml;gen.
Die beiden existierenden Wires m&uuml;ssen dazu auf dem gleichen Layer liegen, die
gleiche Breite und den gleichen Wire-Style haben.
<h2>Abschr&auml;gen eines Punktes</h2>
Wenn Sie einen Punkt selektieren, an dem sich genau zwei geradlinige Wires treffen,
so wird ein zus&auml;tzlicher Wire zwischen diesen beiden Wires eingef&uuml;gt, dessen Abmessungen
sich aus dem angegebenen <i>radius</i> ergeben.
Wenn sie Click&amp;Drag mit der linken Maustaste an einem solchen Punkt machen, k&ouml;nnen
Sie den zur Abschr&auml;gung verwendeten Wire dynamisch definieren.
<h2>Abschr&auml;gen eines Wires</h2>
Wenn sie einen Wire (der auch ein Kreisbogen sein kann) in der Mitte zwischen seinen Endpunkten
selektieren, und dieser Wire mit genau zwei anderen, geradlinigen Wires (jeweils einer
an jedem Ende) verbunden ist, so werden die Abmessungen dieses Wires gem&auml;&szlig; dem
angegebenen <i>radius</i> neu berechnet.
Wenn sie Click&amp;Drag mit der linken Maustaste an einem solchen Wire machen, k&ouml;nnen
Sie den zur Abschr&auml;gung verwendeten Wire dynamisch definieren.
<h2>Geradlinige und runde Abschr&auml;gung</h2>
Ist der <i>radius</i> positiv, so ist der eingef&uuml;gte Wire ein Kreisbogen mit dem gegebenen
Radius; falls er negativ ist wird ein geradliniger Wire eingef&uuml;gt (stellen Sie sich
das <tt>'-'</tt> Zeichen als Indikator f&uuml;r "geradlinig" vor). Durch Dr&uuml;cken der rechten
Maustaste k&ouml;nnen Sie zwischen runder und geradliniger Abschr&auml;gung hin und her schalten.
<h2>Miter-Radius und Wire-Knickwinkel</h2>
Der <i>radius</i>, den Sie mit dem MITER-Befehl einstellen, wird auch in allen anderen
Befehlen verwendet, die Wires zeichnen, falls der Knickwinkel einer der 90- bzw. 45-Grad
Winkel ist. Bei runder Abschr&auml;gung betrifft dies sowohl 90- als auch 45-Grad Winkel,
bei geradliniger Abschr&auml;gung nur die 90-Grad Winkel.


<a name=70>
<h1>MODULE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Erzeugen eines Moduls.<br>
Modul-Instanz in eine Schaltplanseite einf&uuml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>MODULE [[width height] 'module_name'] ['prefix*'] [+offset] [orientation] &#149;..</tt><br>
<tt>MODULE [[width height] 'module_name'] ['module_instance_name'] [+offset] [orientation] &#149;..</tt><br>
<tt>MODULE 'variant_name@module_name' ['module_instance_name'] [+offset] [orientation] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> spiegelt die Modul-Instanz.<br>
<mb>Rechte</mb> dreht die Modul-Instanz.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#72>NAME</a>,
<a href=#82>PORT</a>,
<a href=#83>PREFIX</a>
<p>
Der MODULE-Befehl wird verwendet, um Module zu erzeugen und um Module mit Hilfe von
Modul-Instanzen im Schaltplan zu verwenden.
<p>
Mit <tt>+offset</tt> kann f&uuml;r die aktuelle Modul-Instanz ein Offset zur Namensgebung
der Bauteile angegeben werden. Der Wert muss ein Vielfaches von 100 sein (z.B. +100).
Beachten Sie, dass dies nur f&uuml;r Modul-Instanzen im Hauptschaltplan unterst&uuml;tzt wird
(Details siehe unten).
<p>
Als Option kann die Schreibrichtung <tt>orientation</tt> auch textuell angegeben werden.
Die entsprechenden Schl&uuml;sselw&ouml;rter sind im <a href=#30>ADD</a>-Befehl
aufgef&uuml;hrt (R0, R90 usw.).
<p>
Der <a href=#82>PORT</a>-Befehl wird verwendet, um Ports zu einem Modul hinzuzuf&uuml;gen.
<p>
Eine Modul-Instanz f&uuml;gt alle Netze und Bauteile des Moduls zum Board hinzu.
Netznamen werden zusammengesetzt aus dem Modul-Instanz-Namen und dem Namen des
Netzes im Modul (z.B. 'MODULE1:N$1').
Wenn ein Netz durch einen <a href=#82>PORT</a> exportiert wird,
&uuml;berschreibt ein am Port angeschlossenes Netz den Modul-internen Netznamen.
Bauteilnamen von Modul-Instanzen mit einem Offset ungleich 0 werden mit diesem
Offset beaufschlagt (z.B. 'R17' wird mit Offset '100' zu 'R117', Details siehe unten).
Wenn kein Offset gesetzt ist, werden auch diese mit dem Modul-Instanz-Namen
zusammengesetzt (z.B. 'MODULE1:R17').
<p>
Um eine bestimmte Best&uuml;ckungsvariante des Moduls zu w&auml;hlen, muss ihr Name dem
Modulnamen vorangestellt werden (z.B. 'V1@ABC').
<h2>Namen, Offset-Notation</h2>
Bei der Moduldefinition kann ein Pr&auml;fix angegeben werden, das zur
automatischen Generierung der Modul-Instanz-Namen verwendet wird.
Zur syntaktischen Unterscheidung in der Befehlszeile muss dem Pr&auml;fix
ein Stern ('*') folgen.
<p>
Wird kein Pr&auml;fix und auch kein Name f&uuml;r die Modul-Instanz angegeben,
wird zur Generierung der Modul-Name als Pr&auml;fix verwendet.
<p>
Die Modul-Instanz-Namen k&ouml;nnen mit <a href=#72>NAME</a> ver&auml;ndert werden.
<p>
Die Offset-Notation f&uuml;r Modul-Instanzen hat den Vorteil, dass k&uuml;rzere Namen erzeugt werden,
aber sie ist mit Vorsicht zu benutzen, da sie zu Namenskonflikten bei den Elementen f&uuml;hren kann.<br>
Beispiel:
<p>
Wenn Sie die Bauteile R1-R9 in einem Modul haben, und auf der Hauptebene des Schaltplans die
Bauteilnamen (bzw. Elementnamen) R201-R209 schon benutzt werden, ist es nicht m&ouml;glich,
eine Modul-Instanz MI von M mit Offset 200 anzulegen, da die generierten Elemente ebenfalls die
Namen R201-R209 beanspruchen w&uuml;rden. EAGLE &uuml;berpr&uuml;ft und verhindert solche F&auml;lle mit
einer Fehlermeldung. Der Konflikt kann leicht gel&ouml;st werden durch Verwendung eines anderen
positiven Offsets oder Offset 0 (also der zusammengesetzten Notation).
<p>
Selbst wenn die Offset-Notation konfliktfrei funktioniert, kann sie auch anderweitig verwirrend sein:
wenn Sie im oberen Beispiel den Offset auf 300 &auml;ndern, aber auf der Hauptebene Bauteile mit Namen
R310, R311 usw. haben, ist es schwierig zu erkennen, dass diese bauteile NICHT zu MI geh&ouml;ren,
sondern zur Hauptebene. Deswegen wird empfohlen, die Offsets gro&szlig; genug zu w&auml;hlen um solche
Missverst&auml;ndnisse zu vermeiden.
<p>
Je nachdem was Sie vorhaben, kann die zusammengesetzte Notation unter Verwendung kurzer
Modul-Instanz-Namen die bessere Alternative sein.
<p>
Ebenfalls um Missverst&auml;ndnisse zu reduzieren, kann jeder Offset im ganzen Schaltplan nur
einmal benutzt werden. Der Eigenschaften-Dialog f&uuml;r Modul-Instanzen erlaubt die &Auml;nderung
des Offsets nur auf solche Werte, die noch nicht vergeben sind (oder auf 0).
<h2>Tiefere Hierarchien</h2>
Modul-Instanzen k&ouml;nnen auch in eine Modulseite platziert werden. Auf diese Weise kann eine
Hierarchie beliebiger Tiefe erzeugt werden.
<p>
Offsets > 0 werden in tieferen Hierarchiestufen nicht unterst&uuml;tzt.<br>
Beispiel:<br>
Die Instanz F0 benutzt FILTER mit Offset 100, Instanz SUB befindet sich in FILTER und benutzt
SUBMODULE mit Offset 0. F&uuml;r die Elemente aller Bauteile in FILTER wird Offset 100 verwendet,
f&uuml;r die Elemente zu allen Bauteilen in SUBMODULE wird die zusammengesetzte Notation wie bei einem
Verzeichnispfad verwendet, ebenso f&uuml;r die Signale zu den Netzen in SUBMODULE. So wird z.B. der Name
f&uuml;r das Element, welches C1 in SUBMODULE enspricht, zu F0:SUB:C1.
<i>(Anmerkung: Wenn Offsets auch in tieferen Hierarchien zul&auml;ssig w&auml;ren, w&uuml;rde dies zu weiteren m&ouml;glichen
Konflikten und Missverst&auml;ndnissen f&uuml;hren).</i>
<h2>Abmessungen</h2>
Die Abmessungen eines Moduls k&ouml;nnen bei der Definition durch <tt>width</tt> und <tt>height</tt>
angegeben werden.
<h2>Editieren</h2>
Der <a href=#71>MOVE</a>-Befehl kann zum Bearbeiten der Modul-Darstellung verwendet werden.
Mit <mb>Ctrl+Linke</mb> lassen sich die R&auml;nder selektieren.


<a name=71>
<h1>MOVE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Bewegen von Objekten.
<dt>
<b>Syntax</b>
<dd>
<tt>MOVE &#149; &#149;..</tt><br>
<tt>MOVE name &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Linke</mb> selektiert ein Objekt an seinem Aufh&auml;ngepunkt bzw. ver&auml;ndert es (siehe Anmerkung).<br>
<mb>Ctrl+Rechte</mb> selektiert die Gruppe.<br>
<mb>Linke&amp;Ziehen</mb> bewegt das Objekt sofort.<br>
<mb>Ctrl+Rechte&amp;Ziehen</mb> bewegt die Gruppe sofort.<br>
<mb>Mittlere</mb> spiegelt das Objekt bzw. die Gruppe.<br>
<mb>Rechte</mb> dreht das selektierte Objekt bzw. die Gruppe.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
<dt>
<b>Tastatur</b>
<dd>
<tt>F7: MOVE</tt>   aktiviert den MOVE-Befehl.
</dl>
<b>Siehe auch</b> <a href=#56>GROUP</a>,
<a href=#64>LOCK</a>,
<a href=#86>RATSNEST</a>
<p>
Der MOVE-Befehl bewegt das Objekt, das dem Mauszeiger bzw. dem angegebenen
Koordinatenpunkt am n&auml;chsten liegt.
<p>
Bauteile, Pads, Smds, Pins und Gatter lassen sich
auch mit ihrem Namen selektieren. Das ist vor allem dann n&uuml;tzlich,
wenn sich das Objekt ausserhalb des gerade dargestellten Bildausschnitts
befindet. Beim Selektieren eines aus mehreren Gattern bestehenden Bauteils
im Schaltplan muss der volle, aus dem Bauteil- und dem jeweiligen Gatternamen
bestehende Name angegeben werden.
<p>
Attribute von Bauteilen k&ouml;nnen dadurch selektiert werden, dass die Kombination
aus Bauteilname und Attributname angegeben wird, wie etwa <tt>R5&gt;VALUE</tt>.
<p>
Das Bewegen von Elementen ist nur mit eingeblendetem tOrigins- bzw.
bOrigins-Layer m&ouml;glich.
<p>
Der MOVE-Befehl wirkt nur auf sichtbare Layer (siehe DISPLAY).
<p>
Wires, die an einem Element h&auml;ngen, lassen sich an diesem Ende
nicht bewegen. Beim Bewegen von Elementen bewegen sich die angeschlossenen
Wires mit, sofern sie Bestandteil eines Signals sind, (Achtung
auf Kurzschl&uuml;sse!).
<p>
Wird ein Objekt mit der linken Maustaste angeklickt und die Taste danach
nicht wieder losgelassen, so kann das Objekt sofort bewegt werden ("Click&amp;Drag").
Gleiches gilt f&uuml;r Gruppen bei Verwendung der rechten Maustaste.
Es ist dann allerdings nicht m&ouml;glich das Objekt w&auml;hrend des Bewegens zu
drehen oder zu spiegeln.
<p>
Bauteile k&ouml;nnen nicht bewegt werden, wenn sie <a href=#64>gelockt</a> sind,
oder wenn eines ihrer angeschlossenen Pads aus der erlaubten Fl&auml;che hinausstehen w&uuml;rde
(falls sie eine <a href=#378>eingeschr&auml;nkte Version</a> von EAGLE verwenden).
<h2>Leitungen bewegen</h2>
Bewegt man mit MOVE Wires &uuml;bereinander, dann werden diese Wires
nicht zu einem Signal verbunden (Kurzschluss, den der DRC-Befehl
feststellt).
<h2>Gruppe bewegen</h2>
Will man eine Gruppe bewegen, definiert man zuerst die Gruppe mit
dem GROUP-Befehl, dann selektiert man den MOVE-Befehl und klickt mit
der rechten Maustaste die Gruppe an. Jetzt l&auml;sst sich die ganze
Gruppe bewegen und mit der rechten Maustaste (um den Mauszeiger) rotieren.
<h2>Hinweise f&uuml;r den Schaltplan</h2>
Wird ein Supply-Pin (Pin-Direction Sup)
auf ein Netz plaziert, erh&auml;lt dieses Netz-Segment den Namen des
Supply-Pins. Werden Pins direkt aufeinander plaziert (ohne explizite
Netz-Linie), sind sie verbunden.
<p>
Wird ein Element bewegt, werden beim Absetzen offene Pins dieses Elements
an eventuell vorhandene Netze bzw. andere Pins angeschlossen.
<p>
Bewegt man ein Netz auf einen Pin, werden Netz und Pin nicht logisch
verbunden, obwohl sie optisch verbunden sind.
<h2>Objekte an ihrem Aufh&auml;ngepunkt selektieren</h2>
Normalerweise bleibt ein selektiertes Objekt in dem Raster, in dem es urspr&uuml;nglich
plaziert wurde. Wird beim Selektieren eines Objektes <tt>Ctrl</tt> gedr&uuml;ckt,
so wird der Punkt, an dem das Objekt selektiert wurde, an den Mauszeiger
gezogen und schnappt in das aktuelle Raster.
<p>
Wird ein <i>Wire</i> in der Mitte (nicht an einem seiner Endpunkte) mit gedr&uuml;ckter
<tt>Ctrl</tt>-Taste selektiert, so bleiben die Endpunkte fixiert und der Wire kann
gebogen werden, wodurch er zum Kreisbogen wird. Auf die gleiche Weise kann die Kr&uuml;mmung eines
Kreisbogens (der im Grunde nichts anderes als ein Wire ist) ver&auml;ndert werden.
<p>
Wird ein <i>Rechteck</i> an einer seiner Ecken mit gedr&uuml;ckter <tt>Ctrl</tt>-Taste
selektiert, so kann die Gr&ouml;&szlig;e des Rechtecks sowohl in der Breite als auch in der H&ouml;he
ver&auml;ndert werden. Beim Selektieren einer Kante mit gedr&uuml;ckter <tt>Ctrl</tt>-Taste
l&auml;&szlig;t sich nur die Breite bzw. die H&ouml;he ver&auml;ndern. Selektiert man das Rechteck an
seinem Mittelpunkt mit gedr&uuml;ckter <tt>Ctrl</tt>-Taste, so wird dieser an den Mauszeiger
gezogen und in das aktuelle Raster geschnappt.
<p>
Wird ein <i>Kreis</i> mit gedr&uuml;ckter <tt>Ctrl</tt>-Taste an seinem Umfang selektiert,
so bleibt sein Mittelpunkt fix und der Durchmesser kann ver&auml;ndert werden. Wird
der Mittelpunkt auf diese Weise selektiert, so wird dieser an den Mauszeiger
gezogen und in das aktuelle Raster geschnappt.
<h2>Teile einer Seite auf eine andere Seite verschieben</h2>
Sie k&ouml;nnen Teile einer Seite auf eine andere Seite des gleichen Schaltplans
verschieben, ohne die Platine zu beeinflussen (falls <a href=#372>Forward&amp;Back Annotation</a>
aktiviert ist), indem Sie eine <a href=#56>Gruppe</a> definieren, die die
zu verschiebenden Objekte enth&auml;lt, diese mit dem MOVE-Befehl selektieren und dann
auf die gew&uuml;nscht Seite umschalten, wobei der MOVE-Befehl immer noch aktiv sein und
die Gruppe am Mauszeiger h&auml;ngen muss. In der neuen Seite ist dann der MOVE-Befehl wieder aktiv
und hat die vorher definierte Gruppe am Mauszeiger. Platzieren Sie die Gruppe jetzt
wie &uuml;blich, so werden alle betroffenen Objekte von der urspr&uuml;nglichen Seite auf die
aktuelle Seite verschoben. Falls die aktuelle Seite gleich der urspr&uuml;nglichen ist,
passiert nichts.
<p>
Beachten Sie, das nur solche Wires verschoben werden, die beide Enden in der Gruppe
haben, und dass Bauteile, die verschoben werden, alle ihre elektrischen Verbindungen
mitnehmen, auch wenn ein an einem Pin angeschlossener Net-Wire nicht verschoben wird,
da sein anderes Ende nicht in der Gruppe liegt.
Falls ein Pin auf der neuen Seite eine elektrische Verbindung hat, aber kein anderer
Pin, Wire oder Junction daran angeschlossen ist um dies sichtbar zu machen, so
wird automatisch eine Junction an dieser Stelle generiert.
<p>
Dieser Vorgang kann sogar in einem Script ausgef&uuml;hrt werden. Zum Beispiel w&uuml;rde
<pre>
edit .s1
group (1 1) (1 2) (2 2) (2 1) (1 1)
move (&gt; 0 0)
edit .s2
(0 0)
</pre>
auf die erste Seite schalten, eine Gruppe definieren, diese mit MOVE selektieren,
auf die zweite Seite schalten und die Gruppe absetzen. Die Koordinaten <tt>(0 0)</tt>
am Schluss sind f&uuml;r den implizit gestarteten MOVE-Befehl.
<p>
Falls Sie lediglich die Reihenfolge der Seiten ver&auml;ndern wollen, so k&ouml;nnen Sie
das mit dem <a href=#49>EDIT</a>-Befehl tun.


<a name=72>
<h1>NAME</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Anzeigen und &Auml;ndern von Namen.
<dt>
<b>Syntax</b>
<dd>
<tt>NAME &#149;..</tt><br>
<tt>NAME new_name &#149;</tt><br>
<tt>NAME old_name new_name</tt>
</dl>
<b>Siehe auch</b> <a href=#98>SHOW</a>,
<a href=#100>SMASH</a>,
<a href=#108>VALUE</a>
<p>
Mit den NAME-Befehl kann man den Namen
des selektierten Objektes anzeigen und
(in einem Popup-Men&uuml;) &auml;ndern.
<p>
Bauteile, Pads, Smds, Pins und Gatter lassen sich
auch mit ihrem Namen selektieren. Das ist vor allem dann n&uuml;tzlich,
wenn sich das Objekt ausserhalb des gerade dargestellten Bildausschnitts
befindet. Andere Objekttypen (z.B. Netze, Busse, Signale) m&uuml;ssen vorher angeklickt werden.
<h2>Bibliothek</h2>
Im Bibliotheks-Editier-Modus gilt das gleiche f&uuml;r Pad-, Smd-,
Pin- und Gate(Symbol)-Namen.
<h2>Automatische Namensvergabe</h2>
EAGLE vergibt automatisch Namen (N$.. f&uuml;r Netze; E$.. f&uuml;r Elemente; S$.. f&uuml;r
Signale; P$.. f&uuml;r Pads, Pins und Smds; G$.. f&uuml;r Gates). Zumindest
in Packages und Symbolen sollte man die Pad- und Pin-Bezeichnungen
durch g&auml;ngige Namen (z.B. 1..14 bei einem 14pol. DIL-Geh&auml;use)
bzw. die Signalbezeichnung ersetzen.
Die automatische Namensvergabe von Bauteilen kann mit <a href=#83>PREFIX</a>
gesteuert werden.
<h2>Namensregeln</h2>
Buchstaben in EAGLE-Objektnamen werden automatisch in Grossschreibweise umgewandelt.
Neben den normalen Buchstaben toleriert EAGLE die meisten anderen Sonderzeichen ausser dem
Leerzeichen und dem Strichpunkt (';'). Bei Netze, Bauteilen, Modul-Instanzen, Signalen
und Elementen wird auch der Doppelpunkt (':') nicht unterst&uuml;tzt, da er f&uuml;r die automatische
und eindeutige Benennung von Objekten in hierarchischen Designs ben&ouml;tigt wird.<br>
Zum Beispiel kann sich ein Element AMP1:IC1 nur auf ein Bauteil IC1 in dem Modul beziehen,
welches von der Modul-Instanz AMP1 benutzt wird, Konsistenz vorausgesetzt.
<p>
Neben dem Haupt-Schaltplan hat jedes Modul seinen eigenen <i>Namensraum</i>. Daher ist es
kein Problem, die Bauteile R1 bis R9 auf der Hauptebene und auch in einem oder mehreren Modulen
zu haben. Siehe auch Befehl <a href=#70>MODULE</a>.
<h2>Schaltplan</h2>
Beim Umbenennen von Netzen und Bussen in Schaltpl&auml;nen werden drei
verschiedene F&auml;lle unterschieden, da Netze und Busse aus mehreren
(nicht explizit verbundenen) Segmenten bestehen und &uuml;ber mehrere
Seiten verteilt sein k&ouml;nnen. Das in einem solchen Fall erscheinende Men&uuml;
erm&ouml;glicht die Auswahl, ob
<p>
nur das selektierte Segment,<br>
alle Segmente auf dieser Seite,<br>
alle Segmente auf allen Seiten
<p>
mit der Maus oder durch Eingabe des entsprechenden Hot-Keys
umbenannt werden sollen. Je nachdem ob das Netz bzw. der
Bus nur auf dieser Seite definiert ist oder aus einem oder mehreren
Segmenten besteht, entfallen einzelne Punkte des Men&uuml;s bzw. das
gesamte Men&uuml;. Existiert der neue Name bereits (auf dieser oder
einer anderen Seite), wird vorher noch abgefragt, ob die beiden Netze
bzw. Busse verbunden werden sollen.
<h2>Polygon</h2>
Beim Umbenennen eines Signal-Polygons in einem Board kann ausgew&auml;hlt werden,
ob nur dieses Polygon umbenannt (und damit Bestandteil eines anderen Signals)
werden soll, oder ob das gesamte Signal einen anderen Namen erhalten soll.


<a name=73>
<h1>NET</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeichnen von Netzen im Schaltplan.
<dt>
<b>Syntax</b>
<dd>
<tt>NET [net_name] &#149; [curve | @radius] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Rechte</mb> &auml;ndert den Knickwinkel (siehe <a href=#97>SET Wire_Bend</a>).<br>
<mb>Shift+Rechte</mb> kehrt die Richtung des Weiterschaltens des Knickwinkels um.<br>
<mb>Ctrl+Rechte</mb> schaltet zwischen korrespondierenden Knickwinkeln hin und her.
</dl>
<b>Siehe auch</b> <a href=#36>BUS</a>,
<a href=#72>NAME</a>,
<a href=#39>CLASS</a>,
<a href=#97>SET</a>
<p>
Mit dem NET-Befehl zeichnet man Einzelverbindungen (Netze) in den
Net-Layer eines Schaltplans. Der erste Mausklick gibt den Startpunkt
des Netzes an, der zweite setzt die Linie ab.
Zwei Mausklicks am selben Punkt beenden das Netz.
<p>
Wird ein Netz an einem Punkt abgesetzt, an dem schon ein anderes Netz,
ein Bus oder ein Pin liegt, endet die Netzlinie hier.
Diese Funktion kann &uuml;ber "<tt>SET AUTO_END_NET OFF;</tt>" oder durch
Deselektieren der Option "Netze und Busse automatisch beenden" im Men&uuml; "Optionen/Einstellungen/Verschiedenes"
abgeschaltet werden.
<p>
Wird eine Netzlinie an einem Punkt abgesetzt an dem mindestens zwei
Netzlinien und/oder Pins liegen, wird automatisch ein Verkn&uuml;pfungspunkt
(Junction) gesetzt.
Diese Funktion kann &uuml;ber "<tt>SET AUTO_JUNCTION OFF;</tt>" oder durch
Deselektieren der Option "Junctions automatisch setzen" im Men&uuml; "Optionen/Einstellungen/Verschiedenes"
abgeschaltet werden.
<p>
Wird der <i>curve</i> oder <i>@radius</i> Parameter angegeben, so kann ein Kreisbogen als Teil des Netzes
gezeichnet werden (siehe die ausf&uuml;hrliche Beschreibung beim <a href=#112>WIRE</a>-Befehl).
<h2>Bussignal ausw&auml;hlen</h2>
Startet man das Netz auf einem Bus, &ouml;ffnet sich ein Popup-Men&uuml;,
aus dem man ein Signal des Busses ausw&auml;hlen kann. Das Netz erh&auml;lt
dann den entsprechenden Namen und geh&ouml;rt damit zu diesem Signal.
Enth&auml;lt der Bus mehrere Teilbusse, &ouml;ffnet sich erst ein Popup-Men&uuml;,
in dem man den gew&uuml;nschten Teilbus ausw&auml;hlen kann.
<h2>Netz-Namen</h2>
Gibt man einen Namen im NET-Befehl an, dann
erh&auml;lt das Netz diesen Namen.
<p>
Gibt man keinen Namen im NET-Befehl an und startet man auch nicht
auf einem Bus, dann wird ein Name der Form N$1 f&uuml;r das Netz automatisch
vergeben.
<p>
Netze oder Teile davon, die auf verschiedenen Seiten eines Schaltplans liegen und denselben
Namen haben, sind miteinander verbunden.
<p>
Netznamen sollten kein Komma (<tt>','</tt>) enthalten, da dieses das Trennzeichen
f&uuml;r <a href=#36>Busse</a> ist.
<h2>Linienbreite</h2>
Die Breite der Linien, die ein Netz darstellen, l&auml;sst sich
mit dem Befehl
<pre>
SET NET_WIRE_WIDTH width;
</pre>
voreinstellen (Default: 6 Mil).
<h2>Negierte Signale</h2>
Der Name eines negierten Signals ("active low") kann &uuml;berstrichen dargestellt werden,
wenn ihm ein Ausrufezeichen (<tt>'!'</tt>) vorangestellt wird, wie in
<pre>
  !RESET
</pre>
was als
<pre>
  _____
  RESET
</pre>
dargestellt w&uuml;rde.
Einzelheiten hierzu finden Sie in der Beschreibung des <a href=#104>TEXT</a>-Befehls.


<a name=74>
<h1>OPEN</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnen einer Bibliothek.
<dt>
<b>Syntax</b>
<dd>
<tt>OPEN library_name</tt>
</dl>
<b>Siehe auch</b> <a href=#40>CLOSE</a>,
<a href=#107>USE</a>,
<a href=#49>EDIT</a>,
<a href=#96>SCRIPT</a>
<p>
Der OPEN-Befehl &ouml;ffnet eine existierende Bibliothek oder legt
eine neue an, falls noch keine mit dem angegebenen Namen existiert.
Danach kann ein existierendes oder ein neues Symbol, Device oder Package
editiert werden.
<p>
Dieser Befehl ist in erster Linie f&uuml;r Script-Dateien erforderlich.


<a name=75>
<h1>OPTIMIZE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zusammenfassen von Wire-Segmenten.
<dt>
<b>Syntax</b>
<dd>
<tt>OPTIMIZE;</tt><br>
<tt>OPTIMIZE signal_name ..</tt><br>
<tt>OPTIMIZE &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Rechte</mb> optimiert die Gruppe.
</dl>
<b>Siehe auch</b> <a href=#97>SET</a>,
<a href=#102>SPLIT</a>,
<a href=#71>MOVE</a>,
<a href=#94>ROUTE</a>
<p>
Der OPTIMIZE-Befehl (welcher nur in einer Board-Zeichnung anwendbar ist) fasst Wire-Segmente, die
in einer Linie liegen, zu einem Segment zusammen. Voraussetzung daf&uuml;r
ist, dass sich die Segmente im selben Layer befinden und dass
Sie dieselbe Breite haben.
<p>
Werden Signalnamen angegeben oder wird ein Signal selektiert, so wirkt der
Befehl nur auf die entsprechenden Signale.
<p>
Wird ein Objekt mit der Maus selektiert (oder eine Gruppe selektiert)
so werden nur echte Signal-Wires optimiert. Um alle Wires in einem Board
zu optimieren, geben Sie ein
<pre>
OPTIMZE;
</pre>
<h2>Automatische Optimierung</h2>
Diese Wire-Optimierung geschieht auch automatisch nach dem MOVE-,
SPLIT und ROUTE-Befehl f&uuml;r den damit selektieren Wire, es sei
denn, sie wurde mit dem Befehl
<pre>
SET OPTIMIZING OFF;
</pre>
abgeschaltet, oder beim SPLIT-Befehl wurden zwei Mausklicks auf
denselben Punkt eines Wires gesetzt.
<p>
Der OPTIMIZE-Befehl arbeitet unabh&auml;ngig von der Einstellung der
Set-Variablen Optimizing, d.h. er funktioniert auch, wenn
<pre>
SET OPTIMIZING OFF;
</pre>
eingegeben wurde.


<a name=76>
<h1>PACKAGE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zuweisung einer Package-Variante f&uuml;r ein Device.
<dt>
<b>Syntax</b>
<dd>
<tt>PACKAGE</tt><br>
<tt>PACKAGE pname vname</tt><br>
<tt>PACKAGE pname@lname vname</tt><br>
<tt>PACKAGE name</tt><br>
<tt>PACKAGE -old_name new_name</tt><br>
<tt>PACKAGE -name</tt><br>
</dl>
<b>Siehe auch</b> <a href=#41>CONNECT</a>,
<a href=#103>TECHNOLOGY</a>,
<a href=#83>PREFIX</a>
<p>
Dieser Befehl wird im Device-Editor verwendet um eine Geh&auml;use-Variante
zu definieren, zu l&ouml;schen oder umzubenennen.
Im Schaltplan- oder Board-Editor verh&auml;lt sich der PACKAGE-Befehl genau so
wie "<a href=#37>CHANGE PACKAGE</a>".
<p>
Ohne Angabe von Parametern &ouml;ffnet sich ein Dialog, der es erlaubt ein Geh&auml;use zu
w&auml;hlen und dessen Varianten-Namen zu definieren.
<p>
Die Parameter <tt>pname vname</tt> verkn&uuml;pfen das Geh&auml;use <tt>pname</tt> mit
der neuen Variante <tt>vname</tt>.
<p>
In der Schreibweise <tt>pname@lname vname</tt> wird das Package <tt>pname</tt>
aus der Bibliothek <tt>lname</tt> geholt und eine neue Geh&auml;use-Variante erzeugt.
Dies kann ebenso &uuml;ber das <a href=#14>Kontext-Men&uuml;</a> der
Bibliotheksobjekte oder &uuml;ber <i>Drag&amp;Drop</i> aus der Baumansicht des Control
Panels erfolgen.
<p>
Der einzelne Parameter <tt>name</tt> ruft die schon vorhandene Package-Variante
auf. Wurde bisher noch keine Package-Variante definiert und existiert ein
Package mit dem angegebenen Namen in der Bibliothek, wird mit diesem Package eine neue
Package-Variante mit Namen '' (ein "leerer" Name) erzeugt (aus Kompatibilit&auml;tsgr&uuml;nden
zu Version 3.5 notwendig).
<p>
Gibt man <tt>-old_name new_name</tt> an, wird die Package-Variante <tt>old_name</tt>
umbenannt in <tt>new_name</tt>.
<p>
Der einzelne Parameter <tt>-name</tt> l&ouml;scht die angegebene Package-Variante.
<p>
Der Name der Package-Variante wird dem Device-Set-Namen hinzugef&uuml;gt, so dass ein
eindeutiger Device-Name entsteht. Enth&auml;lt der Device-Set-Name das Zeichen <tt>'?'</tt>,
wird dieser Platzhalter durch den Package-Varianten-Namen ersetzt.
Bitte beachten Sie, dass die Package-Variante erst nach der Technology-Funktion
bearbeitet wird. Wenn der Device-Set-Name weder <tt>'*'</tt> noch <tt>'?'</tt> enth&auml;lt,
setzt sich der Device-Name aus <i>Device-Set-Name</i><tt>+</tt><i>Technology</i><tt>+</tt><i>Package-Variante</i> zusammen.
<p>
Anschlie&szlig;end ist der CONNECT-Befehl zu verwenden, damit festgelegt
werden kann, welcher Pin (im Schaltplan-Symbol) welchem Pad des Geh&auml;uses
entspricht.
<p>
F&uuml;hrt man im Schaltplan-Modus den <a href=#35>BOARD</a>-Befehl aus,
so entsteht f&uuml;r jedes Device dasjenige Package, das mit dem
PACKAGE-Befehl festgelegt wurde.
<h2>Devices ohne Packages</h2>
Man kann auch Devices ohne Zuordnung eines Package erzeugen, beispielweise f&uuml;r Zeichnungsrahmen,
Supply-Devices, externe oder andere Devices, die nur im Schaltplan Sinn machen.
Man erreicht dies, indem man das Device-Set mit den entsprechenden Symbolen, ggf. Technologien und
Attributen anlegt, jedoch das Package-Kommando nicht verwendet. Speichert man dies so, entsteht eine
packagelose Variante (mit Leerstring als Variantennamen).
Sobald ein Package zugewiesen wird, wird die packagelose Variante damit &uuml;berschrieben und es k&ouml;nnen keine
weiteren packagelose Varianten erzeugt werden.<br>
Sobald die Gates Pins enthalten sind packagelose Devices nur begrenzt sinnvoll (s.u.).
<h3>Supply-Devices</h3>
Um Supply-Symbole im Schaltplan zu verwenden, nutzt man packagelose Supply-Devices. Das Device besteht in der
Regel aus genau einem Symbol mit einem <i>Sup</i>-Pin (siehe <a href=#79>PIN</a>-Befehl).
<h3>Externe Devices</h3>
Diese dienen dazu, um im Schaltplan Anordnungen zu dokumentieren, die im Board nicht relevant sind,
da es sich um extern zugeschaltete Anordnungen handelt, z.B. f&uuml;r Simulations- oder Testzwecke.<br>
Solche Devices m&uuml;ssen mit dem Attribut <b>_EXTERNAL_</b> ausgestattet sein (siehe
<a href=#33>ATTRIBUTE</a>-Befehl). Der Wert spielt keine Rolle. In diesem Fall k&ouml;nnen
beliebige Gatter mit Pins definiert sein, ohne dass ein Package existiert.
Das Attribut muss in der Library vergeben worden sein und nicht erst im Schaltplan oder Board.
<p>
Man beachte, dass Supply- und externe Devices nicht mehr als solche gehandhabt werden, sobald dazu
Packages definiert werden. Die Pins m&uuml;ssen dann entsprechend angeschlossen sein.


<a name=77>
<h1>PAD</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Plazieren von Pads in Packages.
<dt>
<b>Syntax</b>
<dd>
<tt>PAD [diameter] [shape] [orientation] [flags] ['name'] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Rechte</mb> dreht das Pad.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#101>SMD</a>,
<a href=#37>CHANGE</a>,
<a href=#47>DISPLAY</a>,
<a href=#97>SET</a>,
<a href=#72>NAME</a>,
<a href=#110>VIA</a>,
<a href=#139>Design Rules</a>
<p>
Ein Pad ist ein Bauelemente-Anschluss mit Durchkontaktierung.
<p>
Der PAD-Befehl plaziert ein Pad in einem Package. Die Eingabe eines
Durchmessers vor dem Plazieren &auml;ndert die Gr&ouml;&szlig;e des Pads.
Der Durchmesser wird in der aktuellen Ma&szlig;einheit angegeben. Er darf
maximal 200 mm (ca. 7.7840 Zoll) betragen.
<p>
Pads erzeugen Bohrsymbole im Layer Drills und die L&ouml;tstopmaske in den
Layern tStop/bStop.
<p>
Die <tt>orientation</tt> (siehe Beschreibung bei <a href=#30>ADD</a>)
darf jeder Winkel im Bereich <tt>R0</tt>...<tt>R359.9</tt> sein. Das <tt>S</tt>-
bzw. <tt>M</tt>-Flag kann hier nicht benutzt werden.
<h2>Beispiel</h2>
<pre>
PAD 0.06 &#149;
</pre>
Falls die eingestellte Ma&szlig;einheit "Inch" ist, hat das Pad einen
Durchmesser von 0.06 Zoll. Die eingegebene Gr&ouml;&szlig;e bleibt f&uuml;r nachfolgende
Operationen erhalten.
<h2>Pad-Formen</h2>
Ein Pad kann eine der folgenden Formen (<i>shape</i>) haben:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Square    </td><td width=20><td>quadratisch</td></tr>
<tr><td>Round     </td><td width=20><td>rund</td></tr>
<tr><td>Octagon   </td><td width=20><td>achteckig</td></tr>
<tr><td>Long      </td><td width=20><td>l&auml;nglich</td></tr>
<tr><td>Offset    </td><td width=20><td>l&auml;nglich mit Versatz</td></tr>
</table>
<p>
Diese Formen gelten nur f&uuml;r die Aussenlagen (Top bzw. Bottom).
In den Innenlagen ist die Form immer "rund".
<p>
Bei den l&auml;nglichen Pads ist der kleinere der beiden Durchmesser
als Parameter anzugeben. Das Seitenverh&auml;ltnis wird &uuml;ber den Parameter
Shapes/Elongation in den <a href=#139>Design Rules</a> des Boards
festgelegt (Default ist 100%, also ein Seitenverh&auml;ltnis von 2:1).
<p>
Die Pad-Form kann entweder (wie der Durchmesser) eingegeben werden,
w&auml;hrend der Pad-Befehl aktiv ist, oder sie kann mit dem CHANGE-Befehl
ver&auml;ndert werden, z. B.:
<pre>
CHANGE SHAPE OCTAGON &#149;
</pre>
Die eingegebene Form bleibt f&uuml;r nachfolgende Operationen erhalten.
<p>
Da die Darstellung verschiedener Pad-Formen und der Bohrl&ouml;cher
den Bildaufbau etwas verlangsamt, kann mit dem Befehl
<pre>
SET DISPLAY_MODE REAL | NODRILL;
</pre>
von realer auf schnelle Darstellung umgeschaltet werden.
<p>
Beachten Sie bitte, dass die tats&auml;chlichen Werte f&uuml;r Pad-Form und -Durchmesser durch die
<a href=#139>Design Rules</a> des Boards bestimmt werden, in dem das Bauteil
verwendet wird.
<h2>Beliebige Pad-Formen</h2>
Falls die standardm&auml;&szlig;igen Pad-Formen f&uuml;r ein bestimmtes Bauteil nicht
ausreichen, k&ouml;nnen Sie beliebige Pad-Formen dadurch erzeugen, dass Sie
ein Polygon um ein Pad herum zeichnen, oder Wires zeichnen, die mit einem
Ende an das Pad angeschlossen sind.
<p>
Hierbei gelten folgende Bedingungen:
<ul>
<li>Ein Polygon in einem Signal-Layer (1-16) gilt als mit einem Pad verbunden, wenn
    der Aufh&auml;ngepunkt des Pads innerhalb der durch die Mittellinien der Polygon-Wires
    definierten Fl&auml;che liegt.
<li>Ein Wire in einem Signal-Layer gilt als mit einem Pad verbunden, wenn einer
    seiner Endpunkte am Aufh&auml;ngepunkt des Pads liegt. Etwaige mit dem anderen Ende
    eines solchen Wires verbundene weitere Wires sind ebenfalls elektrisch mit dem
    Pad verbunden.
<li>Pro Pad wird nur <b>ein</b> Polygon ber&uuml;cksichtigt.
    Ist mehr als ein Polygon an einem Pad angeschlossen, so erzeugen diese DRC-Fehler.
<li>Mit einem Pad verbundene Polygone werden von Autorouter ignoriert, wenn er das
    betreffende Signal routet. F&uuml;r andere Signale gelten sie als Hindernisse.
<li>Mit einem Pad verbundene Wires werden wie alle anderen Signal-Wires behandelt,
    mit dem Unterschied, dass sie nicht gesplittet werden k&ouml;nnen.
<li>L&ouml;tstop-Masken werden nur f&uuml;r das Pad selber erzeugt. Werden dar&uuml;ber
    hinaus weitere L&ouml;tstop--Masken ben&ouml;tigt, so m&uuml;ssen diese explizit
    in die entsprechenden Layer gezeichnet werden.
<li>Bei der Generierung von Thermal-Stegen wird die zus&auml;tzliche Polygon-Form mit
    ber&uuml;cksichtigt.
<li>Ist ein Polygon oder Wire mit mehr als einem Pad innerhalb eines Bauteils verbunden,
    so gilt nur eines der Pads als elektrisch mit dem Polygon bzw. Wire verbunden.
    Die anderen Pads erzeugen DRC-Fehler, es sei denn, sie sind alle innerhalb eines
    Devices <a href=#41>am selben Pin angeschlossen</a>.
<li>Enth&auml;lt ein Polygon mehrere Pads, so erzeugt nur eines davon (das erste in der
    Datenstruktur gefundene) Thermal-Stege. Sollen alle solchen Pads Thermal-Stege
    erzeugen, so m&uuml;ssen Sie meherere Polygone zeichnen (eines pro Pad), die
    entsprechend &uuml;berlappen.
<li>Sind mehrere Pads mit einem Pin verbunden, und haben diese Pads &uuml;berlappende
    Wires oder Polygone im Package, so wird es zu DRC-Fehlern kommen, falls der Pin
    nicht an einem Netz angeschlossen ist (d.h. die Pads nicht an einem Signal
    angeschlossen sind).
</ul>
<h2>Pad-Namen</h2>
Pad-Namen werden vom Programm automatisch erzeugt und k&ouml;nnen mit
dem NAME-Befehl ge&auml;ndert werden.
Der Name kann als Parameter auch im PAD-Befehl mit angegeben werden
(muss in Hochkommas eingeschlossen sein).
<p>
Die Namen der Pads kann man mit dem Befehl
<pre>
SET PAD_NAMES ON/OFF
</pre>
ein- bzw. ausblenden. Die &Auml;nderung wird erst nach dem n&auml;chsten
Bildaufbau sichtbar.
<h2>Flags</h2>
Folgende <i>flags</i> k&ouml;nnen dazu benutzt werden, das Erscheinungsbild eines Pads zu
beeinflussen:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>NOSTOP</tt>  </td><td width=20><td>keine L&ouml;tstopmaske generieren</td></tr>
<tr><td><tt>NOTHERMALS</tt>       </td><td width=20><td>keine Thermals generieren</td></tr>
<tr><td><tt>FIRST</tt>            </td><td width=20><td>dies ist das "erste" Pad (und kann mit einer speziellen Form dargestellt werden)</td></tr>
</table>
<p>
Standardm&auml;&szlig;ig generieren Pads automatisch L&ouml;tstopmaske und Thermals.
In speziellen F&auml;llen kann es jedoch erw&uuml;nscht sein, dass einzelne Pads dies nicht tun.
Die objgen <tt>NO...</tt>-Flags k&ouml;nnen benutzt werden um diese Eigenschaften zu
unterdr&uuml;cken.<br>
Falls die <a href=#139>Design Rules</a> eines Boards definieren, dass
das "erste Pad" eines Bauteils in einer speziellen Form dargestellt werden soll, so
wird das mit <tt>FIRST</tt> markierte Pad auf diese Weise dargestellt.<br>
Ein neu gestarteter PAD-Befehl setzt alle Flags auf ihre Standardwerte zur&uuml;ck.
Sobald ein Flag in der Kommandozeile angegeben wird, gilt es f&uuml;r alle nachfolgend
in diesem PAD-Befehl plazierten Pads (ausgenommen <tt>FIRST</tt>, welches nur f&uuml;r
das unmittelbar dieser Option folgende Pad gilt).
<h2>Einzelne Pads</h2>
Einzelne Pads in Platinen m&uuml;ssen als Package definiert und in
die Platine geladen werden. Durchkontaktierungen lassen sich aber
mit dem VIA-Befehl direkt in Platinen plazieren. Solche Durchkontaktierungen
haben aber keinen Elementnamen und k&ouml;nnen deshalb auch nicht in
der Netzliste gef&uuml;hrt werden.


<a name=78>
<h1>PASTE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Inhalt der Zwischenablage oder einer Zeichnungsdatei einf&uuml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>PASTE [ orientation ] &#149;</tt><br>
<tt>PASTE [ orientation ] [ offset ] filename &#149;</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> spiegelt den Inhalt der Zwischenablage.<br>
<mb>Rechte</mb> dreht den Inhalt der Zwischenablage.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#43>CUT</a>,
<a href=#42>COPY</a>,
<a href=#56>GROUP</a>
<p>
Zu <tt>orientation</tt> siehe <a href=#30>ADD</a>-Befehl.
<p>
Mit CUT und PASTE lassen sich Teile einer Zeichnung/Bibliothek kopieren,
auch in eine andere Zeichnung/Bibliothek.
<p>
Dabei ist folgendes zu beachten:
<ul>
<li>Von und nach Devices ist kein CUT/PASTE m&ouml;glich.
<li>Elemente und Signale k&ouml;nnen nur von Platine zu Platine kopiert werden.
<li>Parts, Busse und Netze k&ouml;nnen nur von Schaltplan zu Schaltplan kopiert werden.
<li>Pads und Smds k&ouml;nnen nur von Package zu Package kopiert werden.
<li>Pins k&ouml;nnen nur von Symbol zu Symbol kopiert werden.
<li>Parts, Elemente, Signale, Pads, Smds und Pins erhalten einen neuen Namen, falls ihr bisheriger Name in der neuen Zeichnung (bzw. im Symbol oder Package) schon existiert.
<li>Busse behalten ihren Namen.
<li>Netze behalten ihren Namen, falls es ein Label oder ein Supply-Symbol an einem der Netz-Segmente gibt. Andernfalls wird ein neuer Name generiert, sofern der bisherige Name schon vorhanden ist.
</ul>
Befinden sich in der mit PASTE einzuf&uuml;genden Zeichnung modifizierte Devices oder Packages,
die in einer &auml;lteren Version schon im Schaltplan oder im Layout verwendet wurden, wird
automatisch ein <a href=#106>Library-Update</a> gestartet, um die Bauteile
durch die neueren aus der Zwischenablage zu ersetzen.<br>
<b>Achtung: Nach einem Library-Update sollten Sie immer einen <a href=#48>Design Rule Check</a> (DRC)
und einen <a href=#50>Electrical Rule Check</a> (ERC) durchf&uuml;hren!</b>
<h2>Eine komplette Datei einf&uuml;gen</h2>
Wird ein Dateiname in der Befehlszeile angegeben, so wird der gesamte Inhalt
dieser Datei in die geladene Zeichnung eingef&uuml;gt. Ist die angegebene Datei
Teil eines konsistenten Board/Schaltplan-Paares, so werden beide Dateien in
die jeweilige Zeichnung des gerade bearbeiteten Projekts eingef&uuml;gt.
Setzen Sie <tt>*</tt> anstelle des Dateinamens oder geben nur ein Verzeichnis an,
&ouml;ffnet sich ein File-Dialog im Projektverzeichnis bzw. angegebenen Verzeichnis.
<p>
Angenommen, Sie haben ein konsistentes Board/Schaltplan-Paar, welches das
Design eines Verst&auml;rkers enth&auml;lt (wobei der Schaltplan auch aus mehreren
Seiten bestehen kann). Wenn Sie jetzt diesen Verst&auml;rker mehrmals in Ihr
Projekt einf&uuml;gen wollen, k&ouml;nnen Sie dies einfach folgenderma&szlig;en erreichen:
<pre>
PASTE 100 amplifier.sch &#149;
PASTE 200 amplifier.sch &#149;
</pre>
Dieses Beispiel demonstriert auch die Verwendung eines <tt>offset</tt>,
wodurch der angegebene Wert zu allen Bauteil- und Netznamen hinzuaddiert wird
(es sei denn, sie behalten ihren urspr&uuml;nglichen Namen, siehe unten).
Somit werden im ersten Verst&auml;rkerkanal alle Bauteile und Netze beginnend bei
100 numeriert, w&auml;hrend sie im zweiten Kanal bei 200 beginnen. Wird kein Offset
angegeben, so werden Namen nach Bedarf generiert.
<p>
Wie bei einer normalen PASTE-Operation auch, behalten Netze beim Einf&uuml;gen einer
kompletten Datei ihren Namen, wenn sie mit einem Label versehen oder an einem
Supply-Pin angeschlossen sind. Dabei reicht es, wenn das Netz auf einer
Schaltplanseite ein Label hat bzw. an einen Supply-Pin angeschlossen ist,
auch wenn das Netz auf mehreren Seiten vorkommt.
<p>
Wird die PASTE-Operation nicht in einer Script-Datei ausgef&uuml;hrt, so wird Ihnen ein
Dialog mit allen Netznamen angeboten. Durch Klicken auf die Namen in der Spalte
"Neuer Name" k&ouml;nnen Sie einzelne Netznamen editieren. Icons zeigen an, ob ein Netz
ein Label oder einen Supply-Pin hat, und ob es mit einem bestehenden Netz gleichen
Namens in der geladenen Zeichnung verbunden wird.
<p>
Wird ein Schaltplan in eine Schaltplan-Zeichnung eingef&uuml;gt, so werden alle
Seiten des eingef&uuml;gten Schaltplans als separate, neue Seiten zu der editierten
Zeichnung hinzugef&uuml;gt (was in der <a href=#378>Light Edition</a>
nicht m&ouml;glich ist, da diese nur eine einzelne Schaltplanseite bearbeiten kann).
Das zugeh&ouml;rige Board (falls vorhanden) wird unterhalb des Inhalts des editierten
Boards platziert. Falls Sie genau kontrollieren wollen, wohin das Board platziert
wird, k&ouml;nnen Sie die PASTE-Operation auch im Board-Editor ausf&uuml;hren. Hierbei
werden die Schaltplanseiten genauso hinzugef&uuml;gt, aber das Board wird an den
Mauszeiger geh&auml;ngt und kann wie gew&uuml;nscht platziert werden.
<p>
Bez&uuml;glich globaler Einstellungen in den Dateien wie Layer, Netzklassen, Designregeln
und Autorouter-Parameter gilt: Die Einstellungen der aktuell ge&ouml;ffneten Zeichnung behalten
ihre G&uuml;ltigkeit. Das hei&szlig;t zum Beispiel, dass bei den eingef&uuml;gten Daten
die Restring-Parameter der aktuellen Zeichnung verwendet werden,
so dass sich Pads oder Vias von der Quelldatei unterscheiden k&ouml;nnen.
Auch hierbei ist ein <a href=#48>DRC</a> sehr zu empfehlen.<br>
Zus&auml;tzliche Einstellungen wie zus&auml;tzliche Layer oder Netzklassen werden
nat&uuml;rlich hinzugef&uuml;gt.
<p>
Das Einf&uuml;gen einer kompletten Datei kann auch mit <i>Drag&amp;Drop</i> geschehen,
wenn dabei die <tt>Ctrl</tt>-Taste gedr&uuml;ckt wird.
<p>
Falls der Dateiname mit einer Orientierung oder einem Offset verwechselt
werden k&ouml;nnte, schlie&szlig;en Sie ihn in Hochkommas ein.


<a name=79>
<h1>PIN</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Anschlusspunkte in Symbolen definieren.
<dt>
<b>Syntax</b>
<dd>
<tt>PIN 'name' options &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Rechte</mb> dreht den Pin.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#72>NAME</a>,
<a href=#98>SHOW</a>,
<a href=#37>CHANGE</a>
<h2>Options</h2>
Die options teilen sich in folgende Gruppen auf:
<p>
Direction<br>
Function<br>
Length<br>
Orientation<br>
Visible<br>
Swaplevel
<h3>Direction</h3>
Die logische Richtung des Signalflusses. Sie ist f&uuml;r den Electrical
Rule Check (siehe ERC-Befehl) und f&uuml;r die automatische Verdrahtung
der Stromversorgungs-Pins von Bedeutung. M&ouml;glich sind:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>NC   </td><td width=20><td>not connected</td></tr>
<tr><td>In   </td><td width=20><td>Eingang</td></tr>
<tr><td>Out  </td><td width=20><td>Ausgang (totem-pole)</td></tr>
<tr><td>IO   </td><td width=20><td>Ein-/Ausgang (bidirektional)</td></tr>
<tr><td>OC   </td><td width=20><td>Open Collector oder Open Drain</td></tr>
<tr><td>Hiz  </td><td width=20><td>High-Impedance(3-State)-Ausgang</td></tr>
<tr><td>Pas  </td><td width=20><td>passiv (f&uuml;r Widerst&auml;nde, Kondensatoren etc.)</td></tr>
<tr><td>Pwr  </td><td width=20><td>Power-Pin (Vcc, Gnd, Vss ...), Stromversorgungs-Eingang</td></tr>
<tr><td>Sup  </td><td width=20><td>Stromversorgungs-Ausgang, z.B. Massesymbol.</td></tr>
</table>
<p>
Default: IO
<p>
Wenn Pwr-Pins in einem Symbol vorhanden sind und im Schaltplan ein
entsprechender Sup-Pin existiert, werden die Netze automatisch
eingef&uuml;gt. Sup-Pins werden nicht in Bauelementen verwendet.
<h3>Function</h3>
Die grafische Darstellung des Pins. M&ouml;glich sind:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>None    </td><td width=20><td>keine spezielle Funktion</td></tr>
<tr><td>Dot     </td><td width=20><td>Invertier-Symbol</td></tr>
<tr><td>Clk     </td><td width=20><td>Taktsymbol</td></tr>
<tr><td>DotClk  </td><td width=20><td>Invertiertes Taktsymbol</td></tr>
</table>
<p>
Default: None
<h3>Length</h3>
Die L&auml;nge des Pin-Symbols. M&ouml;glich sind:
<p>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Point   </td><td width=20><td>Pin wird ohne Linie und Beschriftung dargestellt</td></tr>
<tr><td>Short   </td><td width=20><td>Linie ist 0.1 Zoll lang</td></tr>
<tr><td>Middle  </td><td width=20><td>Linie ist 0.2 Zoll lang</td></tr>
<tr><td>Long    </td><td width=20><td>Linie ist 0.3 Zoll lang</td></tr>
</table>
<p>
Default: Long
<h3>Orientation</h3>
Die Lage des Pins. Beim Plazieren lassen sich Pins mit der rechten
Maustaste rotieren. Der Parameter "orientation" ist f&uuml;r
die textuelle Eingabe des Pin-Befehls erforderlich, z. B. in Script-Dateien.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>R0    </td><td width=20><td>Pin-Symbol rechts</td></tr>
<tr><td>R90   </td><td width=20><td>Pin-Symbol oben</td></tr>
<tr><td>R180  </td><td width=20><td>Pin-Symbol links</td></tr>
<tr><td>R270  </td><td width=20><td>Pin-Symbol unten</td></tr>
</table>
<p>
Default: R0
<h3>Visible</h3>
Dieser Parameter bestimmt, ob der Pin- und/oder Pad-Name im Schaltplan
sichtbar sein soll.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Both   </td><td width=20><td>Pin- und Pad-Name sind im Schaltplan sichtbar</td></tr>
<tr><td>Pad    </td><td width=20><td>nur der Pad-Name ist im Schaltplan sichtbar</td></tr>
<tr><td>Pin    </td><td width=20><td>nur der Pin-Name ist im Schaltplan sichtbar</td></tr>
<tr><td>Off    </td><td width=20><td>weder Pin- noch Pad-Name im Schaltplan sichtbar</td></tr>
</table>
<p>
Default: Both
<h3>Swaplevel</h3>
Eine ganze Zahl. Die Zahl 0 bedeutet, dass der Pin nicht
gegen einen anderen desselben Gates ausgetauscht werden darf. Jede
Zahl, die gr&ouml;&szlig;er als 0 ist, bedeutet, dass der Pin mit
solchen Pins ausgetauscht werden kann, die den gleichen Swaplevel
haben und im selben Symbol definiert sind. Beispiel: Die Eingangs-Pins
eines NAND-Gatters k&ouml;nnen beide denselben Swaplevel bekommen,
da sie &auml;quivalent sind.
<p>
Default: 0
<h2>Anwendung des PIN-Befehls</h2>
Der PIN-Befehl dient dazu, in einem Symbol die Anschlusspunkte
f&uuml;r Netze (Pins) zu definieren. Pins werden im Symbols-Layer dargestellt.
Zus&auml;tzliche Informationen erscheinen im Pins-Layer. Mit den options
lassen sich jedem Pin individuelle Eigenschaften mitgeben. Die options
d&uuml;rfen in jeder beliebigen Reihenfolge eingegeben werden, man
kann sie aber auch ganz weglassen.
<p>
Gibt man im PIN-Befehl einen Namen an, dann muss er in Hochkommas
eingeschlossen sein. Pin-Namen kann man im Symbol-Editier-Modus mit
dem NAME-Befehl &auml;ndern.
<h2>Namen "hochz&auml;hlen"</h2>
Will man beispielsweise Pins mit den Namen D0 bis D7 in einem Symbol
plazieren, dann setzt man den ersten Pin mit dem Befehl
<pre>
PIN 'D0' &#149;
</pre>
und alle weiteren nur noch mit je einem Mausklick ab. Der numerische
Teil des Namens wird dann automatisch weitergez&auml;hlt.
<h2>Options mit CHANGE einstellen</h2>
Alle options lassen sich auch mit dem CHANGE-Befehl voreinstellen.
Sie bleiben so lange erhalten, bis sie entweder mit dem PIN- oder
dem CHANGE-Befehl wieder ge&auml;ndert werden.
<p>
Der SHOW-Befehl zeigt den Namen des Pins sowie Direction und
Swaplevel an.
<h2>Pin rotieren</h2>
Bewegt man einen Pin mit dem MOVE-Befehl, dann rotiert die rechte
Maustaste den Pin.
<h2>Gleiche Pin-Namen</h2>
Wenn Sie Bausteine definieren wollen, die mehrere Pins mit gleichem
Namen haben, dann gehen Sie folgenderma&szlig;en vor:
<p>
Drei Pins sollen z.B. GND hei&szlig;en. Sie geben den Pins bei der
Symbol-Definition die Namen GND@1, GND@2 und GND@3. Im Schaltplan sind
nur die Zeichen vor dem "@" sichtbar, und die Pins werden dort auch so
behandelt, als hie&szlig;en Sie GND.
<p>
Es ist nicht m&ouml;glich, in einem Symbol, das in einem Device verwendet
wird, nachtr&auml;glich einen Pin hinzuzuf&uuml;gen oder zu l&ouml;schen,
da dies die im Device definierten Pin-/Pad-Zuordnungen (CONNECT-Befehl)
ver&auml;ndern w&uuml;rde.
<h2>Pin-Beschriftung</h2>
Die Position der Pin- und Pad-Namen in einem Schaltplansymbol ist
relativ zum Pin-Aufh&auml;ngepunkt festgelegt und kann nicht ver&auml;ndert
werden. Ebenso ist die Schrifth&ouml;he f&uuml;r Pin- und Pad-Namen
fest eingestellt (60 Mil). Bitte orientieren Sie sich beim Definieren
neuer Symbole an den Gr&ouml;&szlig;enverh&auml;ltnissen der in den mitgelieferten
Bibliotheken vorhandenen Bausteine.
<h2>Negierte Pins</h2>
Der Name eines negierten Pins ("active low") kann &uuml;berstrichen dargestellt werden,
wenn ihm ein Ausrufezeichen (<tt>'!'</tt>) vorangestellt wird, wie in
<pre>
  !RESET
</pre>
was als
<pre>
  _____
  RESET
</pre>
dargestellt w&uuml;rde.
Einzelheiten hierzu finden Sie in der Beschreibung des <a href=#104>TEXT</a>-Befehls.


<a name=80>
<h1>PINSWAP</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Auml;quivalente Pins/Pads vertauschen.
<dt>
<b>Syntax</b>
<dd>
<tt>PINSWAP &#149; &#149;..</tt>
</dl>
<b>Siehe auch</b> <a href=#79>PIN</a>
<p>
In einem Schaltplan kann man mit diesem Befehl Pins vertauschen, die
zum selben Device geh&ouml;ren und bei der Symbol-Definition denselben
Swaplevel erhalten haben (Swaplevel &gt; 0). Swaplevel siehe PIN-Befehl.
Ist eine Platine &uuml;ber die
<a href=#372>Back-Annotation</a>
einem Schaltplan verbunden,
dann lassen sich Pads nur dann vertauschen, wenn die zugeh&ouml;rigen Pins
vertauscht werden k&ouml;nnen.
<p>
In einer Platine, zu der es keinen Schaltplan gibt, lassen sich mit
zwei Pads desselben Package vertauschen. Der Swaplevel
wird dabei nicht gepr&uuml;ft.
<p>
Die an den vertauschten Pads angeschlossenen Leitungen wandern
mit, so dass es zu Kurzschl&uuml;ssen kommen kann. Bitte DRC durchf&uuml;hren
und, falls erforderlich, Fehler korrigieren.


<a name=81>
<h1>POLYGON</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeichnen von Polygonfl&auml;chen.
<dt>
<b>Syntax</b>
<dd>
<tt>POLYGON [signal_name] [width] &#149; [curve | @radius] &#149; &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.<br>
<mb>Rechte</mb> &auml;ndert den Knickwinkel (siehe <a href=#97>SET Wire_Bend</a>).
<mb>Shift+Rechte</mb> kehrt die Richtung des Weiterschaltens des Knickwinkels um.<br>
<mb>Ctrl+Rechte</mb> schaltet zwischen korrespondierenden Knickwinkeln hin und her.<br>
<mb>Ctrl+Linke</mb> beim Absetzen eines Wire-Endpunktes definiert den Kreisbogen-Radius.<br>
<mb>Linke</mb> zweimal an der gleichen Stelle schlie&szlig;t das Polygon.
</dl>
<b>Siehe auch</b> <a href=#37>CHANGE</a>,
<a href=#44>DELETE</a>,
<a href=#86>RATSNEST</a>,
<a href=#92>RIPUP</a>,
<a href=#112>WIRE</a>,
<a href=#69>MITER</a>
<p>
Der POLYGON-Befehl dient zum Zeichnen von Polygonfl&auml;chen. Polygone
in den Layern Top, Bottom und Route2..15 werden als Signale behandelt.
Polygone in den Layern t/b/vRestrict sind Sperrfl&auml;chen f&uuml;r den Autorouter.
<p>
Wird der <i>curve</i> oder <i>@radius</i> Parameter angegeben, so kann ein Kreisbogen als Teil der Polygondefinition
gezeichnet werden (siehe die ausf&uuml;hrliche Beschreibung beim <a href=#112>WIRE</a>-Befehl).
<h2>Anmerkung</h2>
Sie sollten es vermeiden, sehr kleine Werte f&uuml;r die <i>width</i> eines
Polygons zu verwenden, da dies zu extrem gro&szlig;en Datenmengen f&uuml;hren kann,
wenn die Zeichnung mit dem <a href=#119>CAM Prozessor</a>
ausgegeben wird.<br>
Die Polygon-<i>width</i> sollte immer gr&ouml;&szlig;er sein als die physikalische
Aufl&ouml;sung des Ausgabeger&auml;ts. Zum Beispiel sollte bei einem Gerber
Fotoplotter mit einer typischen Aufl&ouml;sung von 1 Mil die Polygon <i>width</i>
nicht kleiner als zum Beispiel 6 Mil gew&auml;hlt werden. Im allgemeinen sollte
die Polygon <i>width</i> in der selben Gr&ouml;&szlig;enordnung liegen wie die
der &uuml;brigen Wires.
<p>
Falls Sie dem Polygon einen Namen geben wollen, der mit einer Ziffer beginnt
(zum Beispiel <tt>0V</tt>), so m&uuml;ssen Sie diesen Namen in Hochkommas einschlie&szlig;en,
um ihn von einem <i>width</i>-Wert zu unterscheiden.
<p>
Die Parameter <tt>Isolate</tt> und <tt>Rank</tt> sind nur f&uuml;r Polygone in den Signallayern
Top...Bottom relevant.
<h2>Urzustand und freigerechneter Zustand</h2>
F&uuml;r Polygone, die Bestandteil eines Signals sind, gibt es zwei verschiedene
Zust&auml;nde:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>1.&nbsp;Outlines:   </td><td width=20><td>"Urzustand", also die Form in der sie vom Benutzer definiert worden sind (Umrisslinien)</td></tr>
<tr><td>2.&nbsp;Real&nbsp;mode:  </td><td width=20><td>"freigerechneter" Zustand, also die Form wie sie vom Programm berechnet wird.</td></tr>
</table>
<p>
Im "Urzustand" werden Polygone mit gepunkteten Wires dargestellt, um sie von
anderen Wires unterscheiden zu k&ouml;nnen.
In der Board-Datei (name.brd) ist nur der Urzustand abgespeichert.
<p>
Standardm&auml;&szlig;ig werden alle Polygone am Bildschirm im Urzustand
dargestellt, da das Freirechnen ein rechenintensiver und damit
zeitaufwendiger Vorgang ist. Es werden dabei nur die vom Benutzer
definierten Umrisslinien dargestellt.
<p>
Bei der Ausgabe mit dem CAM-Prozessor werden auf jeden Fall alle
Polygone freigerechnet.
<p>
Das Freirechnen der Polygone wird mit dem
<a href=#86>RATSNEST</a>-Befehl ausgel&ouml;st
(mit <tt><a href=#97>SET</a> POLYGON_RATSNEST OFF;</tt> kann das
verhindert werden).
Ein Klick auf das Stop-Icon bricht das Freirechnen ab.
Alle bis dahin freigerechneten Polygone liegen dann im freigerechneten Zustand vor,
alle anderen (auch das gerade in der Berechnung befindliche!) liegen
im Urzustand vor.
<p>
Ein freigerechnetes Polygon kann durch Anklicken mit dem
<a href=#92>RIPUP</a>-Befehl
wieder in den Urzustand zur&uuml;ckversetzt werden.
<p>
Bei CHANGE-Operationen wird ein Polygon neu freigerechnet, wenn es vor
dem CHANGE bereits freigerechnet war.
<h2>Andere Befehle und Polygone</h2>
Polygone werden an den Kanten selektiert (wie normale Wires)
<p>
SPLIT: f&uuml;gt neue Polygonkanten ein.
<p>
DELETE: l&ouml;scht eine Polygon-Ecke (falls nur noch drei Ecken vorhanden
sind, wird das ganze Polygon gel&ouml;scht).
<p>
CHANGE LAYER: &auml;ndert den Layer des gesamten Polygons.
<p>
CHANGE WIDTH: &auml;ndert den Parameter Width des gesamten Polygons.
<p>
MOVE: bewegt Polygonkante oder -ecke (wie bei normalen Wire-Z&uuml;gen).
<p>
COPY: kopiert ganzes Polygon.
<p>
NAME: Falls das Polygon in einem Signal-Layer liegt, wird der Name
des Signals ge&auml;ndert.
<h2>Polygon-Parameter</h2>
<h3>Width</h3>
Linienbreite der Polygonkanten. Wird auch zum Ausf&uuml;llen
verwendet.
<h3>Layer</h3>
Polygone k&ouml;nnen in jeden Layer gezeichnet werden.
Polygone in Signal-Layern sind Bestandteil eines Signals und werden
'freigestellt', d.h. potentialfremde Anteile werden 'abgezogen'.
Polygone in Signallayern geh&ouml;ren zu einem Signal und halten Mindestabst&auml;nde zu anderen
Signalen, die in den Design Rules oder &uuml;ber die Netzklasse definiert wurden, ein.
Von Polygonen im Top-Layer werden auch Objekte im Layer tRestrict
abgezogen (entsprechendes gilt f&uuml;r Bottom und bRestrict). Damit ist es
z. B. m&ouml;glich, eine negative Beschriftung innerhalb einer Massefl&auml;che
zu erzeugen.
<h3>Pour</h3>
F&uuml;llmodus (Solid = ganz gef&uuml;llt [Default], Hatch = schraffiert oder Cutout = Ausschnitt).
<h3>Rank</h3>
Legt fest wie Polygone voneinander subtrahiert werden. Polygone mit einem
niedrigeren 'Rank' "erscheinen zuerst" (haben eine h&ouml;here Priorit&auml;t) und werden somit
von Polygonen mit einem h&ouml;heren 'Rank' abgezogen.<br>
G&uuml;ltige Werte sind <tt>1..6</tt>.
Polygone mit gleichem Rank werden vom <a href=#48>Design Rule Check</a> gegeneinander
gepr&uuml;ft. Der Parameter 'Rank' ist nur f&uuml;r Polygone in Signallayern (<tt>1..16</tt>) relevant,
die im Board gezeichnet wurden,
und wird f&uuml;r alle anderen Polygone ignoriert. Der Standardwert ist <tt>1</tt>.
<h3>Thermals</h3>
Bestimmt wie potentialgleiche Pads und Smds angeschlossen werden
(On = es werden Thermals generiert [default], Off = keine Thermals).
<h3>Spacing</h3>
Abstand der F&uuml;ll-Linien bei Pour=Hatch (Default:
50 Mil).
<h3>Isolate</h3>
Abstand der freigestellten Polygonkanten zu potentialfremdem
Kupfer bzw. Objekten im Dimension-Layer (default: 0). Dieser Wert ist nur dann
ma&szlig;geblich, wenn er gr&ouml;&szlig;er ist als der jeweilige Wert in den Design Rules bzw. Netzklassen.
Siehe auch <a href=#139>Design Rules</a> unter <b>Distance</b> bzw. <b>Supply</b>.
<b>Bitte beachten Sie, dass, wenn Sie einem Polygon einen Isolationsabstand geben,
der gr&ouml;&szlig;er ist als der aus den Design Rules bzw. Netzklassen, kleine L&uuml;cken
entstehen k&ouml;nnen zwischen dem freigerechneten Polygon und Objekten, die zum
gleichen Signal geh&ouml;ren wie das Polygon selber, was zu Problemen bei der
Fertigung f&uuml;hren kann! Es wird daher empfohlen, diesen Parameter auf dem Wert 0
zu belassen, es sei denn, Sie wissen genau, was Sie tun!</b>
<h3>Orphans</h3>
Beim Freistellen von Polygonen kann es passieren,
dass das urspr&uuml;ngliche Polygon in mehrere Teile zerf&auml;llt.
Falls sich in einem solchen Teil kein Aufh&auml;ngepunkt eines Objektes des zugeh&ouml;rigen
Signals befindet, entsteht eine 'Insel' ohne elektrische Verbindung
zum zugeh&ouml;rigen Signal. Sollen solche Inseln (oder 'verwaiste'
Fl&auml;chen) erhalten bleiben, ist der Parameter Orphans auf
On zu setzen. Bei Orphans&nbsp;=&nbsp;Off [default] werden sie eliminiert.
Besteht ein Signal nur aus Polygonen und hat keine anderen, elektrisch angeschlossenen
Objekte, so werden alle Teile unabh&auml;ngig von der Einstellung des Parameters Orphans
dargestellt.
<p>
Unter gewissen Umst&auml;nden, insbesondere mit Orphans&nbsp;=&nbsp;Off, kann ein
Polygon vollst&auml;ndig verschwinden.
In diesem Fall werden auf dem Bildschirm die Linien im Urzustand
dargestellt um es dem Benutzer zu erm&ouml;glichen, das Polygon zu l&ouml;schen
oder anderweitig zu ver&auml;ndern.
Mit dem Drucker oder dem CAM-Prozessor werden diese Linien nicht ausgegeben,
um keine Kurzschl&uuml;sse zu verursachen.
Ein Polygon wird auch dann in seinem Urzustand dargestellt, wenn das Signal
andere nicht-Polygon-Objekte enth&auml;lt, von denen keines mit dem Polygon verbunden
ist.
<h2>Stegbreite bei Thermals</h2>
Die Breite der Stege bei Thermals ist:
<ul>
<li>bei Pads gleich dem halben Bohrdurchmesser des Pads,
<li>bei Smds gleich der H&auml;lfte der kleineren Kante,
<li>mindestens gleich der Linienbreite (Width) des Polygons,
<li>maximal zweimal die Linienbreite (Width) des Polygons.
</ul>
<h2>Konturdaten</h2>
Der Signalname _OUTLINES_ gibt dem Polygon besondere Eigenschaften,
die man zur Erzeugung von <a href=#136>Konturdaten</a> (z. B.
zum Fr&auml;sen von Prototypen) ben&ouml;tigt. Dieser Name sollte ansonsten nicht
verwendet werden.
<h2>Schraffierte Polygone und Luftlinien</h2>
Abh&auml;ngig vom Wert des <i>spacing</i>-Parameters k&ouml;nnen Pads, Smds, Vias und Wires
innerhalb eines schraffierten Polygons, die zum selben Signal geh&ouml;ren wie das
Polygon, durch das Raster fallen, und erhalten daher Luftlinien um Ihre Verbindung
zu dem Signal anzuzeigen.
<p>
Bei der Beurteilung, ob ein solches Objekt tats&auml;chlich eine solide Verbindung
zum schraffierten Polygon hat, wird das Objekt auf einige "Kontrollpunkte" reduziert.
F&uuml;r ein rundes Pad w&auml;ren das zum Beispiel der n&ouml;rdliche, &ouml;stliche, westliche
und s&uuml;dliche Punkt auf seinem Umfang. F&uuml;r einen Wire w&auml;ren es seine beiden
Endpunkte. Eine solide Verbindung besteht dann, wenn es im berechneten Polygon
mindestens eine Linie (Umri&szlig;- oder Schraffurlinie) gibt, deren Mittellinie durch
diese Punkte verl&auml;uft.
<p>
Thermal- und Annulus-Ringe innerhalb eines schraffierten Polygons, die
keinen soliden Kontakt zu den Polygon-Linien haben, werden nicht erzeugt.
<h2>Polygon-Ausschnitte</h2>
Der spezielle F&uuml;llmodus "Cutout" bewirkt, dass ein Polygon von allen anderen
Signal-Polygonen im gleichen Layer subtrahiert wird, unabh&auml;ngig von deren Rank.
<p>
Nur Polygone in Signal-Layern k&ouml;nnen den F&uuml;llmodus "Cutout" haben.
<p>
Die Umrisse eines Ausschnitt-Polygons werden auf dem Bildschirm immer als
gepunktete Linien dargestellt, auch nachdem die Signal-Polygone mit dem
<a href=#86>RATSNEST</a>-Befehl freigerechnet wurden.
<p>
Die Wire-Breite eines Ausschnitts-Polygons wird beim Sutrahieren von den anderen
Signal-Polygonen ber&uuml;cksichtigt. Sie kann beliebig klein sein (auch Null), ohne
dass gro&szlig;e CAM-Datenmengen verursacht werden (anders als bei "Solid"-Polygonen,
bei denen die Wire-Breite nicht zu klein gew&auml;hlt werden sollte).


<a name=82>
<h1>PORT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Hinzuf&uuml;gen von Ports zu Modulen.
<dt>
<b>Syntax</b>
<dd>
<tt>PORT 'module_instance_name' 'net_name' options &#149;..</tt><br>
<tt>PORT 'module' 'net_name' options &#149;..</tt><br>
<tt>PORT 'module' 'net_name' options|DELETE</tt><br>
</tt>
</dl>
<b>Siehe auch</b> <a href=#70>MODULE</a>
<p>
Der <tt>PORT</tt>-Befehl wird verwendet, um in hierarchischen Schaltpl&auml;nen Ports zu
Modulen hinzuzuf&uuml;gen.
<p>
Die Lage und Orientierung werden bezogen auf die n&auml;chstgelegene Modulseite automatisch
ermittelt.
<p>
Ein Port kann ein Netz eines Moduls exportieren und stellt einen Anschlusspunkt f&uuml;r ein
weiteres Netz zur Verf&uuml;gung. Ein dort angeschlossenes Netz stellt den Namen und die
Netzklasse zur Verf&uuml;gung.
Name und Klasse des Netzes im Modul werden also damit &uuml;berschrieben.
<p>
Ein Port mit einem Bus-Namen exportiert alle diese Netze auf einmal und
stellt einen Anschlusspunkt f&uuml;r einen passenden Bus zur Verf&uuml;gung.
<h2>Namen</h2>
Durch den gew&auml;hlten Namen wird bestimmt, welches Netz des Moduls exportiert wird.
Der Name kann auch ein einfacher Bus-Name sein, wie z.B. 'PA[0..7]'.
<h2>Options</h2>
<h3>Direction</h3>
Die logische Richtung des Signalflusses. Sie ist f&uuml;r den Electrical
Rule Check (siehe ERC-Befehl) von Bedeutung. M&ouml;glich sind:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>NC   </td><td width=20><td>not connected</td></tr>
<tr><td>In   </td><td width=20><td>Eingang</td></tr>
<tr><td>Out  </td><td width=20><td>Ausgang (totem-pole)</td></tr>
<tr><td>IO   </td><td width=20><td>Ein-/Ausgang (bidirektional)</td></tr>
<tr><td>OC   </td><td width=20><td>Open Collector oder Open Drain</td></tr>
<tr><td>Hiz  </td><td width=20><td>High-Impedance(3-State)-Ausgang</td></tr>
<tr><td>Pas  </td><td width=20><td>passiv (f&uuml;r Widerst&auml;nde, Kondensatoren etc.)</td></tr>
<tr><td>Pwr  </td><td width=20><td>Power-Pin (Vcc, Gnd, Vss ...), Stromversorgungs-Eingang</td></tr>
</table>
<p>
Default: IO
<p>
Die Direction von bereits vorhandenen Ports kann hiermit auch ver&auml;ndert werden.
<h3>DELETE</h3>
Mit DELETE kann ein Port gel&ouml;scht werden.
<h2>Editieren</h2>
Der <a href=#71>MOVE</a>-Befehl kann zum Verschieben von Ports verwendet werden.
Mit <mb>Ctrl+Linke</mb> lassen sich die Ports an ihrem Verbindungs-Punkt selektieren
und entlang des Randes der Modul-Instanz verschieben.
<p>
Der <a href=#59>INFO</a>-Befehl kann verwendet werden, um die Eigenschaften
von Ports zu ver&auml;ndern. Hierzu erfolgt die Selektion ebenfalls mit <mb>Ctrl+Linke</mb>.
<p>
Bei angeschlossenem Netz kann die Selektion mehrdeutig sein. Benutzen Sie hierbei bitte
<mb>Ctrl+Rechte</mb> um zum gew&uuml;nschtem Objekt (in dem Fall Port) zu schalten.


<a name=83>
<h1>PREFIX</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Pr&auml;fix f&uuml;r Schaltzeichen oder ein Modul festlegen.
<dt>
<b>Syntax</b>
<dd>
<tt>PREFIX prefix_string;</tt>
</dl>
<b>Siehe auch</b> <a href=#41>CONNECT</a>,
<a href=#70>MODULE</a>,
<a href=#76>PACKAGE</a>,
<a href=#108>VALUE</a>
<p>
Dieser Befehl wird im Device-Editier-Modus angewendet. Er legt fest,
mit welchem Zeichen oder welcher Zeichenfolge der automatisch
vergebene Name beginnen soll, wenn das Element mit dem ADD-Befehl
im Schaltplan plaziert wird.
<p>
Wenn ein Modul editiert wird, kann dieser Befehl zum &Auml;ndern des Pr&auml;fix des
Moduls verwendet werden.
<h2>Beispiel</h2>
<pre>
PREFIX U;
</pre>
Wird dieser Befehl ausgef&uuml;hrt, w&auml;hrend man das Device 7400
editiert, dann bekommen sp&auml;ter die mit ADD im Schaltplan plazierten
NAND-Gatter die Namen U1, U2, U3 und so weiter. Diese Namen lassen
sich mit dem NAME-Befehl &auml;ndern.


<a name=84>
<h1>PRINT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Druckt eine Zeichnung auf dem System-Drucker aus.
<dt>
<b>Syntax</b>
<dd>
<tt>PRINT [factor] [-limit] [options] [;]</tt>
</dl>
<b>Siehe auch</b> <a href=#119>CAM-Prozessor</a>,
<a href=#115>Drucken auf dem System-Drucker</a>
<p>
Der PRINT-Befehl druckt die gerade editierte Zeichnung auf dem
System-Drucker aus.
<p>
Farben und F&uuml;llmuster werden aus dem Editor-Fenster &uuml;bernommen, falls
nicht die Optionen <tt>SOLID</tt> oder <tt>BLACK</tt> angegeben werden.
Als Farbpalette wird beim Ausdruck immer diejenige f&uuml;r wei&szlig;en Hintergrund verwendet.
<p>
Wenn Sie Pads und Vias "ausgef&uuml;llt" drucken wollen (ohne sichtbare Bohrl&ouml;cher),
benutzen Sie den Befehl
<pre>
<a href=#97>SET</a> DISPLAY_MODE NODRILL;
</pre>
<b>Bitte beachten Sie, dass Polygone in Platinen beim Ausdrucken mit dem
PRINT-Befehl nicht automatisch freigerechnet werden! Es werden lediglich die
Umrisse dargestellt. Um die Polygone freigerechnet auszudrucken f&uuml;hren Sie
bitte vorher den <a href=#86>RATSNEST</a>-Befehl aus</b>.
<p>
Es kann ein <tt>factor</tt> angegeben werden um die Ausgabe zu skalieren.
<p>
Mit dem Parameter <tt>limit</tt> kann die maximale Anzahl von Bl&auml;ttern
angegeben werden, die f&uuml;r die Ausgabe verwendet werden soll.
Diese Zahl muss mit einem vorangestellten <tt>'-'</tt> angegeben werden,
um sie vom <tt>factor</tt> unterscheiden zu k&ouml;nnen.
Sollte die Zeichnung nicht auf die vorgegebene Anzahl von Bl&auml;ttern passen,
so wird der <tt>factor</tt> so lange verkleinert, bis sie gerade noch passt.
Setzen Sie diesen Parameter auf <tt>-0</tt> um beliebig viele Bl&auml;tter zuzulassen
(und damit sicherzustellen, dass der Ausdruck genau mit dem angegebenen Faktor
skaliert wird).
<p>
Wird der PRINT-Befehl nicht mit einem <tt>';'</tt> abgeschlossen, so
erscheint ein <a href=#116>Druck-Dialog</a> in dem
alle Druck-Optionen eingestellt werden k&ouml;nnen.
Bitte beachten Sie, dass Optionen, die &uuml;ber die Kommandozeile eingegeben wurden,
nur dann dauerhaft in den Druckeinstellungen gespeichert werden, wenn sie &uuml;ber
den <a href=#116>Druck-Dialog</a> best&auml;tigt wurden (d.h. wenn der
Befehl nicht mit einem <tt>';'</tt> abgeschlossen wurde).
<p>
Folgende <tt>options</tt> stehen zur Verf&uuml;gung:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>MIRROR</tt>        </td><td width=20><td>spiegelt die Ausgabe</td></tr>
<tr><td><tt>ROTATE</tt>        </td><td width=20><td>dreht die Ausgabe um 90&deg;</td></tr>
<tr><td><tt>UPSIDEDOWN</tt>    </td><td width=20><td>dreht die Ausgabe um 180&deg;. Zusammen mit <tt>ROTATE</tt>, wird die Zeichnung um insgesamt 270&deg; gedreht</td></tr>
<tr><td><tt>BLACK</tt>         </td><td width=20><td>ignoriert die Farbeinstellungen der Layer und zeichnet alles in Schwarz</td></tr>
<tr><td><tt>SOLID</tt>         </td><td width=20><td>ignoriert die F&uuml;llmuster der Layer und zeichnet alles voll ausgef&uuml;llt</td></tr>
<tr><td><tt>CAPTION</tt>       </td><td width=20><td>druckt eine Bildunterschrift</td></tr>
<tr><td><tt>FILE</tt>          </td><td width=20><td>leitet die Ausgabe in eine Datei um; der Dateiname muss unmittelbar nach dieser Option folgen</td></tr>
<tr><td><tt>PRINTER</tt>       </td><td width=20><td>druckt auf einen bestimmten Drucker; der Druckername muss unmittelbar nach dieser Option folgen</td></tr>
<tr><td><tt>PAPER</tt>         </td><td width=20><td>druckt auf das angegebene Papierformat; das Papierformat muss unmittelbar nach dieser Option folgen</td></tr>
<tr><td><tt>SHEETS</tt>        </td><td width=20><td>druckt den angegebenen Bereich von Schaltplanseiten; der Bereich (von-bis) muss unmittelbar nach dieser Option folgen</td></tr>
<tr><td><tt>WINDOW</tt>        </td><td width=20><td>druckt den momentan sichtbaren Ausschnitt der Zeichnung</td></tr>
<tr><td><tt>PORTRAIT</tt>      </td><td width=20><td>druckt in Hochformat</td></tr>
<tr><td><tt>LANDSCAPE</tt>     </td><td width=20><td>druckt in Querformat</td></tr>
<tr><td><tt>HIERARCHY</tt>     </td><td width=20><td>druckt die Schaltplanseiten von Modulen in ihrer hierarchischen Verwendung</td></tr>
</table>
<p>
Wird einer der <tt>options</tt> <tt>MIRROR</tt>...<tt>CAPTION</tt> ein <tt>'-'</tt> vorangestellt, so wird diese Option ausgeschaltet,
falls sie zur Zeit eingeschaltet ist (von einem vorhergehenden PRINT).
Ein <tt>'-'</tt> allein schaltet alle <tt>options</tt> aus.
<h2>Drucken in eine Datei</h2>
Die <tt>FILE</tt> Option kann dazu benutzt werden in eine Datei zu drucken.
Falls diese Option angegeben wird, muss der Dateiname unmittelbar nach ihr folgen.
<p>
Hat der Dateiname die Extension <tt>".pdf"</tt> (wobei die Gro&szlig;-/Kleinschreibung keine Rolle spielt),
so wird eine PDF-Datei erzeugt. Eine PDF-Datei kann auch durch Auswahl von "In Datei drucken (PDF)"
aus der "Drucker" Combo-Box im <a href=#116>Druck-Dialog</a> erzeugt werden.
Texte in einer PDF-Datei k&ouml;nnen in einem PDF-Betrachter durchsucht werden, solange
sie nicht den Vektor-Font verwenden.
<p>
Hat der Dateiname die Extension <tt>".ps"</tt> (wobei die Gro&szlig;-/Kleinschreibung keine Rolle spielt),
so wird eine Postscript-Datei erzeugt.
<p>
Besteht der Dateiname nur aus einem <tt>"*"</tt> oder <tt>"*.ext"</tt> (ein Stern gefolgt von einer
Extension, wie etwa <tt>"*.pdf"</tt>), so wird ein Datei-Dialog ge&ouml;ffnet &uuml;ber den der Benutzer
den tats&auml;chlichen Dateinamen ausw&auml;hlen oder eingeben kann.
<p>
Besteht der Dateiname nur aus einer Extension, wie etwa <tt>".pdf"</tt>, so wird der Name
der Ausgabedatei aus dem Namen der Zeichnungsdatei gebildet, indem dessen Extension durch
den angegebenen String ersetzt wird.
<p>
Der Dateiname kann einen oder mehrere der folgenden Platzhalter enthalten, die
durch den entsprechenden Text ersetzt werden:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%E</tt>     </td><td width=20><td>die Extension der geladenen Datei (ohne den <tt>'.'</tt>)</td></tr>
<tr><td><tt>%N</tt>     </td><td width=20><td>der Name der geladenen Datei (ohne Pfad und Extension)</td></tr>
<tr><td><tt>%P</tt>     </td><td width=20><td>Verzeichnis-Pfad der geladenen Datei (ohne Dateinamen)</td></tr>
<tr><td><tt>%%</tt>     </td><td width=20><td>das Zeichen <tt>'%'</tt></td></tr>
</table>
<p>
Zum Beispiel w&uuml;rde der Dateiname
<p>
<tt>%N.cmp.pdf</tt>
<p>
den Namen <tt><i>boardname</i>.cmp.pdf</tt> erzeugen.
<p>
Wurde sowohl die <tt>FILE</tt> als auch die <tt>PRINTER</tt> Option angegeben, so wird
nur die zuletzt angegebene ber&uuml;cksichtigt.
<h2>Auf eine bestimmte Papiergr&ouml;&szlig;e drucken</h2>
Die <tt>PAPER</tt>-Option gibt an, auf welche Papiergr&ouml;&szlig;e gedruckt werden soll.
Ihr muss unmittelbar einer der Namen f&uuml;r Papiergr&ouml;&szlig;en folgen, die in der Combo-Box
<i>Papier</i> des Drucken-Dialogs aufgelistet sind, wie etwa <tt>A4</tt>, <tt>Letter</tt> etc.
Soll eine benutzerdefinierte Papiergr&ouml;&szlig;e benutzt werden, so muss diese im Format
<pre>
Breite x H&ouml;he Einheit
</pre>
(ohne Leerzeichen) angegeben werden, wie in
<pre>
PRINT PAPER 200x300mm
PRINT PAPER 8.0x11.5inch
</pre>
<i>Breite</i> und <i>H&ouml;he</i> k&ouml;nnen Dezimalzahlen sein, und die <i>Einheit</i>
ist entweder <tt>mm</tt> oder <tt>inch</tt> (letztere kann abgek&uuml;rzt werden als <tt>in</tt>).
Papiernamen m&uuml;ssen vollst&auml;ndig angegeben werden, wobei die Gro&szlig;-/Kleinschreibung keine Rolle spielt.
Wird sowohl die <tt>PRINTER</tt>- als auch die <tt>PAPER</tt>-Option benutzt, muss die <tt>PRINTER</tt>-Option
zuerst angegeben werden.
Benutzerdefinierte Papiergr&ouml;&szlig;en funktionieren nicht unbedingt mit allen Druckern. Sie sind haupts&auml;chlich
f&uuml;r die Ausgabe in Postscript- bzw. PDF-Dateien gedacht.
<h2>Einen Bereich von Schaltplanseiten drucken</h2>
Mit der <tt>SHEETS</tt> Option kann ein ausgew&auml;hlter Bereich von Schaltplanseiten
gedruckt werden.
Der Bereich wird in Form von zwei Zahlen angegeben, die durch <tt>'-'</tt>
getrennt werden, etwa <tt>2-15</tt>.
Ohne diese Option wird nur die aktuell im Editor befindliche Seite gedruckt.
Um alle Seiten auszudrucken, kann der Bereich <tt>ALL</tt> benutzt werden (wobei
Gro&szlig;-/Kleinschreibung egal ist, das Wort aber voll ausgeschrieben werden muss).
Ein Bereich kann auch aus einer einzelnen Zahl bestehen, etwa <tt>42</tt>, wodurch
genau diese Seite gedruckt wird.
Ist kein Schaltplan geladen, so hat diese Option keine Bedeutung.
<h2>Schaltplanseiten von Modulen drucken</h2>
Wenn die aktuelle Schaltplanseite zu einem Modul geh&ouml;rt, bezieht sich eine
Bereichsangabe auf dieses Modul.
Mit der Option <tt>SHEETS ALL</tt> werden alle Schaltplanseiten des
Hauptschaltplans und alle Schaltplanseiten aller Module gedruckt.
Mit der zus&auml;tzlichen Option <tt>HIERARCHY</tt> werden die Schaltplanseiten von
Modulen f&uuml;r jede Verwendung in Modulinstanzen mit entsprechenden Bauteil- und
Netznamen gedruckt.
<h2>Beispiele</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PRINT</tt>     </td><td width=20><td>&ouml;ffnet den <a href=#116>Print Dialog</a> f&uuml;r die Eingabe der Druckeinstellungen</td></tr>
<tr><td><tt>PRINT;</tt>    </td><td width=20><td>druckt die Zeichnung ohne weiteren Dialog, mit default Einstellungen</td></tr>
<tr><td><tt>PRINT - MIRROR BLACK SOLID;</tt>  </td><td width=20><td>druckt die Zeichnung gespiegelt, alles in Schwarz und voll ausgef&uuml;llt</td></tr>
<tr><td><tt>PRINT 2.5 -1;</tt>              </td><td width=20><td>druckt die Zeichnung um den Faktor 2.5 vergr&ouml;&szlig;ert, wobei aber sichergestellt wird, dass nicht mehr als <b>ein</b> Blatt verwendet wird</td></tr>
<tr><td><tt>PRINT FILE .pdf;</tt>           </td><td width=20><td>druckt die Zeichnung in eine PDF-Datei mit dem gleichen Namen wie die Zeichnungsdatei</td></tr>
<tr><td><tt>PRINT SHEETS 2-15 FILE .pdf;</tt> </td><td width=20><td>druckt die Seiten 2 bis 15 in eine PDF-Datei mit dem gleichen Namen wie die Zeichnungsdatei</td></tr>
</table>


<a name=85>
<h1>QUIT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Beendet die Arbeit mit EAGLE
<dt>
<b>Syntax</b>
<dd>
<tt>QUIT</tt>
</dl>
Dieser Befehl beendet die Arbeit mit EAGLE. Sind seit dem letzten
Abspeichern der Zeichnung oder der Bibliothek &Auml;nderungen vorgenommen
worden, erscheint ein Popup-Men&uuml;, das nachfragt, ob die die Zeichnung
vorher abgespeichert werden soll. Beantwortet man diese Frage mit
no (n), dann wird das Programm ohne Abspeichern der Zeichnung
beendet. Bei Cancel bleibt man im Programm.
<p>
Sie k&ouml;nnen das Programm von jeder Stelle aus mit <i>Alt+X</i> verlassen.


<a name=86>
<h1>RATSNEST</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Neuberechnen der Luftlinien und Polygone.
<dt>
<b>Syntax</b>
<dd>
<tt>RATSNEST</tt><br>
<tt>RATSNEST signal_name ..</tt><br>
<tt>RATSNEST ! signal_name ..</tt>
</dl>
<b>Siehe auch</b> <a href=#99>SIGNAL</a>,
<a href=#71>MOVE</a>,
<a href=#81>POLYGON</a>,
<a href=#92>RIPUP</a>
<p>
Der RATSNEST-Befehl berechnet die Luftlinien neu, damit man z. B.
nach einer &Auml;nderung der Bauelemente-Plazierung wieder die k&uuml;rzesten
Verbindungen erh&auml;lt. Auch nach dem Einlesen einer Netzliste (mit
dem SCRIPT-Befehl) ist es sinnvoll, den RATSNEST-Befehl aufzurufen,
da dabei im allgemeinen nicht die k&uuml;rzesten Luftlinien entstehen.
<p>
Der RATSNEST-Befehl berechnet auch alle Polygone neu, die zu einem
Signal geh&ouml;ren. Dies ist notwendig, damit f&uuml;r bereits durch
Polygonfl&auml;chen verbundene Pads keine Luftlinien mehr erzeugt werden.
Alle zugeh&ouml;rigen Polygonfl&auml;chen sind dann in realer Darstellung zu sehen.
Auf Umriss-Darstellung kann mit
dem RIPUP-Befehl gewechselt werden.
Die automatische Berechnung der Polygone kann mit
<pre>
<a href=#97>SET</a> POLYGON_RATSNEST OFF;
</pre>
ausgeschaltet werden.<br>
<p>
Beachten Sie bitte, dass RATSNEST die Board-Zeichnung nicht als ver&auml;ndert
kennzeichnet, da die berechneten Polygon-Daten (falls vorhanden) nicht
in der Datei abgespeichert werden, und die neuberechneten Luftlinien
keine wirkliche Ver&auml;nderung der Zeichnung darstellen.
<h2>Luftlinien der L&auml;nge Null</h2>
Enden zwei oder mehr Wires desselben Signals am selben Punkt, aber auf
unterschiedlichen Layern, und sind die Signale nicht &uuml;ber eine
Durchkontaktierung verbunden, dann wird eine
<i>Luftline der L&auml;nge Null</i> erzeugt und als X-f&ouml;rmiges Kreuz im Unrouted-Layer
dargestellt. Dasselbe gilt f&uuml;r gegen&uuml;berliegende SMDs (auf Top-
und Bottom-Layer), die zum selben Signal geh&ouml;ren.
<p>
Solche <i>Luftlinen der L&auml;nge Null</i> k&ouml;nnen mit dem
<a href=#94>ROUTE</a>-Befehl wie andere Luftlinien
angeklickt werden. Top- und Bottom-Seite k&ouml;nnen an diesen Stellen auch
durch Plazieren eines
<a href=#110>Vias</a> verbunden werden.
<h2>&Uuml;berpr&uuml;fen, ob alles geroutet ist</h2>
Wenn kein unverdrahtetes Signal mehr vorhanden ist, gibt der
RATSNEST-Befehl die Meldung
<pre>
Ratsnest: Nichts zu tun!
</pre>
aus. Andernfalls erscheint die Meldung
<pre>
Ratsnest: Luftlinien: xx
</pre>
wobei <tt>xx</tt> die Zahl der ungerouteten Luftlinien repr&auml;sentiert.
<h2>Platzhalter</h2>
Falls der <tt>signal_name</tt>-Parameter angegeben wurde, so sind die Zeichen <tt>'*'</tt>, <tt>'?'</tt>
und <tt>'[]'</tt> <i>Platzhalter</i> und haben folgende Bedeutung:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>*</tt>    </td><td width=20><td>steht f&uuml;r eine beliebige Anzahl beliebiger Zeichen</td></tr>
<tr><td><tt>?</tt>    </td><td width=20><td>steht f&uuml;r genau ein Zeichen</td></tr>
<tr><td><tt>[...]</tt></td><td width=20><td>steht f&uuml;r irgend eines der Zeichen zwischen den Klammern</td></tr>
</table>
<p>
Soll eines dieser Zeichen genau so gesucht werden, wie es ist, so muss es in eckige Klammern
eingeschlossen werden. Zum Beispiel findet <tt>abc[*]ghi</tt> die Zeichenfolge <tt>abc*ghi</tt>,
aber nicht <tt>abcdefghi</tt>.
<p>
Ein Bereich von Zeichen kann als <tt>[a-z]</tt> angegeben werden, was f&uuml;r eines der Zeichen
aus dem Bereich <tt>'a'</tt>...<tt>'z'</tt> steht.
<h2>Ausgew&auml;hlte Luftlinien ausblenden</h2>
Manchmal kann es sinnvoll sein, die Luftlinien von bestimmten Signalen auszublenden,
zum Beispiel wenn diese sp&auml;ter durch ein Polygon verbunden werden. Typischerweise
sind dies Versorgungssignale die viele Luftlinien haben, aber nicht explizit
geroutet werden, und so nur die Luftlinien anderer Signale verdecken.
<p>
Um Luftlinien auszublenden kann der RATSNEST-Befehl mit einem Ausrufezeichen
(<tt>'!'</tt>), gefolgt von einer Liste von Signalnamen, aufgerufen werden:
<pre>
RATSNEST ! GND VCC
</pre>
Hiermit w&uuml;rden die Luftlinien der Signale <tt>GND</tt> und <tt>VCC</tt> ausgeblendet.<br>
Um die Luftlinien wieder einzublenden geben Sie einfach den RATSNEST-Befehl ohne
das Zeichen <tt>'!'</tt> mit der Liste der Signale ein:
<pre>
RATSNEST GND VCC
</pre>
Damit wird die Anzeige der Luftlinien der Signale <tt>GND</tt> und <tt>VCC</tt>
aktiviert und diese auch gleich neu berechnet. Auf diese Weise lassen sich auch die
Luftlinien und Polygone nur f&uuml;r bestimmte Signale neu berechnen.
<p>
Die Signalnamen k&ouml;nnen Platzhalter enthalten, und die beiden Varianten k&ouml;nnen
kombiniert werden, wie in
<pre>
RATSNEST D* ! ?GND VCC
</pre>
womit die Luftlinien aller Signale, deren Namen mit <tt>'D'</tt> beginnen, neu
berechnet und angezeigt werden, und die Luftlinien der verschiedenen GND-Signale
(wie AGND, DGND etc.) und des VCC-Signals ausgeblendet werden. Beachten Sie, dass
der Befehl von links nach rechts abgearbeitet wird, so dass f&uuml;r den Fall, dass es
ein DGND-Signal gibt, dieses im Beispiel zuerst f&uuml;r die Anzeige neu berechnet wird,
seine Luftlinien dann aber ausgeblendet werden.
<p>
Ausgeblendete Luftlinien werden mit <a href=98>SHOW</a> nicht angezeigt
und k&ouml;nnen auch nicht selektiert werden.
<p>
Um sicherzustellen, dass alle Luftlinien eingeblendet sind, geben Sie ein
<pre>
RATSNEST *
</pre>
Beachten Sie, das der <a href=#99>SIGNAL</a>-Befehl automatisch die
Luftlinien eines Signals einblendet, wenn eine neue Luftlinie f&uuml;r dieses Signal
erzeugt wird. Der <a href=#92>RIPUP</a>-Befehl hingegen &auml;ndert nichts
an der Sichtbarkeit von Luftlinien, wenn ein Wire eines Signals in eine Luftlinie
verwandelt wird.
<h2>Differential Pairs</h2>
Luftlinien f&uuml;r Differential Pair Signale bevorzugen offene Wire-Enden.


<a name=87>
<h1>RECT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Rechteck in eine Zeichnung einf&uuml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>RECT [orientation] &#149; &#149;..  </tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.
</dl>
<b>Siehe auch</b> <a href=#38>CIRCLE</a>
<p>
Mit diesem Befehl zeichnet man Rechtecke in den aktiven Layer. Die
beiden Punkte legen gegen&uuml;berliegende Ecken des Rechtecks fest.
Die mittlere Maustaste wechselt den aktiven Layer.
<p>
Die <tt>orientation</tt> (siehe Beschreibung bei <a href=#30>ADD</a>)
darf jeder Winkel im Bereich <tt>R0</tt>...<tt>R359.9</tt> sein. Das <tt>S</tt>-
bzw. <tt>M</tt>-Flag kann hier nicht benutzt werden.
Beachten Sie bitte, dass die Koordinaten immer bezogen auf einen Winkel <tt>R0</tt>
angegeben werden. Die M&ouml;glichkeit der Eingabe eines Winkels beim RECT-Befehl
ist haupts&auml;chlich f&uuml;r die Benutzung in Scripts vorgesehen, wobei die Daten
des Rechtecks etwa durch ein User Language Programm aus dem
<a href=#212>UL_RECTANGLE</a>-Objekt ermittelt wurden.
Bei interaktiver Eingabe eines Winkels ungleich 0 kann es sein, dass die
Ecken des Rechtecks nicht an der aktuellen Position des Mauszeigers erscheinen.
Benutzen Sie den <a href=#93>ROTATE</a>-Befehl um ein Rechteck
interaktiv zu drehen.
<h2>Sperrfl&auml;chen</h2>
Der RECT-Befehl in den Layern tRestrict, bRestrict und
vRestrict dient zum Anlegen von Sperrfl&auml;chen
f&uuml;r den Autorouter.
<h2>Nicht Bestandteil von Signalen</h2>
Rechtecke in den Layer Top, Bottom oder Route2...15 geh&ouml;ren nicht zu Signalen.
Der DRC meldet deshalb Fehler, wenn sie mit
Wires, Pads usw. &uuml;berlappen.


<a name=88>
<h1>REDO</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Befehl erneut ausf&uuml;hren.
<dt>
<b>Syntax</b>
<dd>
<tt>REDO;</tt>
<dt>
<b>Tastatur</b>
<dd>
<tt>F10:          REDO</tt>   REDO-Befehl ausf&uuml;hren.<br>
<tt>Shift+Alt+BS: REDO</tt>
</dl>
<b>Siehe auch</b> <a href=#105>UNDO</a>,
<a href=#372>Forward&amp;Back-Annotation</a>
<p>
Die mit UNDO r&uuml;ckg&auml;ngig gemachten Befehle lassen sich mit
REDO erneut ausf&uuml;hren. Damit kann man ganze Abl&auml;ufe rekonstruieren.
Die Befehle EDIT, OPEN und REMOVE l&ouml;schen die Vorgeschichte.
<p>
UNDO/REDO ist vollkommen in den Mechanismus der Forward&amp;Back-Annotation
integriert.


<a name=89>
<h1>REMOVE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
L&ouml;schen von Dateien, Devices, Symbolen, Packages, Modulen und Schaltplanseiten.
<dt>
<b>Syntax</b>
<dd>
<tt>REMOVE name</tt><br>
<tt>REMOVE name.Sxx</tt><br>
<tt>REMOVE name.mod</tt><br>
<tt>REMOVE name.Mxx</tt>
</dl>
<b>Siehe auch</b> <a href=#74>OPEN</a>,
<a href=#90>RENAME</a>,
<a href=#70>MODULE</a>
<h2>Dateien l&ouml;schen</h2>
Der REMOVE-Befehl l&ouml;scht im Platinen- und Schaltplan-Editier-Modus
die mit <tt>name</tt> angegebene Datei.
<h2>Devices, Symbole, Packages</h2>
Im Bibliotheks-Editier-Modus l&ouml;scht der REMOVE-Befehl aus der
aktiven Bibliothek das unter dem Namen name gespeicherte Device,
Symbol oder Package.
Der Name kann mit einer Erweiterung (z. B. REMOVE name.pac) angegeben werden. Wenn Sie
den Namen ohne Erweiterung angeben, m&uuml;ssen Sie sich im entsprechenden Editier-Modus
des Bibliotheks-Editors befinden um ein Objekt zu l&ouml;schen (z. B. im Package-Editor
um ein Package zu l&ouml;schen).
<p>
Symbole/Packages lassen sich nur l&ouml;schen, wenn sie in keinem Device verwendet werden.
<p>
Ist ein Symbol, Device oder Package zum Editieren geladen, wirkt der
Befehl auf den entsprechenden Typ. Ansonsten werden die Namen als
Device-Namen interpretiert, falls das Schaltplan-Modul vorhanden ist,
und als Package-Namen, falls kein Schaltplan-Modul vorhanden ist.
<p>
REMOVE im Bibliotheks-Editier-Modus l&ouml;scht den Undo-Puffer.
<h2>Schaltplan-Seiten</h2>
Der REMOVE-Befehl kann auch zum L&ouml;schen von Seiten aus einem Schaltplan
verwendet werden, dabei kann der Name der geladenen Zeichnung entfallen.
Zum Beispiel:
<pre>
REMOVE .S3
</pre>
l&ouml;scht Seite Nr. 3 aus dem gegenw&auml;rtig geladenen Schaltplan.
<p>
In der Syntax-Beschreibung entspricht xx der Nummer der zu
l&ouml;schenden Seite. Falls xx gleich der Nummer
der gerade editierten Seite ist, wird Seite Nummer 1 geladen. Alle
Seiten mit Nummern, die gr&ouml;&szlig;er sind als xx , erhalten
eine um 1 verminderte Nummer.
<h2>Module</h2>
Der REMOVE-Befehl kann auch zum L&ouml;schen von Modulen oder Seiten von Modulen
aus einem Schaltplan verwendet werden. Zum Beispiel:
<pre>
REMOVE name.mod
REMOVE name.m3
</pre>


<a name=90>
<h1>RENAME</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Symbole, Devices oder Packages in einer Bibliothek umbenennen.
<dt>
<b>Syntax</b>
<dd>
<tt>RENAME old_name new_name;</tt>
</dl>
<b>Siehe auch</b> <a href=#74>OPEN</a>
<p>
Mit RENAME kann der Name eines Symbols, Device oder Package ge&auml;ndert
werden. Die Bibliothek muss vorher mit OPEN ge&ouml;ffnet worden
sein.
<p>
Der Name darf mit der Namenserweiterung angegeben werden (zum Beispiel
RENAME name1.pac name2[.pac] - die Erweiterung im zweiten Parameter ist
optional). Wird der erste Parameter ohne Erweiterung angegeben, m&uuml;ssen Sie
sich im entsprechenden Editier-Modus (z. B. im Package-Modus um Packages
umzubenennen) befinden.
<p>
RENAME l&ouml;scht den Undo-Puffer.


<a name=91>
<h1>REPLACE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Bauteil austauschen.
<dt>
<b>Syntax</b>
<dd>
<tt>REPLACE &#149;..</tt><br>
<tt>REPLACE device_name[@library_name] &#149;..</tt><br>
<tt>REPLACE part_name device_name[@library_name] ..</tt><br>
<tt>REPLACE package_name &#149;..</tt><br>
<tt>REPLACE element_name package_name ..</tt>
</dl>
<b>Siehe auch</b> <a href=#97>SET</a>,
<a href=#106>UPDATE</a>
<p>
Der REPLACE-Befehl kann dazu benutzt werden, ein Bauteil gegen ein anderes
(auch aus einer anderen Bibliothek) auszutauschen. Altes und neues Bauteil
m&uuml;ssen kompatibel sein, das heisst ihre benutzten Gatter und angeschlossenen
Pins bzw. Pads m&uuml;ssen entweder &uuml;ber ihre Namen oder ihre Koordinaten
zusammenpassen.
<p>
Ohne Parameter &ouml;ffnet der REPLACE-Befehl einen Dialog, &uuml;ber den ein Bauteil
aus allen momentan in <a href=#107>Verwendung</a> befindlichen
Bibliotheken ausgew&auml;hlt werden kann. Nach dieser Auswahl f&uuml;hren weitere
Mausklicks auf Bauteile dazu, dass diese (soweit m&ouml;glich) gegen das ausgew&auml;hlte
Bauteil getauscht werden.
<p>
Wird ein <tt>device_name</tt> angegeben, so wird dieses Bibliothekselement f&uuml;r die
Austausch-Operation verwendet.
<p>
Wird sowohl ein <tt>part_name</tt> als auch ein <tt>device_name</tt>
angegeben, so wird das Bauteil <tt>part_name</tt> gegen das Bibliothekselement
<tt>device_name</tt> ausgetauscht (was n&uuml;tzlich ist, wenn mit Skripten
gearbeitet wird).
<p>
Falls ein <tt>library_name</tt> angegeben wird und dieser Leerzeichen enth&auml;lt, so muss der ganze
<tt>device_name@library_name</tt> in einfache Hochkommas eingeschlossen werden.
<p>
Falls nur ein Board (ohne Schaltplan) bearbeitet wird, oder falls Bauteile
im Board ersetzt werden sollen die kein entsprechendes Bauteil im Schaltplan
haben, so kennt REPLACE-Befehl zwei verschiedene Betriebsarten, die mit
dem SET-Befehl eingestellt werden.
<h2>Gleiche Namen</h2>
Die erste Betriebsart wird mit
<pre>
SET REPLACE_SAME NAMES;
</pre>
aktiviert; sie ist beim Programmstart eingestellt. In dieser Betriebsart
kann man einem Element im Schaltplan ein anderes Package zuweisen,
bei dem dieselben Pad- und Smd-Namen vorhanden sind.
<p>
Das neue Package kann aus einer anderen Bibliothek stammen, und es darf
zus&auml;tzliche Pads und Smds enthalten. Die Lage der Anschl&uuml;sse ist
beliebig.
<p>
Anschl&uuml;sse des alten Package, die mit Signalen verbunden sind, m&uuml;ssen
entsprechend auch im neuen Package vorhanden sein. Das neue Package
darf auch weniger Anschl&uuml;sse haben, solange diese Bedingung erf&uuml;llt
ist.
<h2>Gleiche Koordinaten</h2>
Die zweite Betriebsart wird mit
<pre>
SET REPLACE_SAME COORDS;
</pre>
aktiviert. Sie erlaubt es, einem Element in einem Schaltplan
ein anderes Package zuweisen, bei dem auf denselben Koordinaten
(relativ zum Ursprung des Package) Pads oder Smds liegen m&uuml;ssen. Die
Namen d&uuml;rfen unterschiedlich sein.
<p>
Das neue Package kann aus einer anderen Bibliothek stammen, und es darf
zus&auml;tzliche Pads und Smds enthalten. Anschl&uuml;sse des alten Package, die
mit Signalen verbunden sind, m&uuml;ssen entsprechend auch im neuen Package
vorhanden sein. Das neue Package darf auch weniger Anschl&uuml;sse haben,
solange diese Bedingung erf&uuml;llt ist.
<p>
REPLACE funktioniert nur mit eingeblendetem tOrigins- bzw.
bOrigins-Layer.
<p>
Existiert bereits ein Package mit demselben Namen (aus derselben Bibliothek) in der Zeichnung,
und wurde die Bibliothek seit dem Plazieren des Bauteils modifiziert, wird automatisch ein
<a href=#106>Library-Update</a> gestartet. Dabei werden Sie gefragt, ob die
Objekte in der Zeichnung durch die neueren aus der Bibliothek ersetzt werden sollen.
<p>
<b>Achtung: Eine REPLACE-Operation aktualisiert automatisch je nach Bedarf alle
betroffenen Bibliotheksobjekte. Dies bedeutet, dass auch andere Bauteile (auf
anderen Schaltplanseiten oder an anderen Stellen des Boards) ver&auml;ndert werden
k&ouml;nnen.
Starten Sie den <a href=#48>Design Rule Check</a> (DRC) und den
<a href=#50>Electrical Rule Check</a> (ERC) nach jeder REPLACE-Operation!</b>


<a name=92>
<h1>RIPUP</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Verdrahtete in unverdrahtete Signale (Luftlinien) verwandeln.<br>
Polygondarstellung auf "Umrisse".
<dt>
<b>Syntax</b>
<dd>
<tt>RIPUP;</tt><br>
<tt>RIPUP [ @ ] [ ! ] &#149;..</tt><br>
<tt>RIPUP [ @ ] [ ! ] signal_name..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Rechte</mb> verwandelt die Signale in der Gruppe in Luftlinien.<br>
</dl>
<b>Siehe auch</b> <a href=#44>DELETE</a>,
<a href=#56>GROUP</a>,
<a href=#81>POLYGON</a>,
<a href=#86>RATSNEST</a>
<p>
Der Befehl RIPUP wird dazu verwendet, bereits verlegte Signale wieder
in Luftlinien zu verwandeln. Der Befehl kann verwendet werden f&uuml;r:
<ul>
<li>alle Signale (RIPUP;)
<li>alle Signale ausser den genannten (RIPUP ! GND VCC;)
<li>bestimmte Signale (z. B. RIPUP D0 D1 D2;)
<li>bestimmte Signalabschnitte (mit der Maus anzuklicken)
<li>alle Polygone (RIPUP @;)
<li>alle Polygone bestimmter Signale (e.g. RIPUP @ GND VCC;)
<li>alle Polygone ausser denen bestimmter Signale (e.g. RIPUP @ ! GND VCC;)
</ul>
Wird mit RIPUP auf eine Luftlinie geklickt, so werden die an dieser
Luftlinie angrenzenden verlegten Wires und Vias bis hin zum n&auml;chsten Pad,
SMD oder der n&auml;chsten Luftlinie in Luftlinien verwandelt.
<pre>
RIPUP signal_name..
</pre>
Wirkt auf das gesamte Signal "signal_name" (mehrere Signale sind
m&ouml;glich, z.B. <tt>Ripup D0 D1 D2;</tt>)
<pre>
RIPUP &#149;..
</pre>
Wirkt auf das durch den Mausklick selektierte Segment (bis zum n&auml;chsten
Pad/Smd). Bei
<pre>
RIPUP;
</pre>
werden nur solche Signale ber&uuml;cksichtigt, die an Elementen angeschlossen
sind (z.B. die Eckwinkel zur Platinenbegrenzung bleiben erhalten). Das gleiche
gilt, wenn der RIPUP-Befehl auf eine Gruppe angewendet wird.
<p>
<b>Achtung:</b> in allen F&auml;llen wirkt der RIPUP-Befehl nur auf Objekte in
Layern, die momentan eingeblendet sind!
<h2>Platzhalter</h2>
Falls der <tt>signal_name</tt>-Parameter angegeben wurde, so sind die Zeichen <tt>'*'</tt>, <tt>'?'</tt>
und <tt>'[]'</tt> <i>Platzhalter</i> und haben folgende Bedeutung:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>*</tt>    </td><td width=20><td>steht f&uuml;r eine beliebige Anzahl beliebiger Zeichen</td></tr>
<tr><td><tt>?</tt>    </td><td width=20><td>steht f&uuml;r genau ein Zeichen</td></tr>
<tr><td><tt>[...]</tt></td><td width=20><td>steht f&uuml;r irgend eines der Zeichen zwischen den Klammern</td></tr>
</table>
<p>
Soll eines dieser Zeichen genau so gesucht werden, wie es ist, so muss es in eckige Klammern
eingeschlossen werden. Zum Beispiel findet <tt>abc[*]ghi</tt> die Zeichenfolge <tt>abc*ghi</tt>,
aber nicht <tt>abcdefghi</tt>.
<p>
Ein Bereich von Zeichen kann als <tt>[a-z]</tt> angegeben werden, was f&uuml;r eines der Zeichen
aus dem Bereich <tt>'a'</tt>...<tt>'z'</tt> steht.
<h2>Polygone</h2>
Falls der RIPUP-Befehl mit einem Namen auf ein Signal angewendet wird, zu dem ein
Polygon geh&ouml;rt, wird das Polygon anschlie&szlig;end mit seinen Umrissen
dargestellt (schnellerer Bildaufbau!). Soll das Polygon wieder
freigerechnet werden, ist der Befehl <a href=#86>RATSNEST</a>
auszuf&uuml;hren.


<a name=93>
<h1>ROTATE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Drehen von Objekten.
<dt>
<b>Syntax</b>
<dd>
<tt>ROTATE orientation &#149; ..</tt><br>
<tt>ROTATE orientation 'name' ..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Rechte</mb> dreht die Gruppe.<br>
<mb>Linke&amp;Ziehen</mb> rotiert das Objekt um beliebige Winkel.<br>
<mb>Ctrl+Rechte&amp;Ziehen</mb> rotiert die Gruppe um beliebige Winkel.
</dl>
<b>Siehe auch</b> <a href=#30>ADD</a>,
<a href=#68>MIRROR</a>,
<a href=#71>MOVE</a>,
<a href=#64>LOCK</a>,
<a href=#56>GROUP</a>
<p>
Mit dem ROTATE-Befehl kann man die Orientierung von Objekten &auml;ndern.
<p>
Wird <tt>orientation</tt>  (siehe Beschreibung bei <a href=#30>ADD</a>)
angegeben, so wird stattdessen die angegebene Orientation zu der Orientation des
selektierten Objektes hinzugef&uuml;gt.
<p>
Wird der angegebenen <tt>orientation</tt> das Zeichen <tt>'='</tt> vorangestellt, so
wird der Wert nicht hinzugef&uuml;gt, sondern absolut eingestellt.
<p>
Bauteile, Pads, Smds und Pins lassen sich
auch mit ihrem Namen selektieren. Das ist vor allem dann n&uuml;tzlich,
wenn sich das Objekt ausserhalb des gerade dargestellten Bildausschnitts
befindet.
<p>
Zum Beispiel w&uuml;rde
<p>
<pre>
ROTATE =MR90 IC1
</pre>
<p>
die Orientierung des Elements IC1 auf MR90 einstellen, unabh&auml;ngig davon, welchen
Wert diese vorher hatte.
<p>
Attribute von Bauteilen k&ouml;nnen dadurch selektiert werden, dass die Kombination
aus Bauteilname und Attributname angegeben wird, wie etwa <tt>R5&gt;VALUE</tt>.
<p>
Die Hochkommas um <tt>name</tt> sind n&ouml;tig zur Unterscheidung vom Wert der Orientierung wie in
<p>
<pre>
ROTATE R45 'R1'
</pre>
Sie k&ouml;nnen weggelassen werden, wenn der Kontext klar ist.
<p>
Mit Click&amp;Drag k&ouml;nnen Sie ein Objekt um einen beliebigen Winkel drehen.
Klicken Sie dazu auf das Objekt und bewegen Sie die Maus (mit gedr&uuml;ckter Maustaste)
vom Objekt weg. Nachdem Sie die Maus eine kurze Strecke bewegt haben beginnt das
Objekt sich zu drehen. Bewegen Sie die Maus bis der gew&uuml;nschte Winkel erreicht ist
und lassen Sie dann die Maustaste los. Sollten Sie es sich zwischenzeitlich anders
&uuml;berlegt haben und das Objekt lieber doch nicht rotieren wollen, so k&ouml;nnen Sie (bei
immer noch gedr&uuml;ckter Maustaste) die Esc-Taste dr&uuml;cken um den Vorgang abzubrechen.
Die gleiche Operation kann auch auf eine Gruppe angewendet werden indem die rechte
Maustaste verwendet wird. Die Gruppe wird um den Punkt rotiert, an dem die
Maustaste gedr&uuml;ckt wurde.
<p>
Bauteile k&ouml;nnen nicht rotiert werden, wenn sie <a href=#64>gelockt</a> sind,
oder wenn eines ihrer angeschlossenen Pads aus der erlaubten Fl&auml;che hinausstehen w&uuml;rde
(falls sie eine <a href=#378>eingeschr&auml;nkte Version</a> von EAGLE verwenden).
<h2>Elemente</h2>
Beim Drehen von Elementen bewegen sich die angeschlossenen Leitungen
mit (Achtung auf Kurzschl&uuml;sse!).
<p>
Elemente lassen sich nur drehen, wenn der tOrigins- bzw. der
bOrigins-Layer sichtbar ist.
<h2>Texte</h2>
Text wird immer so dargestellt, dass er von vorne oder von rechts
zu lesen ist - auch wenn er rotiert wird. Nach zweimaligem Rotieren
erscheint er deshalb wieder gleich, aber der Aufh&auml;ngepunkt liegt
nicht mehr links unten, sondern rechts oben. Denken Sie daran, wenn
sich ein Text scheinbar nicht mehr selektieren l&auml;sst.
<p>
Wenn Sie einen Text "auf dem Kopf stehend" darstellen wollen, so k&ouml;nnen
Sie das "Spin"-Flag f&uuml;r diesen Text setzen.


<a name=94>
<h1>ROUTE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Luftlinien in Leiterbahnen umwandeln.
<dt>
<b>Syntax</b>
<dd>
<tt>ROUTE [width] &#149; [curve | @radius] &#149;..</tt><br>
<tt>ROUTE name ..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Linke</mb> startet den Routevorgang an einem beliebigen Punkt eines Wires oder Vias.<br>
<mb>Shift+Linke</mb> startet den Routevorgang mit der gleichen Breite wie ein bestehender Wire.<br>
<mb>Mittlere</mb> w&auml;hlt den Layer.<br>
<mb>Rechte</mb> &auml;ndert den Knickwinkel (siehe <a href=#97>SET Wire_Bend</a>).<br>
<mb>Shift+Rechte</mb> kehrt die Richtung des Weiterschaltens des Knickwinkels um.<br>
<mb>Ctrl+Rechte</mb> schaltet zwischen korrespondierenden Knickwinkeln hin und her.<br>
<mb>Shift+Linke</mb> beim Absetzen setzt ein Via.<br>
<mb>Ctrl+Linke</mb> beim Absetzen eines Wire-Endpunktes definiert den Kreisbogen-Radius.
</dl>
<b>Siehe auch</b> <a href=#34>AUTO</a>,
<a href=#105>UNDO</a>,
<a href=#112>WIRE</a>,
<a href=#69>MITER</a>,
<a href=#99>SIGNAL</a>,
<a href=#97>SET</a>,
<a href=#86>RATSNEST</a>
<p>
Der ROUTE-Befehl dient dazu, die unverdrahteten Signale (dargestellt
als Luftlinien im Unrouted-Layer) in verdrahtete (also Wires
in den Signal-Layern) umzuwandeln.
<p>
Ist der ROUTE-Befehl aktiviert, kann die Breite (<tt>width</tt>) des entstehenden Wires unmittelbar von der Tastatur aus eingegeben werden.
<p>
Nachdem man den ROUTE-Befehl aktiviert hat, setzt man
den ersten Punkt an einem Ende der Luftlinie an und bewegt den Mauszeiger
in die Richtung, in die man die Leitung legen will. EAGLE ersetzt
dann die Luftlinie durch einen Wire oder zwei Wire-St&uuml;cke
(je nach eingestelltem Knickwinkel) im gerade aktiven Signal-Layer.
<p>
Die linke Maustaste erneut bet&auml;tigt, setzt das Leitungsst&uuml;ck ab.
Wird beim Absetzen die <tt>Shift</tt>-Taste gedr&uuml;ckt, so wird (falls m&ouml;glich und die
Luftlinie nicht bereits ohnehin komplett geroutet ist) ein Via an der Absetzstelle
gesetzt (entweder mit passender L&auml;nge oder, falls sich eine solche nicht ermitteln
l&auml;sst, durchgehend von Layer 1 bis 16).
<p>
Mit der mittleren Maustaste wechselt man die Ebene. Durchkontaktierungen
(Vias) werden automatisch gesetzt.
Bitte beachten Sie, dass von den Signal-Layern (1 bis 16) nur diejenigen
zur Verf&uuml;gung stehen, die im Layer-Setup in den <a href=#139>Design Rules</a>
eingetragen sind.
<p>
Es wird nur das minimal n&ouml;tige Via (gem&auml;&szlig; dem Layer-Setup in den <a href=#139>Design Rules</a>) gesetzt.
Dabei kann es vorkommen, dass ein bereits vorhandenes Via des selben Signals
entsprechend verl&auml;ngert wird, oder dass vorhandene Vias zusammengefasst werden um ein
l&auml;ngeres Via zu bilden, falls dies n&ouml;tig ist um den gew&uuml;nschten Layer-&Uuml;bergang zu
erm&ouml;glichen.
Wird ein Via am Anfangs- oder Endpunkt gesetzt und es befindet sich an dieser Stelle
ein SMD-Pad, so wird ein <i>Micro-Via</i> erzeugt falls der aktuelle Route-Layer
eine Ebene vom Layer des SMDs entfernt ist (dies trifft nur dann zu wenn in den
<a href=#139>Design Rules</a> Micro-Vias erlaubt sind).
<p>
Die rechte Maustaste &auml;ndert den Knickwinkel (siehe <a href=#97>SET Wire_Bend</a>).
<p>
Ist eine Luftlinie komplett verdrahtet, ert&ouml;nt ein Piepston.
<p>
Wird der <i>curve</i> oder <i>@radius</i> Parameter angegeben, so kann ein Kreisbogen als Teil des Leiterbahnzugs
gezeichnet werden (siehe die ausf&uuml;hrliche Beschreibung beim <a href=#112>WIRE</a>-Befehl).
<p>
Wird der Startpunkt mit gedr&uuml;ckter <tt>Ctrl</tt>-Taste angeklickt und befindet sich
dort keine Luftlinie, so wird automatisch eine neue Luftlinie erzeugt. Der Startpunkt
dieser Luftlinie ist derjenige Punkt auf dem selektierten Wire oder Via, der dem Mauszeiger
am n&auml;chsten liegt (m&ouml;glicherweise auf den n&auml;chstgelegenen Rasterpunkt geschnappt).
Das ferne Ende der Luftlinie zeigt dynamisch auf ein Zielsegment, welches nicht das
ausgew&auml;hlte Segment ist. Sollte das selektierte Signal bereits vollst&auml;ndig geroutet
sein, so zeigt das ferne Ende zum Startpunkt.
Ist der selektierte Wire ein Kreisbogen, so beginnt die Luftlinie am n&auml;chstgelegenen
Endpunkt des Wires.
<p>
Wird ein <tt>name</tt> angegeben, so wird die Luftlinie dieses Signals selektiert,
die dem Mauszeiger am n&auml;chsten liegt. Falls <tt>name</tt> als <i>with</i>,
<i>curve</i> oder <i>@radius</i> Parameter interpretiert werden k&ouml;nnte, so muss
er in Hochkommas eingeschlossen werden.
<h2>Auswahl des Routing-Layers und der Wire-Breite</h2>
Wenn Sie eine Luftlinie selektieren wird der Layer in dem geroutet wird
durch Betrachtung der am Startpunkt vorhandenen Objekte wie folgt ermittelt:
<ul>
<li>befindet sich dort ein Objekt im aktiven Layer, so wird dieser beibehalten
<li>ansonsten wird ein Layer der an diesem Punkt befindlichen Objekte genommen
</ul>
Beim Selektieren einer Luftlinie wird die Wire-Breite
zum Routen auf den Wert gesetzt, der sich aus den Design-Regeln und der
Netzklasse des selektierten Signals ergibt, wenn der Schalter "Optionen/Einstellungen/Verschiedenes/Width und Drill bei
Route autom. setzen" eingeschaltet ist.
W&auml;hrend die Luftlinie am Cursor
h&auml;ngt k&ouml;nnen Sie eine andere Breite einstellen, und die Verbindung wird dann
mit der neuen Breite berechnet. Gleiches gilt f&uuml;r die Daten von Vias.
<p>
Wenn eine Luftlinie geroutet wird, die an einem bereits verlegten Wire
beginnt, so &uuml;bernimmt der neu verlegte Wire die Breite des bereits
existierenden Wires, wenn beim Selektieren der Luftlinie die <tt>Shift</tt>-Taste
gedr&uuml;ckt wird.
<h2>Fangfunktion</h2>
Der Endpunkt der dynamisch berechneten Luftlinie wird immer als
zus&auml;tzlicher Rasterpunkt benutzt, auch wenn er nicht auf dem aktuellen
Raster liegt. Hat die verbleibende Luftlinie eine L&auml;nge, die k&uuml;rzer als
SNAP_LENGTH ist, so schnappt der zu verlegende Wire automatisch auf den
Endpunkt der Luftlinie, und bleibt dort, bis der Mauszeiger mindestens
SNAP_LENGTH von diesem Punkt entfernt wird. Mit
<pre>
SET SNAP_LENGTH number;
</pre>
kann der Grenzwert f&uuml;r die Fangfunktion eingestellt werden, wobei
<i>number</i> in der aktuellen Grid-Einheit anzugeben ist.
Default ist 20 Mil.
<h2>Follow-me-Router</h2>
Mit den speziellen <a href=#97>Knickwinkeln</a> <tt>8</tt> und <tt>9</tt>
arbeitet der ROUTE-Befehl als "Follow-me"-Router. Das bedeutet, dass die selektierte
Luftlinie vollautomatisch vom <a href=#137>Autorouter</a> verlegt wird.
<p>
Knickwinkel <tt>8</tt> verlegt nur das k&uuml;rzere Ende der selektierten Luftlinie,
w&auml;hrend <tt>9</tt> beide Seiten verlegt. Sobald die automatische Wegesuche beendet
ist (was einige Zeit dauern kann, haben Sie also bitte Geduld), wird die Luftlinie
durch die konkreten Wires und Vias ersetzt. Konnte keine Verbindung gefunden werden
(etwa aufgrund von Beschr&auml;nkungen durch die Design-Regeln), so wechselt der Cursor
in ein "Verbotszeichen". Mit Knickwinkel <tt>9</tt> kann es vorkommen, dass nur
eine Seite der Luftlinie verlegt werden kann und die andere nicht.
<p>
Bei jeder Mausbewegung wird das bisherige Ergebnis verworfen und eine neue
Berechnung gestartet. Sobald das Ergebnis akzeptabel ist, klicken Sie mit der
linken Maustaste um es abzulegen.
<p>
Der Follow-me-Router arbeitet so, dass er den Rasterpunkt an der aktuellen
Mausposition als Startpunkt nimmt und den Autorouter benutzt um eine Verbindung
von diesem Punkt zu einem Punkt auf dem Signal-Segment zu finden, an dem die
Luftlinie endet (was nicht unbedingt der genaue Endpunkt der Luftlinie sein muss).
Der Startpunkt ber&uuml;cksichtigt auch den momentan gew&auml;hlten Layer, wundern Sie
sich also nicht, wenn der Router an dieser Stelle ein Via setzt. Durch &Auml;ndern
des aktuellen Layers kann das Routing-Ergebnis beeinflusst werden.
<p>
Als Routing-Raster wird das zum Zeitpunkt des Selektierens der Luftlinie
eingestellte Raster verwendet.
<p>
Die Routing-Parameter (wie etwa Kostenfaktoren, Vorzugsrichtungen etc.) werden
im Dialog des <a href=#34>AUTO</a>-Befehls definiert.
<p>
Folgende Besonderheiten gelten:
<ul>
<li>Der Follow-me-Router berechnet nicht die Polygone. Wenn Sie wollen, dass sie
    freigerechnet werden, so geben Sie vorher den Befehl <a href=#86>RATSNEST</a>
    ein.
<li>Da der Startpunkt Bestandteil der verlegten Leiterbahnen sein muss, kann das
    Ergebnis eine T-f&ouml;rmige Verbindung sein, mit einem &uuml;berfl&uuml;ssigen Wire, der
    zum Startpunkt f&uuml;hrt. Bewegen Sie den Mauscursor einfach in Richtung der
    eigentlichen Verbindung, um dies zu vermeiden.
<li>Beide Enden der Luftlinie werden mit Knickwinkel <tt>9</tt> separat verlegt,
    wodurch es dazu kommen kann, dass sich Wires bzw. Vias &uuml;berlappen. Bewegen
    Sie den Mauscursor bis solche unerw&uuml;nschten Effekte verschwinden.
<li>Abh&auml;ngig vom gew&auml;hlten Routing-Layer des Startpunktes kann es vorkommen, dass
    unn&ouml;tige Vias generiert werden. W&auml;hlen sie einen anderen Layer um dies zu
    vermeiden.
<li>Falls die maximale Anzahl erlaubter Vias in den Follow-me-Parametern auf <tt>0</tt>
    gesetzt ist, und Sie den Layer wechseln w&auml;hrend eine Luftlinie am Mauscursor
    h&auml;ngt, so kann der Router am Anfangspunkt der k&uuml;rzeren Seite der Luftlinie
    dennoch ein Via platzieren (sofern dies gem&auml;&szlig; den Design-Regeln, eventueller
    Sperrfl&auml;chen und dergleichen &uuml;berhaupt m&ouml;glich ist).
<li>Im Follow-me-Modus schaltet die rechte Maustaste zwischen dem einseitigen
    oder beidseitigen Verlegen der Luftlinie hin und her. Um zum manuellen
    Routen zur&uuml;ckzuschalten klicken Sie auf einen der entsprechenden Buttons
    f&uuml;r den Knickwinkel, oder geben den Befehl <a href=#97>SET Wire_Bend</a>
    mit einem Wert unter <tt>8</tt> ein.
<li>Der Follow-me-Router kann nur runde oder achteckige Vias platzieren, keine quadratischen.
<li>Der Miter-Parameter hat im Folow-me-Modus keine Bedeutung.
<li>Die Parameter f&uuml;r den Follow-me-Router werden zusammen mit dem Rest der
    Autorouter-Parameter gespeichert, allerdings in einer eigenen Sektion.
    Der Grund hierf&uuml;r ist, dass sich die Parameter des Follow-me-Routers zun&auml;chst
    wie die der "Route"-Sektion in den Autorouter-Parametern verhalten sollen
    (um m&ouml;glichst wenig Fl&auml;che zu "verbauen"), aber auch eine Tendenz hin zu
    den Parametern der Optimierungsl&auml;ufe haben k&ouml;nnen.
<li>Wird ein Board, welches Autorouter-Parameter enth&auml;lt, mit dieser Version von
    EAGLE abgespeichert und mit einer fr&uuml;heren Version geladen, so kann es sein, dass
    die Autorouter-Parameter als ung&uuml;ltig gemeldet werden, und stattdessen
    Standardwerte verwendet werden. Sie k&ouml;nnen die Autorouter-Parameter, wenn n&ouml;tig,
    in eine *.ctl Datei speichern und diese explizit in die &auml;ltere Version laden.
<li>Die speziellen Mausfunktionen
    <mb>Ctrl+Linke</mb> (Routevorgang an einem beliebigen Punkt eines Wires oder Vias starten),
    <mb>Shift+Linke</mb> (beim Absetzen ein Via setzen) und
    <mb>Ctrl+Linke</mb> (Kreisbogen-Radius definieren) funktionieren im Follow-me-Modus nicht.
</ul>
<h2>Differential Pair Routing</h2>
<i>Differential Pairs</i> sind Signale, die parallel und mit einem bestimmten
Abstand zueinander verlegt werden m&uuml;ssen.
<p>
Folgende Besonderheiten gelten:
<ul>
<li>Ein Differential Pair besteht aus zwei Signalen mit dem gleichen Namen,
    von denen der eine auf <tt>_P</tt> (das "positive" Signal) und der andere
    auf <tt>_N</tt> (das "negative" Signal) endet, zum Beispiel <tt>CLOCK_P</tt>
    und <tt>CLOCK_N</tt>.
    Die beiden Signale m&uuml;ssen auch der selben Netzklasse angeh&ouml;ren.
<li>Wird eine Luftline eines Differential Pairs selektiert, so werden beide
    Signale parallel verlegt. Der Abstand zwischen den beiden Signalen sowie
    die Wire- und Via-Abmessungen ergeben sich aus der Netzklasse der Signale,
    unabh&auml;ngig von der Einstellung "Optionen/Einstellungen/Verschiedenes/Width und Drill bei Route autom. setzen".
<li>Falls Sie nicht beide Signale routen wollen, k&ouml;nnen Sie die zweite Luftlinie
    durch Dr&uuml;cken der ESCape-Taste fallen lassen.
<li>Beim Beginn des Routens eines Differential Pairs (wenn die Anfangspunkte
    der Luftlinien noch nicht den n&ouml;tigen Abstand haben) werden Signal-Wires
    gem&auml;&szlig; dem aktuellen Knickwinkel von den Anfangspunkten zur aktuellen
    Position des Mauszeigers generiert. Beachten Sie bitte, dass es dabei
    vorkommen kann, dass sich die Wires &uuml;berlappen. W&auml;hlen Sie daher einen
    passenden Punkt von dem aus Sie das eigentliche parallele Routen beginnen.
<li>Die Koordinaten, die Sie w&auml;hrend des Routens eines Differential Pairs
    angeben, bilden eine "Mittellinie" entlang der die tats&auml;chlichen Signal-Wires
    links und rechts im passenden Abstand verlegt werden.
<li>Da die Pads, an die ein Differential Pair angeschlossen sind, typischerweise
    nicht den selben Abstand haben wie er f&uuml;r die Signal-Wires ben&ouml;tigt wird,
    m&uuml;ssen Sie solche Signale von beiden Seiten Routen. Das hei&szlig;t, Sie beginnen
    an einem Bauteil, routen in Richtung des anderen Bauteils und routen den
    Rest indem Sie vom anderen Bauteil her beginnen. Dies is notwending, da nur
    der erste Schritt in einer Routing-Sequenz Wires generiert, die an Positionen
    beginnen, die nicht den erforderlichen Abstand haben.
<li>Wenn Sie zu den Wire-Endpunkten eines Differential Pairs in einem anderen
    Layer hinrouten, und die Wires sind genau aufeinander ausgerichtet, so
    werden die passenden Vias automatisch erzeugt.
<li>Die speziellen Mausfunktionen
    <mb>Shift+Linke</mb> (beim Absetzen ein Via setzen) und
    <mb>Ctrl+Linke</mb> (Kreisbogen-Radius definieren) funktionieren im Differential Pair Modus nicht.
<li>Wenn Sie mit <mb>Ctrl+Linke</mb> Maustaste den Route-Vorgang an einer beliebigen
    Stelle des Signals beginnen, so k&ouml;nnen Sie damit nur das selektierte Signal
    routen, und nicht das Differential Pair zu dem dieses Signal m&ouml;glicherweise geh&ouml;rt.
<li>Differential Pairs k&ouml;nnen nur rein manuell geroutet werden. Der Follow-me Router
    und der Autorouter behandeln sie wie ganz normale Signale.
</ul>
Mit dem <a href=#66>MEANDER</a>-Befehl k&ouml;nnen Sie L&auml;ngenunterschiede
zwischen den beiden Signalen eines Differential Pairs ausgleichen.


<a name=95>
<h1>RUN</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
F&uuml;hrt ein <a href=#144>User-Language</a>-Programm aus.
<dt>
<b>Syntax</b>
<dd>
<tt>RUN file_name [argument ...] </tt>
</dl>
<b>Siehe auch</b> <a href=#96>SCRIPT</a>
<p>
Der RUN-Befehl startet das User-Language-Programm mit dem Namen <tt>file_name</tt>.<br>
Die optionale <tt>Argument</tt>-Liste ist f&uuml;r das ULP &uuml;ber die
<a href=#256>Builtin-Variablen</a> <tt>argc</tt> und <tt>argv</tt> verf&uuml;gbar.
<p>
Von einem Kontextmen&uuml; aus gestartet wird das entsprechende Objekt einer Gruppe zugeordnet.
Es ist mit der Builtin-Funktion <a href=#313>ingroup()</a> identifizierbar
f&uuml;r weitere Verarbeitung. Im Falle eines Wire werden dabei die Gruppen-Bits entsprechend dem Selektionszustand gesetzt
(erster, zweiter oder beide Endpunkte). Das erlaubt zu bestimmen, welcher Endpunkt selektiert wurde.
<h2>ULP von Script-Datei ausf&uuml;hren</h2>
Wenn ein ULP von einer Script-Datei aufgerufen wird und das Programm
einen Wert ungleich <tt>0</tt> zur&uuml;ckgibt (durch einen Aufruf der
Funktion
<a href=#276>exit()</a> oder weil
das STOP-Symbol angeklickt wurde), wird die Ausf&uuml;hrung der Script-Datei
beendet.
<h2>Editor-Befehle von einem ULP ausf&uuml;hren</h2>
Ein ULP kann die <a href=#276>exit()</a>-Funktion auch mit einem <tt>string</tt>-Parameter
verwenden, um einen Befehl direkt in einem Editor-Fenster auszuf&uuml;hren.


<a name=96>
<h1>SCRIPT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Befehls-Datei ausf&uuml;hren.
<dt>
<b>Syntax</b>
<dd>
<tt>SCRIPT file_name;</tt>
</dl>
<b>Siehe auch</b> <a href=#97>SET</a>,
<a href=#67>MENU</a>,
<a href=#32>ASSIGN</a>,
<a href=#52>EXPORT</a>,
<a href=#95>RUN</a>
<p>
Der SCRIPT-Befehl stellt eine M&ouml;glichkeit dar, Befehlssequenzen
auszuf&uuml;hren, die in einer Datei abgelegt sind. Gibt man den Befehl
&uuml;ber die Tastatur ein, so wird, falls keine Extension angegeben
wurde, ".scr" als Default verwendet.
<h2>Beispiele</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SCRIPT nofill</tt>     </td><td width=20><td>ruft nofill.scr auf</td></tr>
<tr><td><tt>SCRIPT myscr.</tt>     </td><td width=20><td>ruft myscr (ohne Suffix!) auf</td></tr>
<tr><td><tt>SCRIPT myscr.old</tt>  </td><td width=20><td>ruft myscr.old auf</td></tr>
</table>
<p>
Bitte beachten Sie die M&ouml;glichkeiten des EXPORT-Befehls im Zusammenhang mit Script-Dateien!
<p>
W&auml;hlt man den Befehl mit Hilfe der Maus, dann zeigt ein Popup-Men&uuml;
alle Dateien mit der Erweiterung .scr an. Man kann dann die
gew&uuml;nschte Datei ausw&auml;hlen.
<p>
Der SCRIPT-Befehl bietet die M&ouml;glichkeit, das Programm
an individuelle Bed&uuml;rfnisse anzupassen. Unter
anderem kann man damit:
<ul>
<li>das Befehlsmen&uuml; einstellen,
<li>Tasten belegen,
<li>Platinenumrisse laden,
<li>Farben festlegen.
</ul>
SCRIPT-Dateien enthalten EAGLE-Befehle, entsprechend den Syntax-Regeln.
Zeilen, die mit <tt>'#'</tt> beginnen, sind Kommentarzeilen.
<h2>Fortsetzungszeilen</h2>
Bei manchen Befehlen kann es erforderlich sein, mehrere Zeilen zu
belegen.  Das Zeichen '\'
am Ende einer Kommandozeile sorgt daf&uuml;r, dass das erste Wort
der n&auml;chsten Zeile nicht als Befehl interpretiert wird. Damit
lassen sich in vielen F&auml;llen Hochkommas vermeiden.
<h2>Start-Parameter setzen</h2>
Die SCRIPT-Datei eagle.scr wird jedesmal ausgef&uuml;hrt wenn eine Zeichnung neu in einem
Editor-Fenster geladen wird, oder der Editier-Modus in einer Bibliothek gewechselt wird,
sofern eagle.scr im Projekt-Verzeichnis oder im <a href=#15>Script-Pfad</a>
steht.
<h2>Script Labels</h2>
Die SCRIPT-Datei eagle.scr benutzt Labels der Form <p>
<tt>EDITOR:</tt><p>
wobei <tt>EDITOR</tt> einer der Schl&uuml;sselw&ouml;rter <tt>SCH, BRD, LBR, DEV, PAC</tt> oder <tt>SYM</tt> sein kann.
Das stellt sicher, dass nur der entsprechende Abschnitt im entsprechenden Editor ausgef&uuml;hrt wird.
Wenn zum Beispiel ein neues Board ge&ouml;ffnet wird, wird nur der Abschnitt ausgef&uuml;hrt, der mit
<tt>BRD:</tt> beginnt (bis zum n&auml;chsten Label, falls vorhanden). Dies er&ouml;ffnet die M&ouml;glichkeit von
editorspezifischen Men&uuml;s mit Hilfe des  <a href=#67>MENU</a> Befehls.
Das Label muss am Zeilenanfang stehen.
<h2>Script-Datei im Bibliotheks-Editor ausf&uuml;hren</h2>
Alle Layer werden nur dann erkannt, wenn vorher der Bibliotheks-Editor neu
ge&ouml;ffnet worden ist.


<a name=97>
<h1>SET</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Systemparameter ver&auml;ndern.
<dt>
<b>Syntax</b>
<dd>
<tt>SET</tt><br>
<tt>SET options;</tt>
</dl>
Mit dem SET-Befehl k&ouml;nnen Parameter festgelegt werden, die das
Verhalten des Programms, die Bildschirmdarstellung und die
Benutzeroberfl&auml;che betreffen. Die genaue Syntax ist im folgenden
beschrieben.
<p>
Wird der SET-Befehl ohne Parameter aufgerufen, so erscheint ein Dialog
in dem alle Parameter eingestellt werden k&ouml;nnen.
<h2>Benutzer-Interface</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Fangfunktion             </td><td width=20><td><tt>SET SNAP_LENGTH number;</tt></td></tr>
<tr><td>                         </td><td width=20><td><i>Fangradius:</i> Damit l&auml;sst sich der Grenzwert f&uuml;r die Fangfunktion des <a href=#94>ROUTE</a>-Befehls in der aktuellen Einheit einstellen.</td></tr>
<tr><td>                         </td><td width=20><td>Default: 20 Mil</td></tr>
<tr><td>                         </td><td width=20><td>Verlegt man mit dem <a href=#94>ROUTE</a>-Befehl Leitungen zu Pads, die nicht im Raster liegen, dann sorgt die Fangfunktion daf&uuml;r, dass man innerhalb der Snap_length zu diesem Pad routen kann.</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET CATCH_FACTOR value;</tt></td></tr>
<tr><td>                         </td><td width=20><td><i>Fangfaktor:</i> Legt fest, bis zu welchem Abstand vom Mauszeiger Objekte beim Anklicken mit der Maus ber&uuml;cksichtigt werden. Der Wert wird relativ zur H&ouml;he (bzw. Breite, falls diese kleiner ist) des gegenw&auml;rtigen Bildausschnitts angegeben. Er gilt bei einer Zoomstufe die mindestens einen Bereich von 100mm darstellt und steigt beim Hineinzoomen logarithmisch an. Der Wert 0 setzt diese Einschr&auml;nkung ausser Kraft.
                                          Werte &lt; 1 werden als Faktor, Werte &ge; 1 als Prozentzahl interpretiert. <br>Default: 0.05 (5%).</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET SELECT_FACTOR value;</tt></td></tr>
<tr><td>                         </td><td width=20><td><i>Selektionsfaktor:</i> Damit stellt man ein, bis zu welchem Abstand vom Mauszeiger benachbarte Objekte zur <a href=#21>Auswahl</a> vorgeschlagen werden. Der Wert wird relativ zur H&ouml;he (bzw. Breite, falls diese kleiner ist) des gegenw&auml;rtigen Bildausschnitts angegeben.
                                          Werte &lt; 1 werden als Faktor, Werte &ge; 1 als Prozentzahl interpretiert. <br>Default: 0.02 (2%).</td></tr>
<tr><td>Inhalt von Men&uuml;s         </td><td width=20><td><tt>SET USED_LAYERS name | number;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Legt die Layer fest, die in den entsprechenden EAGLE-Men&uuml;s angezeigt werden. Siehe Beispieldatei <tt>mylayers.scr</tt>.</td></tr>
<tr><td>                         </td><td width=20><td>Die Layer Pads, Vias, Unrouted, Dimension, Drills und Holes sowie die Schaltplan-Layer bleiben auf jeden Fall im Men&uuml;. Auch alle benutzten Signal-Layer bleiben aktiv. <tt>SET Used_Layers All</tt> aktiviert alle Layer.</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET WIDTH_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DIAMETER_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DRILL_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET SMD_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET SIZE_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET ISOLATE_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET SPACING_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET MITER_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DLINE_WIDTH_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DLINE_EXT_WIDTH_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DLINE_EXT_LENGTH_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DLINE_EXT_OFFSET_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td>F&uuml;r die Parameter <i>width</i> etc. kann der Inhalt der entsprechenden Popup-Men&uuml;s mit obigen Befehlen konfiguriert werden. Je Men&uuml; sind max. 16 Werte m&ouml;glich (beim  Smd-Men&uuml; max. 16 Wertepaare). Wird kein Wert angegeben (also z.B. <tt>SET WIDTH_MENU;</tt>), so werden die programminternen Standardwerte gesetzt.</td></tr>
<tr><td>                         </td><td width=20><td>Beispiel:<br><tt>Grid Inch;</tt><br><tt>Set Width_Menu 0.1 0.2 0.3;</tt></td></tr>
<tr><td>Kontextmen&uuml;s             </td><td width=20><td><tt>SET CONTEXT objecttype text commands;</tt></td></tr>
<tr><td>                         </td><td width=20><td>F&uuml;r die selektierbaren Objekttypen k&ouml;nnen die Kontextmen&uuml;s (Rechte-Maus-Klick) um beliebige Eintr&auml;ge
                                          erweitert werden. F&uuml;r <i>objecttype</i> spielt Gross-/Kleinschreibung keine Rolle. <i>text</i> stellt den
                                          Men&uuml;text dar, <i>commands</i> die Kommandofolge, die bei Auswahl dieses Men&uuml;eintrags ausgef&uuml;hrt werden soll.
                                          Leerzeichen sind m&ouml;glich, wenn man den Ausdruck in Hochkomma setzt. Hochkommas innerhalb m&uuml;ssen verdoppelt
                                          werden (vgl. <a href=#104>TEXT</a>). Beispiel:</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET CONTEXT Element Export 'run myexport.ulp';</tt></td></tr>
<tr><td>                         </td><td width=20><td>Dem Kontextmen&uuml; von Elementen wird der Eintrag <i>Export</i> hinzugef&uuml;gt, der ein entsprechendes ULP startet.</td></tr>
<tr><td>                         </td><td width=20><td>Ein bestehender benutzerdefinierter Eintrag kann auch &uuml;berschrieben werden.</td></tr>
<tr><td>                         </td><td width=20><td>Die Einstellungen werden in der EagleRc-Datei gespeichert. Es k&ouml;nnen beliebig viele Eintr&auml;ge hinzugef&uuml;gt werden.</td></tr>
<tr><td>                         </td><td width=20><td>L&ouml;schen der Eintr&auml;ge: Mit</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET CONTEXT objecttype;</tt> werden alle Eintr&auml;ge dieses Objekttyps wieder gel&ouml;scht. Mit <tt>SET CONTEXT;</tt> werden s&auml;mtliche benutzerdefinierte Men&uuml;eintr&auml;ge gel&ouml;scht.</td></tr>
<tr><td>                         </td><td width=20><td>Alle selektierbaren Objekttypen werden unterst&uuml;tzt. Diese sind attribute, circle, dimension, element,
                                          frame, gate, hole, instance, junction, label,  modinst (Modul-Instanz), pad, pin, rectangle, smd, text, via und wire.</td></tr>
<tr><td>                         </td><td width=20><td><i>Einschr&auml;nkung bez&uuml;glich ULP-Ausf&uuml;hrung:</i></td></tr>
<tr><td>                         </td><td width=20><td>Um das selektierte Objekt f&uuml;r die Funktion <a href=#313>ingroup()</a> verf&uuml;gbar zu haben, vermeiden Sie bitte ';' innerhalb der Apostrophe
                                          (also nicht <tt>'run myexport.ulp;'</tt>,sondern <tt>'run myexport.ulp'</tt>).</td></tr>
<tr><td>Knickwinkel f&uuml;r Wires    </td><td width=20><td><tt>SET WIRE_BEND bend_nr;</tt></td></tr>
<tr><td>                         </td><td width=20><td><i>bend_nr</i> kann einer der folgenden Werte sein:</td></tr>
<tr><td>                         </td><td width=20><td><tt>0</tt>: Startpunkt - waagrecht - senkrecht - Endpunkt</td></tr>
<tr><td>                         </td><td width=20><td><tt>1</tt>: Startpunkt - waagrecht - 45&deg; - Endpunkt</td></tr>
<tr><td>                         </td><td width=20><td><tt>2</tt>: Startpunkt - Endpunkt (direkte Verbindung)</td></tr>
<tr><td>                         </td><td width=20><td><tt>3</tt>: Startpunkt - 45&deg; - waagrecht - Endpunkt</td></tr>
<tr><td>                         </td><td width=20><td><tt>4</tt>: Startpunkt - senkrecht - waagrecht - Endpunkt</td></tr>
<tr><td>                         </td><td width=20><td><tt>5</tt>: Startpunkt - Kreisbogen - waagrecht - Endpunkt</td></tr>
<tr><td>                         </td><td width=20><td><tt>6</tt>: Startpunkt - waagrecht - Kreisbogen - Endpunkt</td></tr>
<tr><td>                         </td><td width=20><td><tt>7</tt>: "Freihand" (Kreisbogen passend zum Wire am Startpunkt, ansonsten gerade)</td></tr>
<tr><td>                         </td><td width=20><td><tt>8</tt>: Kurzes Ende der Luftlinie im <a href=#94>Follow-me-Router</a> verlegen</td></tr>
<tr><td>                         </td><td width=20><td><tt>9</tt>: Beide Enden der Luftlinie im <a href=#94>Follow-me-Router</a> verlegen</td></tr>
<tr><td>                         </td><td width=20><td>Beachten Sie bitte, dass <tt>0</tt>, <tt>1</tt>, <tt>3</tt> und <tt>4</tt> zus&auml;tzliche Wires zur Abschr&auml;gung enthalten k&ouml;nnen (siehe <a href=#69>MITER</a>).</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET WIRE_BEND @ bend_nr ...;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Legt fest welche Knickwinkel beim Weiterschalten mit der rechten Maustaste tats&auml;chlich durchlaufen werden sollen.</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET WIRE_BEND @;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Schaltet zur&uuml;ck auf alle Knickwinkel.</td></tr>
<tr><td>Piepston ein/aus         </td><td width=20><td><tt>SET BEEP OFF | ON;</tt></td></tr>
</table>
<h2>Bildschirmdarstellung</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Farbe f&uuml;r Grid-Linien    </td><td width=20><td><tt>SET COLOR_GRID color;</tt></td></tr>
<tr><td>Farbe f&uuml;r Layer          </td><td width=20><td><tt>SET COLOR_LAYER layer color;</tt></td></tr>
<tr><td>F&uuml;llmuster f&uuml;r Layer     </td><td width=20><td><tt>SET FILL_LAYER layer fill;</tt></td></tr>
<tr><td>Raster-Parameter         </td><td width=20><td><tt>SET MIN_GRID_SIZE pixels;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Das Grid wird nur dann gezeichnet, wenn der Rasterabstand gr&ouml;&szlig;er ist als die eingestellte Zahl von Pixeln.</td></tr>
<tr><td>Min. darg. Textgr&ouml;&szlig;e     </td><td width=20><td><tt>SET MIN_TEXT_SIZE size;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Texte, die weniger als <tt>size</tt> Bildpunkte hoch sind, werden auf dem Bildschirm als Rechtecke dargestellt. Einstellung <tt>0</tt> bedeutet: alle Texte werden lesbar dargestellt.</td></tr>
<tr><td>Netz-Linien-Darstellung  </td><td width=20><td><tt>SET NET_WIRE_WIDTH width;</tt></td></tr>
<tr><td>Pad-Darstellung          </td><td width=20><td><tt>SET DISPLAY_MODE REAL | NODRILL;</tt></td></tr>
<tr><td>                         </td><td width=20><td>REAL: Pads werden dargestellt, wie sie geplottet werden.<br>NODRILL: Pads werden ohne Bohrung dargestellt.</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET PAD_NAMES OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Pad-Namen werden ein-/ausgeblendet.</td></tr>
<tr><td>Bus-Linien-Darstellung   </td><td width=20><td><tt>SET BUS_WIRE_WIDTH width;</tt></td></tr>
<tr><td><a href=#48>DRC</a>-Parameter </td><td width=20><td><tt>SET DRC_FILL fill_name;</tt></td></tr>
<tr><td>Polygon-Berechnung       </td><td width=20><td><tt>SET POLYGON_RATSNEST OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Siehe <a href=#81>POLYGON</a>-Befehl.</td></tr>
<tr><td>Vector Font              </td><td width=20><td><tt>SET VECTOR_FONT OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Siehe <a href=#104>TEXT</a>-Befehl.</td></tr>
<tr><td>Querverweis-Labels       </td><td width=20><td><tt>SET XREF_LABEL_FORMAT string;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Siehe <a href=#62>LABEL</a>-Befehl.</td></tr>
<tr><td>Bauteil-Querverweise     </td><td width=20><td><tt>SET XREF_PART_FORMAT string;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Siehe <a href=#104>TEXT</a>-Befehl.</td></tr>
</table>
<h2>Mode-Parameter</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Package-Check            </td><td width=20><td><tt>SET CHECK_CONNECTS OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Der <a href=#30>ADD</a>-Befehl pr&uuml;ft, ob bei einem Device jedem Pin ein Pad (mit <a href=#41>CONNECT</a>) zugewiesen ist. Diese Pr&uuml;fung l&auml;sst sich abschalten. Allerdings kann keine Platine aus einem Schaltplan erzeugt werden, falls ein Device ohne Geh&auml;use gefunden wird.</td></tr>
<tr><td><a href=#91>REPLACE</a>-Modus            </td><td width=20><td><tt>SET REPLACE_SAME NAMES | COORDS;</tt></td></tr>
<tr><td><a href=#105>UNDO</a>-Puffer ein/aus      </td><td width=20><td><tt>SET UNDO_LOG OFF | ON;</tt></td></tr>
<tr><td>Wire-Optimierung         </td><td width=20><td><tt>SET OPTIMIZING OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Wires, die nach MOVE, ROUTE oder SPLIT in einer Linie liegen, werden zu einem Wire zusammengefasst, falls <i>On</i> eingestellt ist. Siehe auch <a href=#75>OPTIMIZE</a>.</td></tr>
<tr><td>Net-Wire beenden         </td><td width=20><td><tt>SET AUTO_END_NET OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Automatisches Beenden von Netzen oder Bussen. Siehe <a href=#73>NET</a> oder <a href=#36>BUS</a>.</td></tr>
<tr><td>Automatische Junctions   </td><td width=20><td><tt>SET AUTO_JUNCTION OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Automatisches Setzen von Junctions. Siehe <a href=#61>JUNCTION</a>.</td></tr>
<tr><td>Automatische Best&auml;tigung </td><td width=20><td><tt>SET CONFIRM OFF | NO | YES;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Erm&ouml;glicht die automatische Behandlung von Best&auml;tigungs-Dialogen (weiteres siehe unten).</td></tr>
</table>
<h2>Farben</h2>
Es gibt drei <i>Paletten</i> f&uuml;r schwarzen, wei&szlig;en und farbigen Hintergrund.
Jede Palette hat 64 Farb-Eintr&auml;ge, die auf jeden beliebigen ARGB-Wert
gesetzt werden k&ouml;nnen. Der Paletten-Eintrag 0 wird f&uuml;r die Hintergrundfarbe
verwendet (in der "wei&szlig;en" Palette ist dieser Eintrag nicht
ver&auml;nderbar, da diese Palette auch zum Ausdrucken verwendet wird, wo der
Hintergrund immer wei&szlig; ist).
<p>
Die Farbpaletten k&ouml;nnen entweder &uuml;ber den Dialog unter
"Optionen/Einstellungen/Farben" ver&auml;ndert werden, oder mittels des Befehls
<pre>
SET PALETTE <i>index</i> <i>argb</i>
</pre>
wobei <i>index</i> eine Zahl im Bereich 0..63 und <i>argb</i> ein hexadezimaler
Wert ist, der die Alpha-, Rot-, Gr&uuml;n- und Blau-Komponenten der Farbe definiert,
etwa 0xFFFFFF00 (was ein helles Gelb ergeben w&uuml;rde). Die Alpha-Komponente gibt an
wie "deckend" die Farbe ist. Ein Wert von 0x00 bedeutet, dass die Farbe vollkommen
transparent ist (d.h. unsichtbar), w&auml;hrend 0xFF f&uuml;r eine vollkommen deckende Farbe steht.
Die Alpha-Komponente der Hintergrundfarbe ist immer 0xFF.
Beachten Sie bitte, dass der ARGB-Wert mit "0x" beginnen muss, ansonsten w&uuml;rde er als
dezimale Zahl interpretiert werden. Mit dem Befehl
<pre>
SET PALETTE BLACK|WHITE|COLORED
</pre>
k&ouml;nnen Sie auf die Palette f&uuml;r schwarzen, wei&szlig;en oder farbigen Hintergrund
umschalten. Beachten Sie bitte, dass nach diesem Befehl kein automatisches
Neuzeichnen des Zeichenfensters stattfindet; Sie sollten daher anschlie&szlig;end
den Befehl WINDOW; ausf&uuml;hren.
<p>
Standardm&auml;&szlig;ig werden nur die Paletten-Eintr&auml;ge 0..15 benutzt und diese
enthalten die unten aufgef&uuml;hrten Farben.
<p>
Die Paletten-Eintr&auml;ge sind unterteilt in "normale" und "hervorgehobene"
Farben. Es gibt immer 8 "normale" Farben, gefolgt von den 8 zugeh&ouml;rigen
"hervorgehobenen" Farben. Die Farben 0..7 sind somit "normale" Farben,
8..15 sind ihre "hervorgehobenen" Werte, 16..23 sind weitere 8 "normale"
Farben mit 24..31 als deren "hervorgehobene" Werte und so weiter. Die
"hervorgehobenen" Farben werden benutzt um Objekte hervorzuheben, wie zum
Beispiel im SHOW-Befehl.
<p>
<tt>Color</tt>, geordnet nach Farbnummern, die anstelle von
color verwendet werden k&ouml;nnen. Damit legt man die Farbe fest:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>0       </td><td width=20><td>Black</td></tr>
<tr><td>1       </td><td width=20><td>Blue</td></tr>
<tr><td>2       </td><td width=20><td>Green</td></tr>
<tr><td>3       </td><td width=20><td>Cyan</td></tr>
<tr><td>4       </td><td width=20><td>Red</td></tr>
<tr><td>5       </td><td width=20><td>Magenta</td></tr>
<tr><td>6       </td><td width=20><td>Brown</td></tr>
<tr><td>7       </td><td width=20><td>LGray</td></tr>
<tr><td>8       </td><td width=20><td>DGray</td></tr>
<tr><td>9       </td><td width=20><td>LBlue</td></tr>
<tr><td>10      </td><td width=20><td>LGreen</td></tr>
<tr><td>11      </td><td width=20><td>LCyan</td></tr>
<tr><td>12      </td><td width=20><td>LRed</td></tr>
<tr><td>13      </td><td width=20><td>LMagenta</td></tr>
<tr><td>14      </td><td width=20><td>Yellow</td></tr>
<tr><td>15      </td><td width=20><td>White</td></tr>
</table>
<p>
<tt>Fill</tt> legt die Art fest, wie Wires und Rectangles in einem
bestimmten Layer gef&uuml;llt werden sollen. Auch dieser Parameter kann
durch die am Anfang der Zeile stehende Zahl ersetzt werden:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>0       </td><td width=20><td>Empty</td></tr>
<tr><td>1       </td><td width=20><td>Solid</td></tr>
<tr><td>2       </td><td width=20><td>Line</td></tr>
<tr><td>3       </td><td width=20><td>LtSlash</td></tr>
<tr><td>4       </td><td width=20><td>Slash</td></tr>
<tr><td>5       </td><td width=20><td>BkSlash</td></tr>
<tr><td>6       </td><td width=20><td>LtBkSlash</td></tr>
<tr><td>7       </td><td width=20><td>Hatch</td></tr>
<tr><td>8       </td><td width=20><td>XHatch</td></tr>
<tr><td>9       </td><td width=20><td>Interleave</td></tr>
<tr><td>10      </td><td width=20><td>WideDot</td></tr>
<tr><td>11      </td><td width=20><td>CloseDot</td></tr>
<tr><td>12      </td><td width=20><td>Stipple1</td></tr>
<tr><td>13      </td><td width=20><td>Stipple2</td></tr>
<tr><td>14      </td><td width=20><td>Stipple3</td></tr>
<tr><td>15      </td><td width=20><td>Stipple4</td></tr>
</table>
<h2>Automatische Best&auml;tigung</h2>
Manchmal zeigt EAGLE dem Benutzer Informationen bzw. Warnungen an, oder
verlangt nach einer Entscheidung, wie weiter verfahren werden soll.
Dies mag bei automatisierten Abl&auml;ufen (wie <a href=#96>Skripten</a>)
unerw&uuml;nscht sein.
Der Befehl
<pre>
SET CONFIRM YES
</pre>
sorgt daf&uuml;r, dass jeder Mitteilungs-Dialog automatisch so best&auml;tigt wird,
als h&auml;tte der Benutzer den "positiven" Button ("OK" bzw. "Ja") angeklickt.
Der Dialog selbst wird &uuml;berhaupt nicht dargestellt.
Entsprechend wirkt der Befehl
<pre>
SET CONFIRM NO
</pre>
als h&auml;tte der Benutzer den "negativen" Button ("Nein") angeklickt, falls
ein solcher vorhanden ist. Andernfalls wird der Dialog einfach best&auml;tigt.
Schlie&szlig;lich schaltet
<pre>
SET CONFIRM OFF
</pre>
die automatische Best&auml;tigung wieder aus. Wird die automatische Best&auml;tigung
nicht explizit ausgeschaltet, so f&auml;llt sie automatisch auf <tt>OFF</tt>
zur&uuml;ck, sobald das Editor-Fenster wieder eine interaktive Eingabe des
Benutzers annimmt.
<p>
Sie sollten nicht ein <tt>SET CONFIRM YES</tt> an den Anfang eines Scripts
setzen und dann viele Befehle "im Stillen" ausf&uuml;hren. Besser ist es, dies
gezielt auf einzelne Befehle anzuwenden, wie in
<pre>
SET CONFIRM YES
REMOVE <i>filename</i>
SET CONFIRM OFF
</pre>
<b>Seien Sie extrem vorsichtig bei der Verwendung dieses Befehls!
Mitteilungs-Dialoge blind zu best&auml;tigen kann dazu f&uuml;hren, dass wichtige
Mitteilungen &uuml;bersehen werden. Das Ergebnis kann dann unter Umst&auml;nden nicht
das sein, was der Benutzer erwartet.</b>
<h2>EagleRc-Parameter</h2>
Manchmal ist es notwendig, ein kleines Funktionsdetail einstellbar zu machen,
zum Beispiel weil einige Benutzer es unbedingt anders haben wollen.
Diese Parameter sind nicht in irgendwelchen Dialogen verf&uuml;gbar, sondern k&ouml;nnen
ausschlie&szlig;lich &uuml;ber einen Eintrag in der eaglerc-Datei ver&auml;ndert werden.
Um dieses zu vereinfachen wird jeder Parameter, der nicht in obigen Schl&uuml;sselw&ouml;rtern
gefunden wurde, in den eaglerc-Parametern gesucht und kann so mit dem SET-Befehl
ver&auml;ndert werden. Im Prinzip k&ouml;nnen Sie so jeden Parameter der eaglerc-Datei ver&auml;ndern.
Beachten Sie bitte, dass die Parameternamen vollst&auml;ndig und genau so, wie unten
aufgelistet, angegeben werden m&uuml;ssen (auch bez&uuml;glich Gro&szlig;-/Kleinschreibung).
Der Parameterwert ist typischerweise '0' oder '1', um eine Funktion aus- bzw.
einzuschalten. Nach der Ver&auml;nderung eines Parameters, der die Bildschirmdarstellung
beeinflu&szlig;t, kann es n&ouml;tig sein, das Zeichenfenster aufzufrischen.
<p>
<b>Beispiel</b>
<pre>
SET Option.DrawUnprocessedPolygonEdgesContinuous 1;
</pre>
Folgende eaglerc-Parameter stehen f&uuml;r Spezial-Einstellungen zur Verf&uuml;gung:
<p>
<dl>
<dt><b>Cmd.Copy.ClassicEagleMode</b>
<dd>
In &auml;lteren EAGLE-Versionen wurde der COPY-Befehl ausschlie&szlig;lich dazu benutzt,
Objekte innerhalb einer Zeichnung zu kopieren - anders als in Windows, wo
COPY eine Kopie der selektierten Objekte (also der GRUPPE) in die
Zwischenablage des Systems platziert.
Ab Version 6 verh&auml;lt sich der COPY-Befehl in EAGLE prim&auml;r wie in anderen
Windows-Applikationen, indem er eine Kopie der aktuellen Gruppe in die
Zwischenablage legt. Die urspr&uuml;ngliche Funktion des Kopierens selektierter
Objekte, oder des Kopierens von Bibliothekselementen zwischen Bibliotheken,
bleibt weiterhin vollst&auml;ndig verf&uuml;gbar. Dies ist insbesondere wichtig,
damit bestehende Scripts und ULPs weiterhin funktionieren.
Was Windows-Anwender auch h&auml;ufig irritiert hat ist, dass in EAGLE der CUT-Befehl
die selektierte Gruppe lediglich in die Zwischenablage kopiert, sie aber nicht
aus der Zeichnung gel&ouml;scht hat. Da ein CUT-Befehl, der die Gruppe l&ouml;scht,
in einem Board-/Schematic-Paar das &uuml;ber Forward- und Backannotation verbunden
ist, nicht wirklich sinnvoll w&auml;re, wurde dieser Befehl aus dem Pulldown-Men&uuml;
und der Toolbar mit den Befehls-Buttons entfernt. Er steht weiterhin &uuml;ber
die Befehlszeile und in Scripts zur Verf&uuml;gung.
Wird dieser Parameter auf '1' gesetzt, so wird die alte Verhaltensweise
des COPY- sowie des CUT-Befehls wieder hergestellt. Beachten Sie bitte, dass
diese Einstellung erst beim n&auml;chsten &Ouml;ffnen eines Editor-Fensters wirksam
wird.
<dt><b>Cmd.Delete.WireJointsWithoutCtrl</b>
<dd>
Falls Sie wollen, dass der DELETE-Befehl Wire-Verbindungspunkte l&ouml;scht, ohne dass
die Ctrl-Taste gedr&uuml;ckt wird, so k&ouml;nnen Sie diesen Parameter auf '1' setzen.
<dt><b>Cmd.Name.RenameEntireNetByDefault</b>
<dd>
Besteht ein Netz aus mehreren Segmenten, so wirkt der NAME-Befehl standardm&auml;&szlig;ig nur
auf das selektierte Segment. Wird dieser Parameter auf '1' gesetzt, so wird
standardm&auml;&szlig;ig das gesamte Netz umbenannt.
Dieser Parameter gilt auch f&uuml;r Busse.
<dt><b>Cmd.Name.RenameEntireSignalByDefault</b>
<dd>
Enth&auml;lt ein Signal ein Polygon, und der NAME-Befehl wird auf dieses Polygon
angewendet, so wird standardm&auml;&szlig;ig nur das Polygon umbenannt. Wird dieser Parameter
auf '1' gesetzt, so wird standardm&auml;&szlig;ig das gesamte Signal umbenannt.
<dt><b>Cmd.Wire.IgnoreCtrlForRadiusMode</b>
<dd>
Falls Sie die spezielle Funktion beim Zeichnen eines Wires, mit der man durch
Dr&uuml;cken von Ctrl den Radius eines Arcs definieren kann, nicht haben wollen,
so k&ouml;nnen Sie diesen Parameter auf '1' setzen.
Dadurch wird dieses Feature f&uuml;r alle Befehle, die Wires zeichnen, abgeschaltet.
<dt><b>ControlPanel.View.AutoOpenProjectFolder</b>
<dd>
Das automatische &Ouml;ffnen des Projekt-Verzeichnisses beim Programmstart
(bzw. wenn ein Projekt durch Klicken auf seinen grauen Button aktiviert
wird) kann durch Setzen dieses Parameters auf '0' abgeschaltet werden.
<dt><b>Erc.AllowUserOverrideConsistencyCheck</b>
<dd>
Um Boards/Schematics bearbeiten zu k&ouml;nnen, die nur geringf&uuml;gige
Inkonsistenzen aufweisen, k&ouml;nnen Sie durch Setzen dieses Parameters
auf '1' einen Dialog aktivieren der es Ihnen erlaubt den Editor dazu zu zwingen,
die Forward-/Backannotation durchzuf&uuml;hren, selbst wenn der ERC die Dateien als
inkonsistent erkannt hat.
<b>BEACHTEN SIE BITTE, DASS SIE DIES AUF EIGENES RISIKO MACHEN</b> - sollten die
Dateien danach zerst&ouml;rt werden, kann wom&ouml;glich niemand mehr sie wiederherstellen.
Schlie&szlig;lich <b>hat</b> der ERC ja gemeldet, dass die Dateien inkonsistent sind!
<dt><b>Interface.MouseButtonReleaseTimeout</b>
<dd>
Die Zeit (in Millisekunden) innerhalb der das Loslassen einer Maustaste, welches
dem Dr&uuml;cken der Maustaste auf einem Button (zum Beispiel in einer Toolbar) folgt,
die Funktion des Buttons ausl&ouml;st, selbst wenn das Loslassen der Maustaste
ausserhalb der Fl&auml;che des Buttons erfolgte. Standardwert ist 500, der Wert 0
schaltet diese Funktion ab. Hat dieser Parameter beim Programmstart den Wert 0,
so wirken sich etwaige &Auml;nderungen erst nach einem erneuten Programmstart aus.
<dt><b>Interface.PreferredUnit</b>
<dd>
Bei der Anzeige numerischer Werte in Dialog-Eingabefeldern werden die Einheiten
automatisch so ermittelt, dass sich die kleinste Anzahl von Nachkommastellen ergibt.
Dies kann beeinflusst werden durch Setzen dieses Parameters auf
'0' f&uuml;r automatische Wahl der Einheiten (default),
'1' f&uuml;r z&ouml;llige Einheiten,
'2' f&uuml;r metrische Einheiten.
<dt><b>Interface.UseCtrlForPanning</b>
<dd>
Das Verschieben des Zeichnungsauschnittes erfolgt durch Click&amp;Drag
mit der mittleren Maustaste (nicht mehr durch Dr&uuml;cken der Ctrl-Taste wie
in &auml;lteren Versionen).
Falls Sie die alte Verhaltensweise wiederhaben wollen, k&ouml;nnen Sie dies
erreichen, indem Sie diesen Parameter auf '1' setzen.
Beachten Sie aber bitte, dass die Ctrl-Taste jetzt f&uuml;r spezielle Funktionen
einiger Befehle benutzt wird (zum Beispiel zum Selektieren von Objekten
an ihrem Aufh&auml;ngepunkt bei MOVE), so dass Sie, bei Benutzung dieser speziellen
Funktionen, dann unter Umst&auml;nden das Zeichenfenster unbeabsichtigt
verschieben k&ouml;nnen.
<dt><b>Interface.VectorFont</b>
<dd>
Texte in Zeichnungen werden immer im EAGLE-eigenen Vektor-Font dargestellt,
unabh&auml;ngig welche Schriftart f&uuml;r einen Text urspr&uuml;nglich gew&auml;hlt wurde
und unabh&auml;ngig von der Einstellung durch
<tt><a href=#97>SET</a> VECTOR_FONT OFF|ON</tt> in der
aktuellen Zeichnung. Siehe <a href=#104>TEXT</a>-Befehl.
<dt><b>Option.AutoLoadMatchingDrawingFile</b>
<dd>
Falls Sie ein Board- und Schaltplaneditor-Fenster offen haben und in einem dieser
Fenster ein anderes Board (bzw. einen anderen Schaltplan) laden, und wenn es f&uuml;r
diese andere Zeichnung einen zugeh&ouml;rigen Schaltplan (bzw. ein zugeh&ouml;riges Board)
gibt, so fragt EAGLE, ob diese andere Zeichnung ebenfalls geladen werden soll.
Indem Sie diesen Parameter auf '1' setzen, kann diese Frage unterdr&uuml;ckt werden,
und EAGLE l&auml;dt die andere Datei dann immer automatisch mit.
<dt><b>Option.Codec</b>
<dd>
Gezieltes Setzen eines Codecs (z.B. beim Schreiben mit ULP output()). G&uuml;ltige Werte
sind: "System", "UTF-8" und "ISO 8859-1". Alle anderen Werte f&uuml;hren zur Verwendung
der System-Einstellung.
<dt><b>Option.DrawUnprocessedPolygonEdgesContinuous</b>
<dd>
Falls Ihnen die Art, wie die Kanten von nicht berechneten Polygonen
dargestellt werden (als gepunktete Linien), nicht zusagt, so k&ouml;nnen Sie
diesen Parameter auf '1' setzen.
Die Kanten von nicht berechneten Polygonen werden dann wieder als
durchgezogene Linien dargestellt, wie es vor Version 5 der Fall war
(allerdings nicht hell).
<dt><b>Option.LayerSequence</b>
<dd>
Die internen Layer werden in der Reihenfolge dargestellt, die dem tats&auml;chlichen
Lagenaufbau entspricht, so dass das Ergebnis auch auf Druckern und PDF- bzw.
Postscript-Dateien brauchbar aussieht, wo die Layer nicht transparent sind.
Manchmal kann es erforderlich sein, dass benutzerdefinierte Layer vor den internen
Layern dargestellt werden m&uuml;ssen, anstatt nach diesen. Mit diesem Parameter kann
die Reihenfolge, in der die Layer dargestellt werden, festgelegt werden.
Er besteht aus einer Folge von Layer-Nummern bzw. Layer-Bereichen, optional gefolgt
von 't' oder 'b'.
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>123</td> <td width=20><td>stellt Layer 123 dar</td></tr>
<tr><td>123t</td><td width=20><td>stellt Layer 123 dar, wenn die Ausgabe "von oben gesehen" erfolgt (nicht gespiegelt)</td></tr>
<tr><td>123b</td><td width=20><td>stellt Layer 123 dar, wenn die Ausgabe "von unten gesehen" erfolgt (gespiegelt)</td></tr>
<tr><td>123-140</td><td width=20><td>stellt die Layer 123 bis 140 in der angegeben Reihenfolge dar</td></tr>
<tr><td>140-123</td><td width=20><td>stellt die Layer 140 bis 123 in der angegeben Reihenfolge dar</td></tr>
<tr><td>*</td><td width=20><td>f&uuml;gt die Standard-Sequenz der internen Layer ein</td></tr>
<tr><td>123b * 123t</td><td width=20><td>sorgt daf&uuml;r, dass Layer 123 immer als erster dargestellt wird</td></tr>
</table>
<dd>
Beachten Sie, dass jeder Layer nur einmal dargestellt wird, auch wenn er mehrmals
aufgef&uuml;hrt ist. Die Standard-Sequenz der internen Layer ist<br>
48t 49t 19t 47t 20t 46t 23 27 25 59 57 55 53 50 51 21 44t 45t 37 35 31 29 33 39 41 43t 18t 17t 1-16 17b 18b 43b 42 40 34 30 32 36 38 45b 44b 22 52 54 56 58 60 26 28 24 46b 20b 47b 19b 49b 48b 61-99.<br>
Bei Ansicht von oben, wird die Layer-Sequenz von rechts nach links abgearbeitet,
w&auml;hrend sie bei Ansicht von unten (gespiegelt) von links nach rechts abgearbeitet wird.
Zum Beispiel ist Layer 48 (Document) als 48t und 48b enthalten, damit dieser immer
als letzter dargestellt wird. Die Layer 21 (tPlace) und 22 (bPlace) hingegen sind
nur jeweils einmal aufgelistet, damit Sie an der richtigen Stelle erscheinen, je
nachdem, ob die Ausgabe gespiegelt erfolgt oder nicht.<br>
Alle nicht explizit in der Layer-Sequenz aufgef&uuml;hrten Layer werden nach der
gegebenen Sequenz, in aufsteigender Reihenfolge, dargestellt.
<dt><b>Option.RatsnestLimit</b>
<dd>
Der RATSNEST-Befehl verwendet alle Punkte eines Signals, auch wenn
dieses sehr komplex ist (in fr&uuml;heren Versionen blieben Wire-Endpunkte
unber&uuml;cksichtigt, wenn die Gesamtzahl der Ankn&uuml;pfungspunkte gr&ouml;&szlig;er als 254
war). Hierf&uuml;r wird mehr Speicherplatz beim Berechnen des Ratsnest ben&ouml;tigt.
Falls dies auf Ihrem System ein Problem darstellen sollte, so k&ouml;nnen Sie
auf die urspr&uuml;ngliche Methode zur&uuml;ckschalten indem Sie diesen Parameter
auf '254' setzen.
Der angegebene Wert ist die Anzahl der Ankn&uuml;pfungspunkte bis zu der Wire-
Endpunkte ber&uuml;cksichtigt werden und beschr&auml;nkt somit den Speicherbedarf
(die Berechnung benutzt Speicher bis zum Quadrat des angegebenen Wertes,
so dass ein Wert von 1024 den verwendeten Speicher auf 1MB beschr&auml;nkt).
Ein Wert von '0' steht f&uuml;r "keine Begrenzung". Ein Wert von '1' bewirkt,
das Luftlinien ausschlie&szlig;lich an Pads, Smds und Vias ankn&uuml;pfen.
<dt><b>Option.RepositionMouseCursorAfterContextMenu</b>
<dd>
Normalerweise ver&auml;ndert EAGLE die Position des Mauszeigers nicht von sich aus.
Es gibt allerdings Benutzer, die m&ouml;chten, dass der Mauszeiger auf den Punkt
zur&uuml;ckpositioniert wird, an dem er war, bevor ein Kontext-Men&uuml; im Zeichnungseditor
ge&ouml;ffnet wurde. Setzen Sie diesen Parameter auf '1' um diese Funktionalit&auml;t
zu erhalten.
<dt><b>Option.ShowPartOrigins</b>
<dd>
Die Aufh&auml;ngepunkte von Bauteilen in einem Schaltplan werden durch kleine
Kreuze gekennzeichnet.
Setzen Sie diesen Parameter auf '0' um dies abzuschalten.
<dt><b>Option.ShowTextOrigins</b>
<dd>
Die Aufh&auml;ngepunkte von Texten werden durch kleine
Kreuze gekennzeichnet.
Setzen Sie diesen Parameter auf '0' um dies abzuschalten.
<dt><b>Option.ToggleCtrlForGroupSelectionAndContextMenu</b>
<dd>
Da die Kontext-Men&uuml;-Funktion &uuml;ber die rechte Maustaste im Konflikt mit
der Selektion einer Gruppe, wie sie vor Version 5 erfolgte,  steht, wird eine
Gruppe jetzt mit Ctrl plus rechte Maustaste selektiert. Falls Sie die bisherige
Art der Gruppenselektierung wieder haben wollen, so k&ouml;nnen Sie diesen
Parameter auf '1' setzen.
Damit k&ouml;nnen Gruppen wieder mit der rechten Maustaste allein selektiert
werden und Kontext-Men&uuml;s werden mit Ctrl plus rechte Maustaste ge&ouml;ffnet.
<dt><b>Option.UnpopulatedMarkScaling</b>
<dd>
Mit diesem Parameter ist es m&ouml;glich die Gr&ouml;&szlig;e der Markierung von in einer
Best&uuml;ckungsvariante nicht best&uuml;ckten Bauteilen zu skalieren.
Der Standardwert ist '1.0'.
<dt><b>Sch.Cmd.Add.AlwaysUseDeviceNameAsValue</b>
<dd>
Einige Benutzer wollen immer den Device-Namen als Bauteilwert verwenden,
selbst wenn das Bauteil einen benutzerdefinierten Wert br&auml;uchte. Wer das
will kann diesen Parameter auf '1' setzen.
<dt><b>Warning.Cam.DrillsAndHolesConcurrent</b>
<dd>
Falls Sie die Warnung, dass Drills und Holes im CAM Prozessor gleichzeitig
ausgegeben werden sollen, nicht haben wollen, k&ouml;nnen Sie diesen Parameter
auf '0' setzen.
<dt><b>Warning.PartHasNoUserDefinableValue</b>
<dd>
Falls Sie die Warnung bez&uuml;glich Bauteilen, die keinen vom Benutzer zu
vergebenden Wert haben, nicht haben wollen, k&ouml;nnen Sie diesen Parameter
auf '0' setzen.
<dt><b>Warning.SupplyPinAutoOverwriteGeneratedNetName</b>
<dd>
Manche Benutzer wollen nicht gewarnt werden, wenn ein Supply-Pin den
generierten Standardnamen (beginnend mit N$) eines bestehenden Netzsegments &uuml;berschreibt.
Wird dieser Parameter auf '1' gesetzt, so wird diese Warnung abgeschaltet.
</dl>


<a name=98>
<h1>SHOW</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Stellt Objekte hervorgehoben dar.
<dt>
<b>Syntax</b>
<dd>
<tt>SHOW &#149;..</tt><br>
<tt>SHOW name..</tt><br>
<tt>SHOW @ name..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Linke</mb> invertiert die Hervorhebung des selektierten Objekts.<br>
</dl>
<b>Siehe auch</b> <a href=#59>INFO</a>
<p>
Der SHOW-Befehl dient zum Hervorheben von Objekten.
Einzelheiten werden in der Statuszeile aufgelistet.
Mit SHOW kann man auch ganze Signale und Netze
hervorheben (auf dem Bildschirm heller dargestellt).
Wird ein Bus ausgew&auml;hlt, so werden auch alle zu diesem Bus geh&ouml;renden
Netze hervorgehoben.
<h2>Quervergleich zwischen Platine und Schaltplan</h2>
Bei aktivierter <a href=#372>Forward&amp;Back-Annotation</a>
wird ein Objekt, das mit Hilfe des SHOW-Befehls heller dargestellt wird,
sowohl im Schaltplan als auch in der Platine heller dargestellt.
<h2>Mehrere Objekte</h2>
Wenn Sie mehrere Objekte mit dem SHOW-Befehl selektieren, wird jedes
einzelne hell dargestellt.
Sie k&ouml;nnen mehrere Objekte gleichzeitig hervorheben indem Sie diese jeweils
mit gedr&uuml;ckter Ctrl-Taste anklicken. Klicken Sie mit gedr&uuml;ckter Ctrl-Taste
auf ein Objekt, das bereits hervorgehoben dargestellt ist, so wird dieses
Objekt wieder in den nicht hervorgehobenen Zustand versetzt.
<p>
Werden mehrere Namen in einer Zeile eingegeben, so werden alle entsprechenden
Objekte gleichzeitig hell dargestellt.
<h2>Kleine Objekte</h2>
Wird das Zeichen <tt>@</tt> in der Kommandozeile angegeben, so wird ein Rechteck
um das hervorgehobene Objekt gezeichnet. Dies ist hilfreich bei der Suche nach
kleinen Objekten, die durch blo&szlig;es Hervorheben nicht leicht zu finden w&auml;ren.
Wird mehr als ein Objekt hervorgehoben, so wird das Rechteck um alle Objekte
gezeichnet. Um das Rechteck zu sehen, kann es erforderlich sein, aus der Zeichnung
herauszuzoomen (oder WINDOW FIT einzugeben).
Soll ein Objekt mit dem Namen <tt>@</tt> hervorgehoben werden, so muss der Name
in einfache Hochkommas eingeschlossen werden.
<h2>Platzhalter</h2>
Falls der <tt>name</tt>-Parameter angegeben wurde, so sind die Zeichen <tt>'*'</tt>, <tt>'?'</tt>
und <tt>'[]'</tt> <i>Platzhalter</i> und haben folgende Bedeutung:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>*</tt>  </td><td width=20><td>steht f&uuml;r eine beliebige Anzahl beliebiger Zeichen</td></tr>
<tr><td><tt>?</tt>           </td><td width=20><td>steht f&uuml;r genau ein Zeichen</td></tr>
<tr><td><tt>[...]</tt>       </td><td width=20><td>steht f&uuml;r irgend eines der Zeichen zwischen den Klammern</td></tr>
</table>
<p>
Soll eines dieser Zeichen genau so gesucht werden, wie es ist, so muss es in eckige Klammern
eingeschlossen werden. Zum Beispiel findet <tt>abc[*]ghi</tt> die Zeichenfolge <tt>abc*ghi</tt>,
aber nicht <tt>abcdefghi</tt>.
<p>
Ein Bereich von Zeichen kann als <tt>[a-z]</tt> angegeben werden, was f&uuml;r eines der Zeichen
aus dem Bereich <tt>'a'</tt>...<tt>'z'</tt> steht.
<p>
Die spezielle Zeichenfolge <tt>[Zahl..Zahl]</tt> stellt einen <a href=#36>Busnamen mit Index</a>
dar und wird deshalb im Schaltplan nicht als Platzhalter behandelt.
<h2>Objekte auf anderen Seiten</h2>
Wird ein namentlich genanntes Objekt nicht auf der aktuellen Schaltplanseite
gefunden, so erscheint ein Dialog mit einer Liste aller Seiten, auf denen dieses
Objekt gefunden wurde. Wurde das Objekt auf keiner Seite gefunden, so wird als
Seitennummer in dieser Liste '-' angezeigt. Beachten Sie bitte, dass dieser Dialog
nur dann erscheint, wenn mindestens eines der durch Namen (bzw. Platzhalter)
angegebenen Objekte nicht auf der aktuellen Seite gefunden wurde. Wurden alle
Objekte auf der aktuellen Seite gefunden, so erscheint kein Dialog (selbst, wenn
einige Objekte auch auf anderen Seiten vorkommen). Wenn der Dialog erscheint, dann
enth&auml;lt er alle gefundenen Objekte, auch diejenigen auf der aktuellen Seite.
<h2>Beispiele</h2>
<pre>
SHOW IC1
</pre>
IC1 wird hell und bleibt hell, bis der SHOW-Befehl beendet oder
ein anderer Name eingegeben wird.
<pre>
SHOW IC*
</pre>
Zeigt alle Objekte an deren Namen mit "IC" beginnt.


<a name=99>
<h1>SIGNAL</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Signale definieren.
<dt>
<b>Syntax</b>
<dd>
<tt>SIGNAL &#149; &#149;..</tt><br>
<tt>SIGNAL signal_name &#149; &#149;..</tt><br>
<tt>SIGNAL signal_name element_name pad_name..;</tt>
</dl>
<b>Siehe auch</b> <a href=#34>AUTO</a>,
<a href=#94>ROUTE</a>,
<a href=#72>NAME</a>,
<a href=#39>CLASS</a>,
<a href=#112>WIRE</a>,
<a href=#86>RATSNEST</a>,
<a href=#52>EXPORT</a>
<p>
Mit dem SIGNAL-Befehl definiert man Signale, also die Verbindungen
zwischen den Anschl&uuml;ssen der Packages. Es sind mindestens zwei
St&uuml;tzstellen anzugeben, da sonst keine Luftlinie entstehen kann.
<h2>Mauseingabe</h2>
Man selektiert mit der Maus der Reihe nach die Anschl&uuml;sse, die
miteinander verbunden werden sollen. EAGLE stellt die Signale als
Luftlinien im Unrouted-Layer dar.
<p>
Gibt man signal_name mit ein, dann erh&auml;lt das Signal den
angegebenen Namen.
<h2>Texteingabe</h2>
Man kann ein Signal aber auch vollst&auml;ndig textuell definieren.
Die Eingabe
<pre>
SIG GND IC1 7 IC2 7 IC3 7;
</pre>
w&uuml;rde z.B. die Pads mit dem Namen '7' der ICs 1...3 miteinander
verbinden. Denken Sie an diese M&ouml;glichkeit im Zusammenhang mit
Script-Dateien. Sie k&ouml;nnen beispielsweise komplette Netzlisten
mit Hilfe von Script-Dateien eingeben.
<h2>Kurzschluss-Check</h2>
Versucht man, mit SIGNAL zwei Pads zu verbinden, die bereits
unterschiedlichen Signalen angeh&ouml;ren, dann wird in einem Popup-Men&uuml;
nachgefragt, ob die beiden Signale verbunden werden sollen und welchen
Namen sie erhalten sollen.
<h2>Konturdaten</h2>
Der Signalname _OUTLINES_ gibt dem Polygon besondere Eigenschaften,
die man zur Erzeugung von <a href=#136>Konturdaten</a> (z. B.
zum Fr&auml;sen von Prototypen) ben&ouml;tigt. Dieser Name sollte ansonsten nicht
verwendet werden.


<a name=100>
<h1>SMASH</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Losl&ouml;sen von Text-Variablen und Attributen von Bauteilen.
<dt>
<b>Syntax</b>
<dd>
<tt>SMASH &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Ctrl+Rechte</mb> wirkt auf die Gruppe.
<mb>Shift+Linke</mb> macht die Losl&ouml;sung der Texte wieder r&uuml;ckg&auml;ngig.
<mb>Ctrl+Shift+Rechte</mb> macht die Losl&ouml;sung der Texte f&uuml;r die Gruppe wieder r&uuml;ckg&auml;ngig.
</dl>
<b>Siehe auch</b> <a href=#72>NAME</a>,
<a href=#108>VALUE</a>,
<a href=#104>TEXT</a>,
<a href=#33>ATTRIBUTE</a>
<p>
Den SMASH-Befehl wendet man auf Bauteile an, damit man anschlie&szlig;end
die zugeh&ouml;rigen Texte, die den aktuellen Namen, Wert bzw. Attribute
repr&auml;sentieren, separat bewegen kann (MOVE). Das ist vor allem
f&uuml;r Schalt- und Best&uuml;ckungspl&auml;ne n&uuml;tzlich.
<p>
Bauteile lassen sich
auch mit ihrem Namen selektieren. Das ist vor allem dann n&uuml;tzlich,
wenn sich das Objekt ausserhalb des gerade dargestellten Bildausschnitts
befindet. Beim Selektieren eines aus mehreren Gattern bestehenden Bauteils
im Schaltplan muss der volle, aus dem Bauteil- und dem jeweiligen Gatternamen
bestehende Name angegeben werden.
<p>
Nach dem SMASH-Befehl kann man die &gt;NAME- und &gt;VALUE-Texte
behandeln wie alle anderen Texte. Allerdings l&auml;sst sich ihr
Inhalt nicht mit CHANGE TEXT &auml;ndern.
<p>
Ein "gesmashtes" Element kann in den "nicht gesmashten" Zustand zur&uuml;ckgef&uuml;hrt
werden, indem es bei gedr&uuml;ckter <tt>Shift</tt>-Taste (und nat&uuml;rlich aktiviertem
SMASH-Befehl) angeklickt wird.


<a name=101>
<h1>SMD</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Plazieren von Smds in Packages.
<dt>
<b>Syntax</b>
<dd>
<tt>SMD [x_width y_width] [-roundness] [orientation] [flags] ['name'] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.<br>
<mb>Rechte</mb> dreht das SMD.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#77>PAD</a>,
<a href=#37>CHANGE</a>,
<a href=#72>NAME</a>,
<a href=#94>ROUTE</a>,
<a href=#139>Design Rules</a>
<p>
Smd: Anschlussfl&auml;che f&uuml;r SMD-Bauelemente.
<p>
Der SMD-Befehl plaziert einen SMD-Anschluss in einem Package. Die
Eingabe der L&auml;nge und Breite vor dem Plazieren &auml;ndert die
Gr&ouml;&szlig;e des Smds. Die Parameter werden in der aktuellen Ma&szlig;einheit
angegeben. Sie d&uuml;rfen maximal 200 mm (ca. 7.7840 Zoll) betragen.
<p>
Die <tt>orientation</tt> (siehe Beschreibung bei <a href=#30>ADD</a>)
darf jeder Winkel im Bereich <tt>R0</tt>...<tt>R359.9</tt> sein. Das <tt>S</tt>-
bzw. <tt>M</tt>-Flag kann hier nicht benutzt werden.
<p>
Die eingegebene Smd-Gr&ouml;&szlig;e bleibt f&uuml;r nachfolgende Operationen
erhalten.
<h2>Roundness</h2>
Der Wert f&uuml;r <tt>roundness</tt> kann ganzzahlig -  mit negativen Vorzeichen, um es
vom width-Parameter zu unterscheiden - zwischen <tt>0</tt> und <tt>100</tt> angegeben
werden.
Der Wert <tt>0</tt> erzeugt rechteckige SMDs, w&auml;hrend der Wert <tt>100</tt>
die Ecken der SMDs vollst&auml;ndig rundet.
Der Befehl
<pre>
SMD 50 50 -100 '1' &#149;
</pre>
erzeugt zum Beispiel ein rundes SMD mit dem Namen '1' an der Position des
Mausklicks. Dieses kann man f&uuml;r ein BGA-Geh&auml;use (Ball Grid Array) verwenden.
<h2>Beliebige Pad-Formen</h2>
Falls die standardm&auml;&szlig;igen SMD Pad-Formen f&uuml;r ein bestimmtes Bauteil nicht
ausreichen, k&ouml;nnen Sie beliebige SMD Pad-Formen dadurch erzeugen, dass Sie
ein Polygon um ein SMD Pad herum zeichnen, oder Wires zeichnen, die mit einem
Ende an das SMD Pad angeschlossen sind.
<p>
Hierbei gelten folgende Bedingungen:
<ul>
<li>Ein Polygon gilt als mit einem SMD Pad im selben Layer verbunden, wenn der
    Aufh&auml;ngepunkt des Pads innerhalb der durch die Mittellinien der Polygon-Wires
    definierten Fl&auml;che liegt.
<li>Ein Wire gilt als mit einem SMD Pad im selben Layer verbunden, wenn einer seiner
    Endpunkte am Aufh&auml;ngepunkt des Pads liegt. Etwaige mit dem anderen Ende eines solchen
    Wires verbundene weitere Wires sind ebenfalls elektrisch mit dem Pad verbunden.
<li>Pro Pad wird nur <b>ein</b> Polygon ber&uuml;cksichtigt.
    Ist mehr als ein Polygon an einem Pad angeschlossen, so erzeugen diese DRC-Fehler.
<li>Mit einem Pad verbundene Polygone werden von Autorouter ignoriert, wenn er das
    betreffende Signal routet. F&uuml;r andere Signale gelten sie als Hindernisse.
<li>Mit einem Pad verbundene Wires werden wie alle anderen Signal-Wires behandelt,
    mit dem Unterschied, dass sie nicht gesplittet werden k&ouml;nnen.
<li>L&ouml;tstop- und Lotpasten-Masken werden nur f&uuml;r das Pad selber erzeugt. Werden dar&uuml;ber
    hinaus weitere L&ouml;tstop- oder Lotpasten-Masken ben&ouml;tigt, so m&uuml;ssen diese explizit
    in die entsprechenden Layer gezeichnet werden.
<li>Bei der Generierung von Thermal-Stegen wird die zus&auml;tzliche Polygon-Form mit
    ber&uuml;cksichtigt.
<li>Ist ein Polygon oder Wire mit mehr als einem Pad innerhalb eines Bauteils verbunden,
    so gilt nur eines der Pads als elektrisch mit dem Polygon bzw. Wire verbunden.
    Die anderen Pads erzeugen DRC-Fehler, es sei denn, sie sind alle innerhalb eines
    Devices <a href=#41>am selben Pin angeschlossen</a>.
<li>Falls ein C-f&ouml;rmiges Polygon, welches mit einem Pad verbunden ist, dazu f&uuml;hrt,
    dass ein Signal-Polygon im Board ein "Orphan" erh&auml;lt, welches innerhalb der
    C-Fl&auml;che liegt, so verschwindet dieses Orphan, unabh&auml;ngig davon ob das betreffende
    Signal-Polygon seinen Orphans-Parameter ein- oder ausgeschaltet hat.
</ul>
<h2>Namen</h2>
Smd-Namen werden vom Programm automatisch erzeugt und k&ouml;nnen mit
dem NAME-Befehl ge&auml;ndert werden.
Der Name kann als Parameter auch im SMD-Befehl mit angegeben werden
(muss in Hochkommas eingeschlossen sein).
<h2>Flags</h2>
Folgende <i>flags</i> k&ouml;nnen dazu benutzt werden, das Erscheinungsbild eines Smds zu
beeinflussen:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>NOSTOP</tt>  </td><td width=20><td>keine L&ouml;tstopmaske generieren</td></tr>
<tr><td><tt>NOTHERMALS</tt>       </td><td width=20><td>keine Thermals generieren</td></tr>
<tr><td><tt>NOCREAM</tt>          </td><td width=20><td>keine Lotpastenmaske generieren</td></tr>
</table>
<p>
Standardm&auml;&szlig;ig generieren Smds automatisch L&ouml;tstopmaske, Lotpastenmaske und Thermals.
In speziellen F&auml;llen kann es jedoch erw&uuml;nscht sein, dass einzelne Smds dies nicht tun.
Die obigen <tt>NO...</tt>-Flags k&ouml;nnen benutzt werden um diese Eigenschaften zu
unterdr&uuml;cken.<br>
Ein neu gestarteter SMD-Befehl setzt alle Flags auf ihre Standardwerte zur&uuml;ck.
Sobald ein Flag in der Kommandozeile angegeben wird, gilt es f&uuml;r alle nachfolgend
in diesem SMD-Befehl plazierten Smds.
<h2>Einzelne Smds</h2>
Einzelne Smds in Platinen sind als Package zu realisieren und dann
in die Platine zu holen.


<a name=102>
<h1>SPLIT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Knicke in Wires einf&uuml;gen.
<dt>
<b>Syntax</b>
<dd>
<tt>SPLIT &#149; [curve | @radius] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Rechte</mb> &auml;ndert den Knickwinkel (siehe <a href=#97>SET Wire_Bend</a>).<br>
<mb>Shift+Rechte</mb> kehrt die Richtung des Weiterschaltens des Knickwinkels um.<br>
<mb>Ctrl+Rechte</mb> schaltet zwischen korrespondierenden Knickwinkeln hin und her.<br>
<mb>Ctrl+Linke</mb> beim Absetzen eines Wire-Endpunktes definiert den Kreisbogen-Radius.
<dt>
<b>Tastatur</b>
<dd>
<tt>F8: SPLIT</tt>   aktiviert den SPLIT-Befehl.
</dl>
<b>Siehe auch</b> <a href=#69>MITER</a>,
<a href=#71>MOVE</a>,
<a href=#75>OPTIMIZE</a>,
<a href=#97>SET</a>
<p>
Den SPLIT-Befehl ben&ouml;tigt man, wenn nachtr&auml;glich in Wires oder
Polygonen noch eine Abknickung erforderlich ist. SPLIT teilt Wires am
Anklickpunkt. Das k&uuml;rzere St&uuml;ck verl&auml;uft gem&auml;&szlig; dem eingestellten
Knickwinkel (Wire_Bend), das l&auml;ngere verl&auml;uft in gerader Linie zum
n&auml;chsten Aufh&auml;ngepunkt.
<p>
Wird der <i>curve</i> oder <i>@radius</i> Parameter angegeben, so kann ein Kreisbogen als Teil des Linienzuges
gezeichnet werden (siehe die ausf&uuml;hrliche Beschreibung beim <a href=#112>WIRE</a>-Befehl).
<p>
Nach dem SPLIT-Befehl werden die betroffenen
Wire-Segmente wieder optimiert (entsprechend dem OPTIMIZE-Befehl),
sofern nicht zuvor der Befehl
<pre>
SET OPTIMIZING OFF;
</pre>
eingegeben wurde. Hat man diesen Befehl eingegeben, bleiben die
Trennstellen in den Wires erhalten. Sie bleiben auch dann erhalten,
wenn man im SPLIT-Befehl dieselbe Stelle zweimal mit der Maus anklickt.
<h2>Leitung verj&uuml;ngen</h2>
Dazu selektiert man den SPLIT-Befehl, markiert den zu verj&uuml;ngenden
Abschnitt mit zwei Mausklicks, gibt den Befehl
<pre>
CHANGE WIDTH breite
</pre>
ein und klickt mit der Maus das gew&uuml;nschte Segment an.


<a name=103>
<h1>TECHNOLOGY</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert eventuell vorhandene <i>Technologien</i> f&uuml;r ein Device.
<dt>
<b>Syntax</b>
<dd>
<tt>TECHNOLOGY name ..;</tt><br>
<tt>TECHNOLOGY -name ..;</tt><br>
<tt>TECHNOLOGY -* ..;</tt>
</dl>
<b>Siehe auch </b> <a href=#76>PACKAGE</a>,
<a href=#33>ATTRIBUTE</a>
<p>
Dieser Befehl wird im Device-Editor verwendet, um die verschiedenen <i>Technologien</i>
eines Bauteils im Device-Namen zu bestimmen.
Im Schaltplan- oder Board-Editor verh&auml;lt sich der TECHNOLOGY-Befehl genau so
wie "<a href=#37>CHANGE TECHNOLOGY</a>".
<p>
Einer der Namen, die mit
dem TECHNOLOGY-Befehl definiert wurden, ersetzt den Platzhalter <tt>'*'</tt> im
Device-Set-Namen, sobald man das Device in einem Schaltplan plaziert.
Der Begriff <i>Technology</i> stammt von der haupts&auml;chlichen Verwendung dieser Funktion
verschiedene Varianten eines Devices zu erzeugen, die alle dasselbe Schaltplan-Symbol,
dieselbe(n) Package-Variante(n) und dieselben Pin/Pad-Zuordnungen haben. Die
Devices unterscheiden sich nur im Namen, der sich beispielsweise f&uuml;r die
TTL-Bausteine im Bezug auf Ihre Technologie, wie "L", "LS", oder "HCT" unterscheiden.
<p>
Der TECHNOLOGY-Befehl kann nur angewendet werden, wenn schon vorher eine Package-Variante
&uuml;ber den <a href=#76>PACKAGE</a>-Befehl definiert wurde.
<p>
Ist kein <tt>'*'</tt>-Platzhalter im Device-Set-Namen angegeben, wird der Device-Set-Name
um die Technologie-Angabe zu einem vollst&auml;ndigen Device-Namen erg&auml;nzt.
Bitte beachten Sie, dass die Technologie vor der Package-Variante eingef&uuml;gt wird.
Ist weder <tt>'*'</tt> noch <tt>'?'</tt> angegeben, setzt sich der Device-Name aus
<i>Device-Set-Name</i><tt>+</tt><i>Technology</i><tt>+</tt><i>Package-Variante</i> zusammen.
<p>
Die Namen (name), die mit dem TECHNOLOGY-Befehl angegeben sind, werden zu einer schon
vorhandenen Liste des aktuellen Devices hinzugef&uuml;gt.
Geben Sie einen Namen mit <tt>'-'</tt> an, wird diese Bezeichnung aus der Liste entfernt.
Soll der Name mit einem <tt>'-'</tt> beginnen, muss dieser in einfachen Hochkommas
angegeben werden.
<tt>-*</tt> l&ouml;scht alle Technologien.
<p>
Es sind nur die ASCII-Zeichen 33..126 als Technologie-Bezeichnung erlaubt (Kleinbuchstaben
werden in Gro&szlig;buchstaben gewandelt).
<p>
Die besondere "leere" Technologie kann in mit zwei Hochkommas angegeben werden,
also <tt>''</tt> (ohne Namen).
<p>
Beachten Sie bitte, dass der "Technologien"-Dialog alle Technologien aller Devices
in der geladenen Bibliothek enth&auml;lt, wobei diejenigen, die vom aktuellen Device
verwendet werden, markiert sind.
<h2>Beispiel</h2>
In einem Device mit dem Namen "<tt>74*00</tt>" l&ouml;scht der Befehl
<pre>
TECHNOLOGY -* '' L LS S HCT;
</pre>
zun&auml;chst alle bisherigen Technologien und erzeugt anschlie&szlig;end die folgenden
Technologie-Varianten:
<pre>
7400
74L00
74LS00
74S00
74HCT00
</pre>


<a name=104>
<h1>TEXT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Plazieren von Text.
<dt>
<b>Syntax</b>
<dd>
<tt>TEXT beliebige_zeichen [orientation] &#149;..</tt><br>
<tt>TEXT 'beliebige_zeichen' [orientation] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.<br>
<mb>Rechte</mb> dreht den Text.<br>
<mb>Shift+Rechte</mb> kehrt die Richtung der Drehung um.
</dl>
<b>Siehe auch</b> <a href=#37>CHANGE</a>,
<a href=#71>MOVE</a>,
<a href=#68>MIRROR</a>,
<a href=#93>ROTATE</a>,
<a href=#33>ATTRIBUTE</a>
<p>
Der TEXT-Befehl plaziert einen Text in einer Zeichnung, oder in einem
Bibliothekselement. Bei der Eingabe mehrerer Texte geht man sinnvollerweise
so vor, dass man zuerst den TEXT-Befehl aktiviert, dann tippt man
den ersten Begriff ein und setzt ihn mit der linken Maustaste ab,
dann den zweiten usw.
<h2>Schreibrichtung</h2>
Mit der rechten Maustaste dreht man den Text.
<p>
Als Option kann die Schreibrichtung (orientation)
auch textuell angegeben werden. Das ist vor allem f&uuml;r Script-Dateien
sinnvoll. Die entsprechenden Schl&uuml;sselw&ouml;rter sind im <a href=#30>ADD</a>-Befehl
aufgef&uuml;hrt (R0, R90 usw.).
<p>
Text wird immer so dargestellt, dass er von vorne oder von rechts
zu lesen ist - auch wenn er rotiert wird. Nach zweimaligem Rotieren
erscheint er deshalb wieder gleich, aber der Aufh&auml;ngepunkt liegt
nicht mehr links unten, sondern rechts oben. Denken Sie daran, wenn
sich ein Text scheinbar nicht mehr selektieren l&auml;sst.
<p>
Wenn Sie einen Text "auf dem Kopf stehend" darstellen wollen, so k&ouml;nnen
Sie das "Spin"-Flag f&uuml;r diesen Text setzen.
<h2>Text auf L&ouml;tseite</h2>
Texte in den Layern Bottom und bPlace werden automatisch gespiegelt.
<h2>Mehrzeilige Texte</h2>
Texte d&uuml;rfen Zeilenumbr&uuml;che enthalten. Im Textdialog k&ouml;nnen sie mit Shift-Enter
eingegeben werden, in der Kommandozeile mu&szlig; "\n" verwendet werden.
<h2>Sonderzeichen</h2>
Sollen in einem Text mehrere aufeinanderfolgende Leerzeichen oder
ein Strichpunkt enthalten sein, dann setzt man den ganzen String in
Hochkommas. Sollen Hochkommas gedruckt werden, dann ist jedes einzelne
in Hochkommas einzuschlie&szlig;en.<br>
Soll der Text Backslashes ('\') enthalten, dann mu&szlig; jeder mit einem weiteren Backslash
maskiert werden (z.B. <tt>TEXT 'abc\\\\def'</tt> f&uuml;hrt zu <tt>abc\\def</tt>).
<h2>Schl&uuml;sselw&ouml;rter</h2>
Ist der TEXT-Befehl aktiv und enth&auml;lt der einzugebende Text W&ouml;rter,
die EAGLE f&uuml;r Befehle oder Orientation-Schl&uuml;sselw&ouml;rter
h&auml;lt (z. B. und f&uuml;r UNDO), dann sind diese
W&ouml;rter oder der gesamte Text in Hochkommas einzuschlie&szlig;en.
<h2>Texth&ouml;he</h2>
Die Zeichengr&ouml;&szlig;e und die Strichst&auml;rke &auml;ndert man mit
den Befehlen:
<pre>
CHANGE SIZE text_size &#149;..
CHANGE RATIO ratio &#149;..
CHANGE LINEDISTANCE value &#149;..
</pre>
Maximale Texth&ouml;he: ca. 2 Zoll.<br>
Maximale Strichst&auml;rke: 200 mm (ca. 7.7840 Zoll)<br>
Parameter "ratio": 0...31 (% der Texth&ouml;he)<br>
Zeilenabstand: 0...250 (% der Texth&ouml;he).
<h2>Schriftart</h2>
Texte k&ouml;nnen in drei Schriftarten verwendet werden:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>Vector</tt></td>           <td width=20><td>der programm-interne Vektor-Font</td></tr>
<tr><td><tt>Proportional</tt></td>     <td width=20><td>ein Proportional-Pixel-Font (&uuml;blicherweise 'Helvetica')</td></tr>
<tr><td><tt>Fixed</tt></td>            <td width=20><td>ein Monospaced-Pixel-Font (&uuml;blicherweise 'Courier')</td></tr>
</table>
<p>
Die Schriftart wird mit CHANGE ver&auml;ndert:
<pre>
CHANGE FONT VECTOR|PROPORTIONAL|FIXED &#149;..
</pre>
Das Programm versucht die Nicht-<tt>Vector</tt>-Schriftarten so gut wie m&ouml;glich auszugeben.
Da diese jedoch vom Grafik-Interface Ihres Systems gezeichnet werden, k&ouml;nnen bei
<tt>Proportional</tt>- und <tt>Fixed</tt>-Schriftart Abweichungen in der Gr&ouml;&szlig;e
bzw. L&auml;nge entstehen.
<p>
Setzen Sie die Option "Immer Vektor-Schrift" im <a href=#17>User-Interface-Dialog</a>,
werden alle Texte mit dem programm-internen Vektor-Font dargestellt und ausgegeben,
unabh&auml;ngig von den Einstellungen der einzelnen Texte und f&uuml;r jede Zeichnung.
Diese Einstellung ist dann sinnvoll, wenn vom System die anderen Schriftarten nicht
korrekt angezeigt werden.<br>
Mit <tt><a href=#97>SET</a> Interface.VectorFont 0|1</tt>
k&ouml;nnen Sie diese Einstellung &auml;ndern.
<p>
Beim Anlegen eines neuen Boards oder Schaltplans wird die aktuelle Einstellung in der
Option "In diese Zeichnung einpr&auml;gen" der Zeichnungsdatei gespeichert.
So wird sicher gestellt (auch bei der Weitergabe an Dritte, die evtl. mit anderen
Einstellungen arbeiten), dass die Datei mit Ihren Einstellungen ausgegeben wird.<br>
Mit <tt><a href=#97>SET</a> VECTOR_FONT OFF|ON</tt> k&ouml;nnen Sie diese
Einstellung f&uuml;r ein bestehendes Layout oder einen Schaltplan &auml;ndern.
<p>
Wenn Sie Daten mit dem CAM-Prozessor erzeugen, werden Texte immer mit
<tt>Vector</tt>-Font ausgegeben. Andere Fonts werden nicht unterst&uuml;tzt.
<p>
Soll ein Text in einem Nicht-<tt>Vector</tt>-Font von einem Signal-Polygon subtrahiert
werden, wird nur das umschlie&szlig;ende Rechteck ausgespart. Aufgrund der oben angef&uuml;hrten
Probleme bzgl. Einhalten von Gr&ouml;&szlig;e und L&auml;nge der Texte, kann es sein, dass der Text
&uuml;ber das umschlie&szlig;ende Rechteck hinausgeht. Sollten Sie also Texte von Polygonen
subtrahieren wollen, ist es h&ouml;chst empfehlenswert nur den <tt>Vector</tt>-Font zu
verwenden.
<p>
Der Parameter <i>Ratio</i> hat f&uuml;r Nicht-<tt>Vector</tt>-Fonts keine Bedeutung.
<h2>Text-Ausrichtung</h2>
Die Text-Ausrichtung gibt an, an welcher Stelle des Textes sich der Aufh&auml;ngepunkt
befinden soll.
Es gibt neun verschiedene m&ouml;gliche Ausrichtungen, die aus Kombinationen der
Schl&uuml;sselworte <tt>left</tt>, <tt>bottom</tt>, <tt>center</tt>, <tt>right</tt>
und <tt>top</tt> bestehen. Diese Schl&uuml;sselworte k&ouml;nnen in beliebiger Reihenfolge
angegeben werden, wobei aber nur das jeweils letzte von left/right bzw. top/bottom
f&uuml;r die tats&auml;chliche Ausrichtung ma&szlig;gebend ist. Das Schl&uuml;sselwort center wirkt
nur f&uuml;r jene Richtungen, f&uuml;r die kein anderes Schl&uuml;sselwort angegeben wurde.
Der Standardwert ist left und bottom.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CHANGE ALIGN TOP CENTER; TEXT 'ABC' &#149;</tt>   </td><td width=20><td>zeichnet den Text ABC mit dem Aufh&auml;ngepunkt oben in der Mitte</td></tr>
</table>
<h2>Zeichensatz</h2>
Eine korrekte Darstellung wird nur f&uuml;r die Zeichen im ASCII-Code unter
128 garantiert. Alle anderen Zeichen dar&uuml;ber k&ouml;nnen systemabh&auml;ngig zu
unterschiedlichen Darstellungen in den unterschiedlichen Schriftarten f&uuml;hren.
<h2>Spezielle Platzhalter-Texte</h2>
Spezielle Texte in einer Symbol- oder Package-Zeichnung, die mit <tt>'&gt;'</tt>
gekennzeichnet sind, werden durch konkreten Werten im Schaltplan bzw. Board ersetzt:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>&gt;NAME</tt>                </td><td width=20><td>Bauteilname (ggf.+Gate-Name)      1)</td></tr>
<tr><td><tt>&gt;VALUE</tt>               </td><td width=20><td>Bauteilwert/-typ                  1)</td></tr>
<tr><td><tt>&gt;PART</tt>                </td><td width=20><td>Bauteilname                       2)</td></tr>
<tr><td><tt>&gt;GATE</tt>                </td><td width=20><td>Gate-Name                         2)</td></tr>
<tr><td><tt>&gt;XREF</tt>                </td><td width=20><td>Bauteil-Querverweis               2)</td></tr>
<tr><td><tt>&gt;CONTACT_XREF</tt>        </td><td width=20><td>Kontaktspiegel                    2)</td></tr>
<tr><td><tt>&gt;ASSEMBLY_VARIANT</tt>    </td><td width=20><td>Name der aktuellen Best&uuml;ckungsvariante</td></tr>
<tr><td><tt>&gt;DRAWING_NAME</tt>        </td><td width=20><td>Zeichnungsname</td></tr>
<tr><td><tt>&gt;LAST_DATE_TIME</tt>      </td><td width=20><td>Datum/Zeit der letzten &Auml;nderung</td></tr>
<tr><td><tt>&gt;PLOT_DATE_TIME</tt>      </td><td width=20><td>Datum/Zeit der Plot-Erstellung</td></tr>
<tr><td><tt>&gt;SHEETNR</tt>             </td><td width=20><td>Seitennummer eines Schaltplans           3)</td></tr>
<tr><td><tt>&gt;SHEETS</tt>              </td><td width=20><td>Gesamtzahl der Seiten eines Schaltplans  3)</td></tr>
<tr><td><tt>&gt;SHEET</tt>               </td><td width=20><td>entspricht "&gt;SHEETNR/&gt;SHEETS"      3)</td></tr>
</table>
<p>
1) Nur im Package und Symbol<br>
2) Nur im Symbol<br>
3) Nur im Symbol oder Schaltplan
<p>
Das Format, in welchem ein Bauteil-Querverweis angezeigt wird, kann &uuml;ber die
"Format f&uuml;r Bauteil-Querverweise" Zeichenfolge im Dialog "Optionen/Einstellungen/Verschiedenes"
oder &uuml;ber den <a href=#97>SET</a> Befehl festgelegt werden.
Folgende Platzhalter sind definiert und k&ouml;nnen in beliebiger Reihenfolge verwendet werden:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%S</tt></td>  <td width=20><td>die Seitennummer</td></tr>
<tr><td><tt>%C</tt></td>  <td width=20><td>die Spalte auf der Seite</td></tr>
<tr><td><tt>%R</tt></td>  <td width=20><td>die Zeile auf der Seite</td></tr>
</table>
<p>
Das Standard-Format ist <tt>"/%S.%C%R"</tt>. Neben den definierten Platzhaltern
k&ouml;nnen Sie auch beliebige andere ASCII-Zeichen verwenden.
<h2>Attribute</h2>
Soll in einer Symbol- oder Package-Zeichnung ein <a href=#33>Attribut</a>
des konkreten Bauteils dargestellt werden, so kann hierf&uuml;r ein Text mit dem Namen
des Attributs und vorangestelltem <tt>'&gt;'</tt> benutzt werden.
Standardm&auml;&szlig;ig wird nur der Wert des gegebenen Attributs dargestellt. Folgt auf den
Namen des Attributs eines der Zeichen <tt>'='</tt>, <tt>'~'</tt> oder <tt>'!'</tt>,
so geschieht die Darstellung wie folgt:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td with=100><tt>&gt;ABC </tt></td><td width=20><td><tt>123</tt></td></tr>
<tr><td><tt>&gt;ABC=</tt></td><td width=20><td><tt>ABC = 123</tt></td></tr>
<tr><td><tt>&gt;ABC~</tt></td><td width=20><td><tt>ABC</tt></td></tr>
<tr><td><tt>&gt;ABC!</tt></td><td width=20><td><tt><i>nothing</i></tt></td></tr>
</table>
Beachten Sie bitte, dass es f&uuml;r jeden Attribut-Namen nur einen solchen Text pro
Symbol bzw. Package geben sollte.
Werden mehrere solcher Texte in einem Symbol bzw. Package verwendet, die alle den
gleichen Attribut-Namen referenzieren, so wird nur einer davon angezeigt, wenn
das Bauteil, welches dieses Symbol bzw. Package verwendet, gesmasht wird.
<h2>&Uuml;berstrichener Text</h2>
Text kann <i>&uuml;berstrichen</i> werden, was zum Beispiel sinnvoll ist f&uuml;r
die Namen von negierten Signalen ("active low", siehe auch
<a href=#73>NET</a>, <a href=#36>BUS</a> und <a href=#79>PIN</a>).
Hierf&uuml;r muss dem Text ein Ausrufezeichen (<tt>'!'</tt>) vorangestellt werden, wie in
<pre>
  !RESET
</pre>
was als
<pre>
  _____
  RESET
</pre>
dargestellt w&uuml;rde. Diese M&ouml;glichkeit ist nicht auf Signalnamen beschr&auml;nkt,
sondern kann in allen Texten benutzt werden. Man kann auch nur einen Teil
eines Textes &uuml;berstreichen, wie in
<pre>
  !RST!/NMI
  R/!W
</pre>
was als
<pre>
  ___
  RST/NMI
    _
  R/W
</pre>
dargestellt w&uuml;rde. Beachten Sie das zweite Ausrufezeichen, welches das
Ende des &Uuml;berstrichs markiert. Ein Text kann beliebig viele &Uuml;berstriche
enthalten. Soll ein Text ein Ausrufezeichen enthalten, welches keinen
&Uuml;berstrich erzeugt, so muss diesem ein Backslash vorangestellt werden.
Um die Notwendigkeit von Backslashes auf ein Minimum zu reduzieren startet
ein Ausrufezeichen einen &Uuml;berstrich dann nicht, wenn es das letzte Zeichen
eines Textes ist, oder wenn es unmittelbar von einem Leerzeichen,
einem Apostroph, einem Anf&uuml;hrungszeichen oder
einer schlie&szlig;enden runden, eckigen oder geschweiften Klammer gefolgt wird.
Ein Ausrufezeichen bzw. Komma ohne vorangestellten Backslash, das nach
einem Ausrufezeichen steht, welches einen &Uuml;berstrich begonnen hat, beendet
den &Uuml;berstrich (dass das Komma einen &Uuml;berstrich beendet ist notwendig f&uuml;r
Busse).


<a name=105>
<h1>UNDO</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Vorhergehende Befehle zur&uuml;cknehmen.
<dt>
<b>Syntax</b>
<dd>
<tt>UNDO</tt><br>
<tt>UNDO LIST</tt>
<dt>
<b>Tastatur</b>
<dd>
<tt>F9:     UNDO</tt>   UNDO-Befehl ausf&uuml;hren.
<tt>Alt+BS: UNDO</tt>
</dl>
<b>Siehe auch</b> <a href=#88>REDO</a>,
<a href=#97>SET</a>,
<a href=#372>Forward&amp;Back-Annotation</a>
<p>
Mit dem Befehl UNDO kann man Befehle r&uuml;ckg&auml;ngig machen. Das
ist insbesondere dann n&uuml;tzlich, wenn man z. B. versehentlich etwas
gel&ouml;scht hat. Die mehrmalige Eingabe von UNDO macht entsprechend
viele Befehle r&uuml;ckg&auml;ngig. Das geht bis zum Zustand nach dem
letzen EDIT-, OPEN- oder REMOVE-Befehl. Diese Befehle
l&ouml;schen die Vorgeschichte.
<p>
Die UNDO-Funktion ben&ouml;tigt Platz im Arbeitsspeicher und kann die Eingabe
von Script-Dateien erheblich verlangsamen.
Sie l&auml;sst sich bei Bedarf mit dem Befehl
<pre>
SET UNDO_LOG OFF;
</pre>
abschalten.
<p>
UNDO/REDO ist vollkommen in den Mechanismus der Forward&amp;Back-Annotation
integriert.
<h2>UNDO-Puffer Dialog</h2>
Die Option LIST im UNDO-Befehl &ouml;ffnet einen Dialog, der den gesamten
Inhalt des UNDO-Puffers darstellt. Sie k&ouml;nnen sich in der Liste der
Undo-/Redo-Schritte bewegen indem Sie den Listen-Trenner mit der Maus
verschieben, oder direkt auf einen Schritt klicken, zu dem Sie gehen wollen.
Liegen mehrere Schritte zwischen der aktuellen Position des Listen-Trenners
und dem angeklickten Listeneintrag, so werden alle dazwischenliegenden
Schritte in der entsprechenden Reihenfolge ausgef&uuml;hrt. In der Liste nach
oben zu gehen bewirkt UNDO, nach unten REDO.<br>
Das Icon bei jedem Listeneintrag gibt an, in welcher Zeichnung der entsprechende
Befehl ausgef&uuml;hrt worden ist.
<p>
Wenn Sie diesen Dialog mit "OK" best&auml;tigen, so verbleibt die Zeichnung in dem
aus der Liste gew&auml;hlten Zustand. Brechen Sie den Dialog ab, so wird der Zustand
wiederhergestellt, den die Zeichnung vor dem &Ouml;ffnen dieses Dialogs hatte.
<p>
<b>VORSICHT:</b> dies ist ein sehr m&auml;chtiges Werkzeug! Wenn Sie in der UNDO-Liste
sehr weit zur&uuml;ckgehen (was mit einem einfachen Mausklick m&ouml;glich ist) und
dann irgend einen neuen Befehl eingeben, so wird der UNDO-Puffer an dieser
Stelle abgeschnitten, und es f&uuml;hrt kein Weg zur&uuml;ck! Benutzen Sie es also
mit entsprechender Vorsicht!


<a name=106>
<h1>UPDATE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Aktualisiert Bibliotheks-Elemente.
<dt>
<b>Syntax</b>
<dd>
<tt>UPDATE</tt><br>
<tt>UPDATE;</tt><br>
<tt>UPDATE library_name..;</tt><br>
<tt>UPDATE package_name@library_name..;</tt><br>
<tt>UPDATE +@ | -@ [library_name..];</tt><br>
<tt>UPDATE old_library_name = new_library_name;</tt>
</dl>
<b>Siehe auch</b> <a href=#30>ADD</a>,
<a href=#91>REPLACE</a>
<p>
Der UPDATE-Befehl vergleicht Bauteile in einem Layout oder Schaltplan
mit den zugeh&ouml;rigen Bibliothekselementen und aktualisiert diese, sofern
Unterschiede festgestellt werden. Wird UPDATE im Bibliotheks-Editor ausgef&uuml;hrt,
so werden die in der geladenen Bibliothek befindlichen Packages aus den angegebenen
Bibliotheken aktualisiert.
<p>
Wird der UPDATE-Befehl ohne Parameter aufgerufen, &ouml;ffnet sich ein Datei-Dialog,
aus dem man die Bibliothek w&auml;hlt, deren Bauteile mit den Definitionen in
der Zeichnung verglichen werden soll.
<p>
Werden eine oder mehrere Bibliotheken angegeben, &uuml;berp&uuml;ft das Programm alle
Bauteile aus diesen Bibliotheken. Der Bibliotheksname kann entweder als einfacher
Name (wie "ttl" oder "ttl.lbr") oder mit voller Pfadangabe
(wie "/home/mydir/myproject/ttl.lbr" oder "../lbr/ttl") angegeben werden.
<p>
Falls ein <tt>library_name</tt> Leerzeichen enth&auml;lt, so muss er in einfache Hochkommas
eingeschlossen werden.
<h2>Update im Layout oder Schaltplan</h2>
Wird der Befehl ohne Parameter mit einem <tt>';'</tt> abgeschlossen, werden alle
Bauteile &uuml;berpr&uuml;ft.
<p>
Falls der erste Parameter <tt>'+@'</tt> ist, werden die Namen der angegebenen Bibliotheken
(oder aller Bibliotheken, falls keine angegeben wurden) um das <tt>'@'</tt>-Zeichen gefolgt
von einer Zahl erweitert. Dies kann dazu benutzt werden um sicherzustellen, dass die in einer
Zeichnung enthaltenen Bibliotheken nicht ver&auml;ndert werden wenn ein Bauteil aus einer neueren
Bibliothek gleichen Namens in die Zeichnung eingef&uuml;gt wird. Bibliotheksnamen die bereits
mit dem <tt>'@'</tt>-Zeichen gefolgt von einer Zahl enden werden nicht ver&auml;ndert.
<p>
Falls der erste Parameter <tt>'-@'</tt> ist, wird das <tt>'@'</tt>-Zeichen (gefolgt von einer Zahl)
vom Ende der angegebenen Bibliotheksnamen (oder aller Bibliotheksnamen, falls keine angegeben
wurden) entfernt. Dies funktioniert nat&uuml;rlich nur dann, wenn sich noch keine Bibliothek mit diesem
neuen Namen in der Zeichnung befindet.
<p>
Bitte beachten Sie, dass "UPDATE +@;" gefolgt von "UPDATE -@;" (und umgekehrt) nicht unbedingt
die urspr&uuml;ngliche Folge von Bibliotheksnamen ergeben muss, da die Reihenfolge, in der die Namen
bearbeitet werden, von der Reihenfolge der Bibliotheken in der Zeichnungsdatei abh&auml;ngt.
<p>
Die Bibliotheksdefinitionen, die in einem Schaltplan oder Board gespeichert sind,
werden nur anhand des Bibliotheksnamens (z. B. "ttl") identifiziert. Bei der
Entscheidung ob das Bauteil &uuml;berpr&uuml;ft werden soll oder nicht, wird nur dieser
Name ber&uuml;cksichtigt.
Die Bibliotheken werden in den unter "Libraries" im
<a href=#15>Directories-Dialog</a> angegebenen Verzeichnissen,
von links nach rechts, gesucht.
Die erste Bibliothek mit dem angegebenen Namen, die in den Verzeichnissen gefunden wird,
wird verwendet. Bitte beachten Sie, dass bei den Bibliotheksnamen nicht zwischen
Gro&szlig;- und Kleinschreibung unterschieden wird. Es ist nicht relevant ob die
gesuchte Bibliothek zur Zeit "in use" ist oder nicht. Kann eine Bibliothek nicht
gefunden werden, findet auch kein Update statt. In diesem Fall wird keine
Fehlermeldung ausgegeben.
<p>
Wird der UPDATE-Befehl in einem Schaltplan oder Board gestartet, und sind diese
&uuml;ber die <a href=#372>Forward&amp;Back Annotation</a> verbunden,
aktualisiert EAGLE die Bauteile in beiden Dateien.
<p>
In manchen F&auml;llen wird es notwendig sein anzugeben, ob Gates, Pins oder Pads
aufgrund ihres Namens oder ihrer Koordinaten zugeordnet werden sollen. Das ist dann
der Fall, wenn die zugeh&ouml;rigen Bibliotheksobjekte verschoben oder umbenannt
wurden. Wenn zuviele &Auml;nderungen gemacht wurden (z. B. wurde ein Pin verschoben
und umbenannt), ist ein automatisches Aktualisieren nicht m&ouml;glich. In diesem
Fall sollte man die Bibliotheks&auml;nderung entweder in mehreren Schritten machen
(erst Umbenennen, dann Verschieben) oder das ganze Element umbenennen, so dass es
nicht getauscht wird.
<p>
In der Notation <tt>old_library_name = new_library_name</tt> (beachten Sie, dass
vor und nach dem <tt>'='</tt> Zeichen jeweils mindestens ein Leerzeichen stehen muss)
sucht der UPDATE-Befehl die Bibliothek <i>old_library_name</i> im aktuellen Board
oder Schaltplan und aktualisiert diese mit dem Inhalt von <i>new_library_name</i>.
Hierbei ist zu beachten, dass <i>old_library_name</i> ein reiner Bibliotheksname
sein muss, ohne Pfad, w&auml;hrend <i>new_library_name</i> ein
vollst&auml;ndiger Pfadname sein kann. Wurde der Update erfolgreich ausgef&uuml;hrt, so
wird auch die Bibliothek im aktuellen Board oder Schaltplan entsprechend umbenannt - aus diesem Grund ist diese
ganze Operation nat&uuml;rlich nur dann m&ouml;glich, wenn <i>new_library_name</i> bisher
im aktuellen Board oder Schaltplan noch nicht verwendet wurde.
<p>
<b>Achtung: Nach jedem Library Update in einem Layout oder Schaltplan sollten Sie unbedingt einen
<a href=#48>Design Rule Check</a> (DRC) und einen
<a href=#50>Electrical Rule Check</a> (ERC) durchf&uuml;hren!</b>
<h2>Update in einer Bibliothek</h2>
Beim Update in einer Bibliothek werden alle in dieser befindlichen Packages durch
die entsprechenden Versionen aus den angegebenen Bibliotheken ersetzt.
<p>
Durch die Angabe des Package-Namens (package_name@library_name) kann daf&uuml;r gesorgt
werden, dass nur ein ganz bestimmtes Package ersetzt wird.


<a name=107>
<h1>USE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Bibliothek zur Benutzung markieren.
<dt>
<b>Syntax</b>
<dd>
<tt>USE</tt><br>
<tt>USE -*;</tt><br>
<tt>USE library_name..;</tt>
</dl>
<b>Siehe auch</b> <a href=#30>ADD</a>,
<a href=#91>REPLACE</a>
<p>
Der USE-Befehl markiert eine Bibliothek so, dass sie f&uuml;r die Befehle
<a href=#30>ADD</a> oder <a href=#91>REPLACE</a>
verf&uuml;gbar ist.
<p>
Rufen Sie den USE-Befehl ohne Parameter auf, &ouml;ffnet sich ein Datei-Dialog
aus dem man eine Bibliotheksdatei ausw&auml;hlen kann.
Falls f&uuml;r Bibliotheken im
"Optionen/Verzeichnisse"-Dialog
ein Pfad definiert wurde, erscheinen im Datei-Dialog
die Bibliotheken aus diesem Verzeichnis.
<p>
Der spezielle Parameter <tt>-*</tt> bewirkt, dass alle bisher markierten
Bibliotheken aufgegeben werden.
<p>
<tt>library_name</tt> kann der volle Name einer Bibliothek oder ein
teilqualifizierter Name sein.
Falls <tt>library_name</tt> der Name eines Verzeichnisses ist, werden alle
Bibliotheken aus diesem Verzeichnis markiert.
<p>
Der Suffix <tt>.lbr</tt> braucht nicht angegeben zu werden.
<p>
EAGLE &uuml;bernimmt die komplette Bibliotheksinformation in die Zeichnung,
deshalb ist die Bibliothek zum Bearbeiten fertiger Platinen nicht
mehr erforderlich.
<p>
&Auml;nderungen an einer Bibliothek wirken sich nicht auf Elemente
in den schon bestehenden Zeichnungen aus.
Siehe <a href=#106>UPDATE</a>-Befehl, um Bauteile durch
aktualisierte Bibliothekselemente zu ersetzen.
<h2>Ausw&auml;hlen der Bibliotheken &uuml;ber das Control Panel</h2>
Wenn eine Bibliothek, die Sie benutzen wollen im Bibliotheks-Editor
ver&auml;ndert und noch nicht gespeichert wurde, werden Sie gefragt, ob die Datei
jetzt gespeichert werden soll oder nicht. Beantworten Sie diese Frage mit
<i>Yes</i>, wird die Datei gespeichert und Sie benutzen die modifizierte Datei.
Antworten Sie mit <i>No</i>, wird die Datei nicht gespeichert und Sie benutzen
die Bibliothek unver&auml;ndert, so wie sie auf der Festplatte gespeichert ist.
Die Schaltfl&auml;che <i>Cancel</i> bricht den Befehl ab, so dass weder die Datei
gespeichert noch diese Bibliothek "in use" ist.
Bibliotheken k&ouml;nnen im <a href=#13>Control Panel</a> als "in use"
markiert werden, indem Sie auf den Marker klicken, der seine Farbe &auml;ndert, um anzuzeigen,
ob die Bibliothek "in use" ist, oder durch die Auswahl des Punkts "Use" im Kontext-Men&uuml;
des Bibliothekseintrags in der Baumansicht. Im Kontext-Men&uuml; gibt es die M&ouml;glichkeit
alle <i>all</i> oder keine <i>none</i> der Bibliotheken zu w&auml;hlen.
<h2>Bibliotheken "in use" und Projekte</h2>
Die Bibliotheken, die "in use" sind, werden in der Projekt-Datei (eagle.epf) gespeichert,
sofern ein Projekt geladen ist.
<h2>Beispiele</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>USE</tt>              </td><td width=20><td>&ouml;ffnet den Datei-Dialog zur Auswahl einer Bibliothek</td></tr>
<tr><td><tt>USE -*;</tt>          </td><td width=20><td>gibt alle vorher mit USE markierten Bibliotheken auf</td></tr>
<tr><td><tt>USE demo trans*;</tt> </td><td width=20><td>markiert die Bibliothek demo.lbr und alle Bibliotheken mit Namen trans*.lbr</td></tr>
<tr><td><tt>USE -* /eagle/lbr;</tt>  </td><td width=20><td>gibt zun&auml;chst alle bereits makierten Bibliotheken auf und markiert dann alle Bibliotheken aus dem Verzeichnis /eagle/lbr</td></tr>
</table>


<a name=108>
<h1>VALUE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Elementwert eintragen und &auml;ndern.
<dt>
<b>Syntax</b>
<dd>
<tt>VALUE &#149;..</tt><br>
<tt>VALUE wert &#149;..</tt><br>
<tt>VALUE name wert ..</tt><br>
<tt>VALUE ON;</tt><br>
<tt>VALUE OFF;</tt>
</dl>
<b>Siehe auch</b> <a href=#72>NAME</a>,
<a href=#100>SMASH</a>,
<a href=#109>VARIANT</a>
<h2>In Platine und Schaltplan</h2>
Elemente kann man mit einem Wert versehen, etwa 10k bei einem Widerstand.
Bei ICs tr&auml;gt man anstelle des Wertes sinnvollerweise den Typ
ein (z. B. 7400). Den Wert bzw. Typ tr&auml;gt man mit dem VALUE-Befehl
ein. Der Befehl selektiert das n&auml;chstgelegene Element und &ouml;ffnet
ein Popup-Men&uuml;, in dem man einen neuen Wert festlegen oder den
bisherigen ver&auml;ndern kann.
<p>
Gibt man wert an, bevor man das Element mit der Maus selektiert,
dann erhalten alle nachfolgend selektierten Elemente diesen Wert.
Das ist sehr praktisch, wenn man z. B. eine ganze Reihe von ICs auf
denselben Wert setzen will.
<p>
Werden name und wert angegeben, so erh&auml;lt das Element
name den angegebenen Wert.
<p>
Der VALUE-Befehl kann nur in der Standard-Best&uuml;ckungsvariante verwendet werden.
Wenn Sie den Wert f&uuml;r eine andere Best&uuml;ckungsvariante &auml;ndern wollen,
verwenden Sie den <a href=#109>VARIANT-Befehl</a> .
<h2>Beispiel</h2>
<pre>
VALUE R1 10k R2 100k
</pre>
Hier wurde mehreren Elementen in einem Befehl je ein Wert zugewiesen.
Diese M&ouml;glichkeit l&auml;sst sich auch in Script-Dateien nach
folgendem Muster ausnutzen:
<pre>
VALUE R1   10k \
      R2  100k \
      R3  5.6k \
      C1  10uF \
      C2  22nF \
      ...
</pre>
Der Backslash ('\') verhindert, dass in der n&auml;chsten Zeile ein Parameter
mit einem Schl&uuml;sselwort verwechselt wird.
<h2>Im Device: Wert oder Typ</h2>
Wendet man den VALUE-Befehl im Device-Editier-Modus an, dann sind
die Parameter On und Off zul&auml;ssig.
<p>
On: Anstelle des Platzhalters VALUE (im Symbol definiert) kann im
Schaltplan der aktuelle Wert eingegeben werden.
<p>
Off: Anstelle des Platzhalters VALUE erscheint im Schaltplan der Device-Name
(z.B. 74LS00N). Er l&auml;sst sich im Schaltplan nur nach R&uuml;ckfrage mit dem
VALUE-Befehl ver&auml;ndern.


<a name=109>
<h1>VARIANT</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Verwaltung von Best&uuml;ckungsvarianten.
<dt>
<b>Syntax</b>
<dd>
<tt>VARIANT</tt><br>
<tt>VARIANT name part_name [NO]POPULATE [ 'value' [ technology ] ];</tt><br>
<tt>VARIANT [ + | - ] name;</tt>
</dl>
<b>Siehe auch</b> <a href=#108>VALUE</a>,
<a href=#103>TECHNOLOGY</a>
<p>
Standardm&auml;&szlig;ig werden alle Bauteile des Schaltplans auf dem Board best&uuml;ckt (sofern
sie ein Package haben). Manchmal kann es aber notwendig sein, dass in bestimmten
Varianten eines Designs einige Bauteile nicht best&uuml;ckt werden, oder dass sie vom
Standard abweichende Werte oder Technologien haben.
Der VARIANT-Befehl erm&ouml;glicht es Ihnen festzulegen, welche Bauteile in einer
bestimmten Ausf&uuml;hrung best&uuml;ckt werden sollen, und welche Werte und Technologien
sie jeweils haben sollen.
<p>
<i>name</i> ist der Name der Variante. Gro&szlig;-/Kleinschreibung ist egal, und er muss
in einfache Hochkommas eingeschlossen werden, wenn er Leerzeichen
enth&auml;lt oder '+' oder '-'.
<p>
Wird <i>part_name</i>, gefolgt von dem Schl&uuml;sselwort <tt>POPULATE</tt> oder <tt>NOPOPULATE</tt>
angegeben, so wird eine Variante mit dem Namen <i>name</i> f&uuml;r dieses Bauteil angelegt,
in der es als "best&uuml;ckt" bzw. "nicht best&uuml;ckt" markiert wird.
<p>
In der aktuellen Best&uuml;ckungsvariante nicht best&uuml;ckte Bauteile werden im Schaltplan
durch ein X gekennzeichnet, das &uuml;ber ihre gesamte Fl&auml;che gezeichnet wird.
Im Board wird in einem solchen Fall alles, was die tats&auml;chliche Best&uuml;ckung des
Bauteils betrifft (also Best&uuml;ckungsaufdruck, Name, Wert etc.) nicht dargestellt.
<p>
Mit den optionalen <i>value</i> und <i>technology</i> (nur im Schaltplan) kann die
Variante weiter verfeinert werden.
Ein Wert kann nur angegeben werden, wenn das Bauteil einen vom Benutzer definierbaren
Wert hat.
Soll nur die Technologie angegeben werden, ohne einen speziellen Wert zu verwenden,
so kann ein leerer Wert (<tt>''</tt>) angegeben werden.
<p>
Eine neue Variante kann angelegt werden, indem man <tt>name</tt> ein <tt>'+'</tt>
voranstellt. Falls eine Variante dieses Namens bereits existiert, passiert nichts.
<p>
Wird dem Varianten-Namen ein <tt>'-'</tt> vorangestellt, so wird die angegebene
Variante gel&ouml;scht. Wird als <tt>name</tt> ein <tt>'*'</tt> angegeben, so werden
alle Varianten gel&ouml;scht.
Falls dieser Befehl au&szlig;erhalb eines Scripts verwendet wird, so wird
nachgefagt, ob diese Aktion wirklich ausgef&uuml;hrt werden soll.
<p>
Mit der blo&szlig;en Angabe eines Varianten-Namens wird das gesamte Projekt auf diese
Variante umgeschaltet.
Dies bedeutet, dass alle "populate"-Flags, Werte und Technologien so erscheinen,
wie es in dieser Variante f&uuml;r die einzelnen Bauteile angegeben wurde.
Die Angabe eines leeren Strings (<tt>''</tt>) schaltet auf die Standard-Variante,
was das Gleiche ist als g&auml;be es keinerlei Varianten.
Beachten Sie bitte, dass nach dem Laden einer Zeichnung diese immer in ihrem
Standard-Zustand ist, ohne eine bestimmte Variante aktiviert zu haben.
<p>
Ohne jegliche Parameter &ouml;ffnet sich ein Dialog in dem Sie alle Best&uuml;ckungsvarianten
verwalten k&ouml;nnen.
<p>
Der Name der aktuellen Best&uuml;ckungsvariante kann mit der
<a href=#104>Text-Variablen</a> <tt>&gt;ASSEMBLY_VARIANT</tt> dargestellt werden.
<p>
Die Befehle ADD, CHANGE PACKAGE | TECHNOLOGY, REPLACE, UPDATE und VALUE k&ouml;nnen nur
verwendet werden, wenn keine Best&uuml;ckungsvariante aktiv ist.
<p>
Der COPY-Befehl kopiert keine Best&uuml;ckungsvarianten.
<p>
Im Board wird der VARIANT-Befehl nicht unterst&uuml;tzt. Alles wird vom Schaltplan aus gesteuert,
Konsistenz vorausgesetzt (Die Varianten-Kombobox im Board-Editor dient nur zur Information).
Ist die F/B-Annotation nicht aktiv, ist es jedoch m&ouml;glich, das Populate-Flag mit dem Befehl
<a href=#37>CHANGE</a> zu setzen.
<h2>Modul-Best&uuml;ckungsvarianten</h2>
Best&uuml;ckungsvarianten k&ouml;nnen auch in Modulen erzeugt werden. In jeder
Modul-Instanz kann eine Best&uuml;ckungsvariante des jeweiligen Moduls gew&auml;hlt werden.
<p>
Die Best&uuml;ckungsvarianten im Schaltplan und in den Modulen sind v&ouml;llig
unabh&auml;ngig voneinander. Mit dem VARIANT-Befehl ist es nicht m&ouml;glich
eine Best&uuml;ckungsvariante eines Moduls auszuw&auml;hlen.
<p>
Der Klarheit wegen unterscheiden wir deswegen zwischen <b><i>Modul-Best&uuml;ckungsvarianten</i></b>
und <b><i>Haupt-Best&uuml;ckungsvarianten</b></i>. Innerhalb eines Moduls bezieht sich der
VARIANT-Befehl auf dessen Modul-Best&uuml;ckungsvarianten, auf den Haupt-Schaltplanseiten
auf die Haupt-Best&uuml;ckungsvarianten.


<a name=110>
<h1>VIA</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Plazieren von Durchkontaktierungen in Platinen.
<dt>
<b>Syntax</b>
<dd>
<tt>VIA ['signal_name'] [diameter] [shape] [layers] [flags] &#149;..</tt>
</dl>
<b>Siehe auch</b> <a href=#101>SMD</a>,
<a href=#37>CHANGE</a>,
<a href=#47>DISPLAY</a>,
<a href=#97>SET</a>,
<a href=#77>PAD</a>,
<a href=#139>Design Rules</a>
<p>
Der VIA-Befehl plaziert ein Via in einer Platine. Dabei f&uuml;gt er
das Via zu einem Signal hinzu (falls es auf einer Leitung plaziert
wird). Werden durch das Via zwei oder mehrere Signale verbunden,
so erfolgt eine Nachfrage, ob dies wirklich beabsichtgt ist.
<h2>Signalname</h2>
Der Parameter <tt>signal_name</tt> ist in erster Linie f&uuml;r die
Anwendung in Script-Dateien gedacht, die generierte Daten einlesen.
Wenn ein Signalname angegeben ist, werden alle folgenden Vias mit
diesem Signal verbunden, und es wird keine automatische Pr&uuml;fung
durchgef&uuml;hrt.<br>
<b>Diese M&ouml;glichkeit ist mit gro&szlig;er Vorsicht
einzusetzen, da es zu Kurzschl&uuml;ssen kommen kann, wenn ein Via so
plaziert wird, dass es unterschiedliche Signale verbindet. Bitte f&uuml;hren
Sie deshalb einen
<a href=#48>Design Rule Check</a> durch, nachdem Sie
den VIA-Befehl mit dem Parameter
<tt>signal_name</tt> benutzt haben!</b>
<h2>Via-Durchmesser und Bohrdurchmesser</h2>
Die Eingabe eines Durchmessers vor dem Plazieren &auml;ndert die Gr&ouml;&szlig;e
des Vias. Der Durchmesser wird in der aktuellen Ma&szlig;einheit angegeben.
Er darf maximal 200 mm (ca. 7.7840 Zoll) betragen.
<p>
Die eingegebene Gr&ouml;&szlig;e bleibt f&uuml;r nachfolgende Operationen
erhalten.
<p>
Der Bohrdurchmesser entspricht dem Durchmesser, der f&uuml;r Pads eingestellt
ist. Er l&auml;sst sich mit
<pre>
CHANGE DRILL durchmesser &#149;
</pre>
einstellen und ver&auml;ndern.
<p>
Vias erzeugen Bohrsymbole im Layer Drills und die L&ouml;tstopmaske in den
Layern tStop/bStop.
<h2>Via-Form</h2>
Ein Via kann eine der folgenden Formen (shape) haben:
<p>
   Square      quadratisch<br>
   Round       rund<br>
   Octagon     achteckig
<p>
Diese Formen gelten nur f&uuml;r die Aussenlagen (Top bzw. Bottom).
In den Innenlagen ist die Form immer "rund".
<p>
Die Via-Form kann entweder (wie der Durchmesser) eingegeben werden,
w&auml;hrend der VIA-Befehl aktiv ist, oder sie kann mit dem Befehl
<pre>
CHANGE SHAPE shape &#149;
</pre>
ver&auml;ndert werden.
<p>
Die eingegebene Form bleibt f&uuml;r nachfolgende Operationen erhalten.
<p>
Beachten Sie bitte, dass die tats&auml;chlichen Werte f&uuml;r Via-Form und -Durchmesser durch die
<a href=#139>Design Rules</a> des Boards bestimmt werden, in dem das Via
verwendet wird.
<h2>Layer</h2>
Der Parameter <tt>layers</tt> gibt an &uuml;ber welche Layer sich
dieses Via erstrecken soll. Die Syntax ist <tt>von-nach</tt>, wobei 'von' und 'nach'
die Layer-Nummern sind &uuml;ber die sich das Via erstrecken soll. So w&uuml;rde zum
Beispiel <tt>2-7</tt> ein Via erzeugen, das von Layer 2 bis Layer 7 geht (<tt>7-2</tt> h&auml;tte
die selbe Bedeutung). Falls das Layer-Setup in den <a href=#139>Design Rules</a> genau dieses
Via nicht zul&auml;sst, wird das n&auml;chst l&auml;ngere Via genommen (bzw. eine Fehlermeldung
ausgegeben, falls kein solches Via gesetzt werden kann).
<h2>Flags</h2>
Folgende <i>flags</i> k&ouml;nnen dazu benutzt werden, das Erscheinungsbild eines Vias zu
beeinflussen:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>STOP</tt>  </td><td width=20><td>L&ouml;tstopmaske immer generieren</td></tr>
</table>
<p>
Standardm&auml;&szlig;ig generiert ein Via mit einem Bohrdurchmesser kleiner oder gleich dem
Wert des <a href=#139>Design Rules</a> Parameters "Masks/Limit" keine
L&ouml;tstopmaske. Das obige <tt>STOP</tt>-Flag kann dazu benutzt werden, eine L&ouml;tstopmaske
f&uuml;r ein Via zu forcieren.


<a name=111>
<h1>WINDOW</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Bildausschnitt festlegen oder Bild auffrischen.
<dt>
<b>Syntax</b>
<dd>
<tt>WINDOW;</tt><br>
<tt>WINDOW &#149;;</tt><br>
<tt>WINDOW &#149; &#149;;</tt><br>
<tt>WINDOW &#149; &#149; &#149;</tt><br>
<tt>WINDOW scale_factor</tt><br>
<tt>WINDOW FIT</tt><br>
<tt>WINDOW LAST</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Linke&amp;Ziehen</mb> definiert einen rechteckigen Bildausschnitt (entspricht "<tt>&#149; &#149;;</tt>)".
<dt>
<b>Tastatur</b>
<dd>
<tt>Alt+F2: WINDOW FIT </tt>   Zeichnung formatf&uuml;llend darstellen<br>
<tt>F2:     WINDOW;    </tt>   Bild auffrischen<br>
<tt>F3:     WINDOW 2   </tt>   Hineinzoomen um Faktor 2<br>
<tt>F4:     WINDOW 0.5 </tt>   Herauszoomen um Faktor 2<br>
<tt>F5:     WINDOW (@);</tt>   Neues Zentrum an aktueller Position des Mauszeigers (falls Befehl aktiviert)
</dl>
Der WINDOW-Befehl legt den sichtbaren Ausschnitt der Zeichnung fest.
Ohne weitere Parameter frischt der Befehl das Bild auf.
<h2>Neues Zentrum</h2>
Der WINDOW-Befehl mit einem Mausklick legt diesen Punkt in die
Fenstermitte und l&auml;sst den Ma&szlig;stab unver&auml;ndert.
Den Bildausschnitt k&ouml;nnen Sie auch mit den Slidern am Rand des
Arbeitsbereichs verschieben. Mit F5 legen Sie die Position
des Mauszeigers als neues Zentrum fest.
<h2>Eckpunkte festlegen</h2>
Der WINDOW-Befehl mit zwei Mausklicks legt einen Ausschnitt
fest, bei dem beide Punkte gerade noch innerhalb des Fensters liegen
- eine sehr bequeme M&ouml;glichkeit f&uuml;r Ausschnittvergr&ouml;&szlig;erungen.
Das Seitenverh&auml;ltnis der Zeichnung wird nicht ge&auml;ndert.
<h2>Neues Zentrum und zoomen</h2>
Der WINDOW-Befehl mit drei Mausklicks legt einen Auschnitt fest, bei
dem der erste Punkt im Zentrum liegt. Das Verh&auml;ltnis des Abstandes von
Punkt 1 zu Punkt 2 und von Punkt 1 zu Punkt 3 legt den
Vergr&ouml;&szlig;erungsfaktor fest. Dabei gilt: Liegt der dritte Punkt weiter
entfernt vom ersten als der zweite, dann erscheinen die Objekte
gr&ouml;&szlig;er.
<h2>Zoomen</h2>
<pre>
WINDOW 2
</pre>
vergr&ouml;&szlig;ert die Darstellung der Objekte um Faktor zwei.
<pre>
WINDOW 0.5
</pre>
verkleinert die Darstellung der Objekte um Faktor zwei.
<h2>Zeichnung formatf&uuml;llend</h2>
<pre>
WINDOW FIT
</pre>
stellt die gesamte Zeichnung im Fenster dar.
<h2>Zur&uuml;ck zum vorhergehenden Ausschnitt</h2>
<pre>
WINDOW LAST;
</pre>
schaltet zur&uuml;ck zum vorherigen Bildausschnitt. Ein Bildausschnitt wird bei jedem
WINDOW-Befehl neu hinterlegt, jedoch nicht bei reinen Zoom-WINDOW-Befehlen und
Ver&auml;nderungen des Bildausschnitts mit der Maus.
<h2>Sehr gro&szlig;e Zoom-Faktoren</h2>
Standardm&auml;&szlig;ig ist der maximale Zoom-Faktor auf einen Wert begrenzt, bei dem eine
Fl&auml;che mit 1mm Durchmesser noch formatf&uuml;llend dargestellt wird. Falls Sie weiter
hineinzoomen wollen, k&ouml;nnen Sie den Schalter "Optionen/Benutzeroberfl&auml;che/Zoomfaktor limitieren"
ausschalten. Sie k&ouml;nnen dann so weit hineinzoomen, bis die feinste Aufl&ouml;sung des
Rasters sichtbar ist.
<p>
Wenn Sie sehr stark in eine Zeichnung hineinzoomen k&ouml;nnen folgende Dinge passieren:
<ul>
<li>Texte, die nicht den Vektor-Font benutzen, werden nicht mehr dargestellt, wenn
    sie gr&ouml;&szlig;er sind als das Editor-Fenster.
<li>Kreise und Kreisb&ouml;gen werden angen&auml;hert und erscheinen daher unter Umst&auml;nden nicht
    genau an der erwarteten Stelle (insbesondere wenn sie eine sehr kleine Breite haben).
<li>Ob die Grid-Linien im feinsten Raster sichtbar werden, wenn Sie ganz hineinzoomen,
    h&auml;ngt von der Bildschirmaufl&ouml;sung, der Gr&ouml;&szlig;e des Editor-Fensters und dem Wert
    in "Optionen/Einstellungen/Verschiedenes/Min. sichtbare Rastergr&ouml;&szlig;e" ab.
</ul>
<h2>Parameter-Aliase</h2>
Parameter-Aliase k&ouml;nnen dazu benutzt werden, bestimmte Parameter-Einstellungen des WINDOW-Befehls
zu definieren, die sp&auml;ter unter einem gegebenen Namen angesprochen werden k&ouml;nnen.
Die Aliase k&ouml;nnen auch benutzt werden indem Sie auf den "WINDOW Select"-Button klicken
und die Maustaste gedr&uuml;ckt halten bis die Liste erscheint.
Ein Klick auf den Button mit der rechten Maustaste l&auml;&szlig;t die Liste ebenfalls erscheinen.
<p>
Die Syntax zur Bearbeitung dieser Aliase ist:
<dl>
<dt>
<tt>WINDOW = <i>name</i> <i>parameter</i></tt>
<dd>
Definiert den Alias <i>name</i>, der in die angegebenen <i>parameter</i>
expandiert wird. Der <i>name</i> darf aus beliebig vielen Buchstaben, Ziffern
und Unterstrichen bestehen, und Gro&szlig;-/Kleinschreibung spielt keine Rolle.
Er muss mit einem Buchstaben oder Unterstrich beginnen und darf keines der
Options-Schl&uuml;sselworte sein.
<dt>
<tt>WINDOW = <i>name</i> @</tt>
<dd>
Definiert den Alias <i>name</i>, der in die aktuelle Bildausschnitt-Einstellung
expandiert wird.
<dt>
<tt>WINDOW = ?</tt>
<dd>
Erfragt vom Benutzer einen Namen zur Definition eines Aliases f&uuml;r
die aktuelle Bildausschnitt-Einstellung.
<dt>
<tt>WINDOW = <i>name</i></tt>
<dd>
Erlaubt es dem Benutzer einen Bildausschnitt zu w&auml;hlen, der als Alias unter
 dem angegebenen Namen gespeichert wird.
<dt>
<tt>WINDOW = <i>name</i>;</tt>
<dd>
L&ouml;scht den Alias mit dem angegebenen Namen.
<dt>
<tt>WINDOW <i>name</i></tt>
<dd>
Expandiert den Alias mit dem angegebenen Namen und f&uuml;hrt den WINDOW-Befehl
mit dem resultierenden Satz von Parametern aus. Der <i>name</i> kann
abgek&uuml;rzt werden und es d&uuml;rfen andere Parameter vor und nach dem
Alias angegeben werden (auch andere Aliase). Beachten Sie bitte,
dass im Falle einer abgek&uuml;rzten Eingabe Aliase Vorrang vor anderen Schl&uuml;sselw&ouml;rtern
des Befehls haben.
</dl>
Beispiel:
<p>
<tt>WINDOW = MyWindow (0 0) (4 3);</tt>
<p>
Definiert den Alias "MyWindow" der, wenn er wie in
<p>
<tt>WINDOW myw</tt>
<p>
benutzt wird, den angegebenen Bildausschnitt einstellt.
Beachten Sie bitte die abgek&uuml;rzte Verwendung des Aliases,
und dass die Gro&szlig;-/Kleinschreibung keine Rolle spielt.


<a name=112>
<h1>WIRE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Wires (Linien) zeichnen.
<dt>
<b>Syntax</b>
<dd>
<tt>WIRE ['signal_name'] [width] &#149; &#149;..</tt><br>
<tt>WIRE ['signal_name'] [width] [ROUND | FLAT] &#149; [curve | @radius] &#149;..</tt>
<dt>
<b>Maustasten</b>
<dd>
<mb>Mittlere</mb> w&auml;hlt den Layer.<br>
<mb>Rechte</mb> &auml;ndert den Knickwinkel (siehe <a href=#97>SET Wire_Bend</a>).<br>
<mb>Shift+Rechte</mb> kehrt die Richtung des Weiterschaltens des Knickwinkels um.<br>
<mb>Ctrl+Linke</mb> am Begin eines Wires schnappt zum n&auml;chstgelegenen existierenden Wire-Endpunkt.<br>
<mb>Ctrl+Rechte</mb> schaltet zwischen korrespondierenden Knickwinkeln hin und her.<br>
<mb>Ctrl+Linke</mb> beim Absetzen eines Wire-Endpunktes definiert den Kreisbogen-Radius.
</dl>
<b>Siehe auch</b> <a href=#69>MITER</a>,
<a href=#99>SIGNAL</a>,
<a href=#94>ROUTE</a>,
<a href=#37>CHANGE</a>,
<a href=#73>NET</a>,
<a href=#36>BUS</a>,
<a href=#44>DELETE</a>,
<a href=#92>RIPUP</a>,
<a href=#31>ARC</a>
<p>
Der WIRE-Befehl plaziert Wires (Linien) in einer Zeichnung, und zwar
zwischen erstem und zweitem Koordinatenpunkt. Jeder weitere Punkt
(Mausklick) wird mit dem vorhergehenden verbunden. Dabei werden jeweils
zwei Koordinatenpunkte mit einer geraden Linie verbunden oder mit
zwei, die in einem bestimmten Winkel abknicken. Dieser Knickwinkel
l&auml;sst sich mit der rechten Maustaste weiterschalten (wird dabei die Shift-Taste
gedr&uuml;ckt gehalten kehrt sich die Richtung des Weiterschaltens um, bei gedr&uuml;ckter
Ctrl-Taste wird zwischen korrespondierenden Knickwinkeln hin und her geschaltet).
<p>
Zwei Mausklicks an derselben Stelle setzen das Leitungsst&uuml;ck ab.
<p>
Die speziellen Schl&uuml;sselworte <tt>ROUND</tt> und <tt>FLAT</tt>, sowie der <i>curve</i>
Parameter, k&ouml;nnen dazu benutzt werden, Kreisb&ouml;gen zu zeichnen (siehe unten).
<p>
Wird das Zeichnen eines Wires mit gedr&uuml;ckter Ctrl-Taste gestartet, so
schnappt der Startpunkt des neuen Wires an die Koordinaten des
n&auml;chstgelegenen existierenden Wires. Dies ist besonders n&uuml;tzlich, wenn
der existierende Wire au&szlig;erhalb des aktuellen Rasters liegt. Hierbei
werden auch die Breite, der Layer und der Linientyp vom existierenden
Wire &uuml;bernommen. Falls der aktuelle Kickwinkel 7 ("Freihand") ist, so
setzt der neue Wire den existierenden b&uuml;ndig fort.
<h2>Signalname</h2>
Der Parameter <tt>signal_name</tt> ist in erster Linie f&uuml;r die
Anwendung in Script-Dateien gedacht, die generierte Daten einlesen.
Wenn ein Signalname angegeben ist, werden alle folgenden Wires mit
diesem Signal verbunden, und es wird keine automatische Pr&uuml;fung
durchgef&uuml;hrt.<br>
<b>Diese M&ouml;glichkeit ist mit gro&szlig;er Vorsicht
einzusetzen, da es zu Kurzschl&uuml;ssen kommen kann, wenn ein Wire so
plaziert wird, dass er unterschiedliche Signale verbindet. Bitte f&uuml;hren
Sie deshalb einen
<a href=#48>Design Rule Check</a> durch, nachdem Sie
den WIRE-Befehl mit dem Parameter
<tt>signal_name</tt> benutzt haben!</b>
<h2>Strichst&auml;rke</h2>
Gibt man den Befehl mit dem Parameter <i>width</i> (z. B. 0.1)
ein, dann wird dadurch die Linienbreite in der aktuellen Ma&szlig;einheit
festgelegt. Zul&auml;ssig ist maximal 200 mm (ca. 7.7840 Zoll). Die
Linienbreite bleibt f&uuml;r nachfolgende Operationen erhalten.
<p>
Die Breite l&auml;sst sich auch zu jeder Zeit mit dem Befehl
<pre>
CHANGE WIDTH breite &#149;
</pre>
&auml;ndern oder voreinstellen.
<p>
Bitte verwenden Sie den WIRE-Befehl nicht f&uuml;r Netze und
Busse sowie f&uuml;r Luftlinien. Siehe
<a href=#73>NET</a>,
<a href=#36>BUS</a> und
<a href=#99>SIGNAL</a>.
<h2>Linienarten</h2>
Linien k&ouml;nnen in folgenden Arten (<i>styles</i>) gezeichnet werden::
<ul>
<li>Continuous - durchgezogen
<li>LongDash   - (lang) gestrichelt
<li>ShortDash  - (kurz) gestrichelt
<li>DashDot    - Strich-Punkt-Linie
</ul>
Die Linienart kann mit dem <a href=#37>CHANGE</a>-Befehl ver&auml;ndert werden.
<p>
DRC und Autorouter behandeln alle Linienarten als durchgezogen (Continuous).
Andere Linienarten werden haupts&auml;chlich f&uuml;r elektrische oder mechanische
Zeichnungen verwendet und sollten nicht in Signallayern benutzt werden.
Der DRC meldet einen Fehler, wenn Sie eine Nicht-continuous-Linie
als Teil einer signalf&uuml;hrenden Leiterbahn mit einem Pad verbinden.
<h2>Signale in Top-, Bottom und Route-Layern</h2>
Wires in den Layern Top, Bottom, Route2.. werden als Signale behandelt.
Wird ein Wire in einem der Signal-Layer an einem bestehenden Signal
angesetzt, so geh&ouml;rt der gesamte gezeichnete Wire-Zug zu diesem
Signal (nur, wenn die Wire-Enden bzw. das Wire-Ende und der Pad-Mittelpunkt
genau &uuml;bereinstimmen). Setzt man das Ende eines Wires an einem anderen Signal ab,
fragt EAGLE zur Best&auml;tigung nach, ob die beiden Signale wirklich
miteinander verbunden werden sollen. Jedes Geradenst&uuml;ck wird von
EAGLE (z. B. beim RIPUP-Befehl) als eigenes Objekt behandelt.
<h2>Kreisb&ouml;gen zeichnen</h2>
Wires und Kreisb&ouml;gen sind im Grunde die selben Objekte, so dass man einen Kreisbogen entweder mit dem
<a href=#31>ARC</a>-Befehl zeichnen kann, oder indem man die n&ouml;tigen Parameter
zum WIRE-Befehl hinzuf&uuml;gt. Damit aus einem Wire ein Kreisbogen wird, ben&ouml;tigt dieser entweder
den <i>curve</i> Parameter, der angibt wie stark der Kreisbogen gekr&uuml;mmt sein soll, oder den
<i>@radius</i> Parameter, der den Radius des Kreisbogens bestimmt (beachten Sie den <tt>'@'</tt>,
welcher n&ouml;tig ist, um <i>curve</i> und <i>radius</i> unterscheiden zu k&ouml;nnen).
<p>
Der g&uuml;ltige Bereich f&uuml;r <i>curve</i> ist <tt>]-360</tt>..<tt>+360[</tt> (also ohne die Grenzen +-360),
wobei der Wert angibt, aus welchem Anteil eines Vollkreises der Kreisbogen besteht. Ein Wert von <tt>90</tt>
beispielsweise steht f&uuml;r einen Viertelkreis, w&auml;hrend <tt>180</tt> einen Halbkreis
ergibt. Es k&ouml;nnen keine Vollkreise auf diese Art erzeugt werden
(verwenden Sie dazu den <a href=#38>CIRCLE</a>-Befehl).
Positive Werte f&uuml;r <i>curve</i> bedeuten, dass der Kreisbogen im mathematisch positiven Sinne
(also gegen den Uhrzeigersinn) gezeichnet wird. Falls <i>curve</i> gleich <tt>0</tt>
ist, handelt es sich um eine gerade Linie ("keine Kr&uuml;mmung"), was letztlich einem
Wire entspricht. Beachten Sie bitte, dass, um den <i>curve</i> Parameter vom <i>width</i>
Parameter unterscheiden zu k&ouml;nnen, dieser immer mit Vorzeichen (<tt>'+'</tt> oder
<tt>'-'</tt>) angegeben werden muss, auch wenn es eine positive Zahl ist.
<p>
Zum Beispiel w&uuml;rde der Befehl
<pre>
WIRE (0 0) +180 (0 10);
</pre>
einen Halbkreis entgegen dem Uhrzeigersinn vom Punkt (0 0) nach (0 10) zeichnen.
<p>
Wird ein <i>radius</i> angegeben, so erh&auml;lt der Kreisbogen diesen Radius. Genau wie der
<i>curve</i>-Parameter muss auch der <i>radius</i> mit Vorzeichen angegeben werden
um die Orientierung des Kreisbogens zu bestimmen.
Zum Beispiel zeichnet der Befehl
<pre>
WIRE (0 0) @+100 (0 200);
</pre>
einen Halbkreis vom Punkt (0 0) nach (0 200) (mit Radius 100), entgegen dem
Uhrzeigersinn. Liegt der Endpunkt des Wires um mehr als den doppelten Radius vom
Startpunkt entfernt, so wird eine gerade Linie gezeichnet.
<p>
Der Kreisbogen-Radius kann auch dadurch definiert werden, dass der Wire-Endpunkt mit gedr&uuml;ckter
<tt>Ctrl</tt>-Taste gesetzt wird (typischerweise am Mittelpunkt des Kreises auf dem
der Kreisbogen liegen soll). In diesem Fall wird der Punkt nicht als eigentlicher
Endpunkt genommen, sondern dazu benutzt den Radius des Kreisbogens festzulegen. Sie k&ouml;nnen
dann den Mauszeiger bewegen und einen Kreisbogen mit dem gegebenen Radius plazieren (die
rechte Maustaste zusammen mit <tt>Ctrl</tt> schaltet die Orientierung des Kreisbogens um).
Falls Sie den Mauszeiger weiter als den doppelten Radius vom Startpunkt wegbewegen wird
eine gerade Linie gezeichnet.
<p>
Um jeden beliebigen Kreisbogen mit dem WIRE-Befehl zeichnen zu k&ouml;nnen (was insbesondere bei der
Generierung von Script-Dateien wichtig ist) sind die Schl&uuml;sselworte <tt>ROUND</tt> und
<tt>FLAT</tt> im WIRE-Befehl ebenfalls erlaubt. Beachten Sie aber, dass diese nur bei
echten Kreisb&ouml;gen Anwendung finden (geradlinige Wires haben immer runde Enden). Standardm&auml;&szlig;ig
haben mit dem WIRE-Befehl erzeugte Kreisb&ouml;gen runde Enden.


<a name=113>
<h1>WRITE</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Abspeichern einer Zeichnung oder Bibliothek.
<dt>
<b>Syntax</b>
<dd>
<tt>WRITE;</tt><br>
<tt>WRITE drawing_name</tt><br>
<tt>WRITE @drawing_name</tt>
</dl>
Der WRITE-Befehl sichert eine Zeichnung oder eine Bibliothek im
<a href=#15>Projektverzeichnis</a>.
Man kann einen neuen Namen w&auml;hlen oder denjenigen beibehalten,
unter dem die Zeichnung/Bibliothek geladen wurde.
<p>
Dem Namen kann man auch einen Pfadnamen voranstellen, wenn die Datei
in ein bestimmtes Verzeichnis gesichert werden soll.
<p>
Wird dem neuen Namen ein <tt>@</tt> vorangestellt, so wird auch der Name
der geladenen Zeichnung entsprechend ge&auml;ndert. Die zugeh&ouml;rige Platine/Schaltplan
wird dann automatisch ebenfalls unter diesem Namen abgespeichert, und der
Undo-Puffer wird gel&ouml;scht.
<p>
Um die Konsistenz der
<a href=#372>Forward&amp;Back-Annotation</a>
zwischen Platine und Schaltplan zu gew&auml;hrleisten, verh&auml;lt sich der WRITE-Befehl
wie folgt:
<ul>
<li>Wenn eine Platinen-/Schaltplan-Datei unter dem selben Namen gespeichert wird,
wird die zugeh&ouml;rige Schaltplan-/Platinen-Datei ebenfalls gespeichert, sofern sie
ge&auml;ndert wurde.
<li>wenn eine Platinen-/Schaltplan-Datei unter einem unterschiedlichen Namen
gespeichert wurde, fragt das Programm, ob die zugeh&ouml;rige
Schaltplan-/Platinen-Datei ebenfalls unter diesem Namen gespeichert werden soll.
<li>Beim Speichern unter einem unterschiedlichen Namen wird das
"Modified"-Flag nicht gel&ouml;scht.
</ul>


<a name=114>
<h1>Ausgabedaten erzeugen</h1>
<ul>
<li><a href=#115>Ausdruck mit PRINT</a>
<li><a href=#119>CAM-Prozessor</a>
<li><a href=#136>Konturdaten</a>
</ul>


<a name=115>
<h1>Drucken</h1>
Die Parameter f&uuml;r das Drucken auf den Systemdrucker k&ouml;nnen mit folgenden
drei Dialogen eingestellt werden:
<ul>
<li><a href=#116>Drucken einer Zeichnung</a>
<li><a href=#117>Drucken eines Textes</a>
<li><a href=#118>Seiteneinrichtung</a>
</ul>
<b>Siehe auch</b> <a href=#84>PRINT</a>


<a name=116>
<h1>Drucken einer Zeichnung</h1>
Wenn Sie den <a href=#84>PRINT</a>-Befehl ohne abschlie&szlig;enden
<tt>';'</tt> eingeben, oder wenn Sie <b>Print</b> aus dem
<a href=#14>Kontext-Men&uuml;</a> des Icons einer Zeichnung im
<a href=#13>Control Panel</a> ausw&auml;hlen, erhalten Sie einen
Dialog mit folgenden Optionen:
<h2>Papier</h2>
Definiert das zu verwendende Papierformat.
<h2>Ausrichtung</h2>
Definiert die Papierausrichtung.
<h2>Voransicht</h2>
Schaltet die Druck-Voransicht ein bzw. aus.
<h2>Spiegeln</h2>
Spiegelt die Ausgabe.
<h2>Drehen</h2>
Dreht die Ausgabe um 90&deg;.
<h2>Kopf&uuml;ber</h2>
Dreht die Ausgabe um 180&deg;. Zusammen mit <b>Drehen</b> wird die Zeichnung um insgesamt 270&deg; gedreht.
<h2>Schwarz</h2>
Ignoriert die Farbeinstellungen der Layer und druckt alles in Schwarz.
<h2>Gef&uuml;llt</h2>
Ignoriert die F&uuml;llmuster der Layer und druckt alles voll ausgef&uuml;llt.
<h2>Skalierungsfaktor</h2>
Skaliert die Zeichnung mit dem gegebenen Wert.
<h2>Blatt-Limit</h2>
Gibt an wieviele Bl&auml;tter der Ausdruck maximal haben soll.
Falls die Zeichnung nicht auf die angegebene Zahl von Bl&auml;ttern passt, wird
der tats&auml;chliche Skalierungsfaktor so lange verkleinert, bis sie passt.
Der Standardwert von <tt>0</tt> bedeutet "kein Limit".
<h2>Alle</h2>
Alle Seiten des Schaltplans werden ausgedruckt
(das ist der Standardwert, wenn <b>Print</b> aus dem
<a href=#14>Kontext-Men&uuml;</a> eines Schaltplan-Icons
ausgew&auml;hlt wird).
<h2>Von...bis</h2>
Nur die angegebenen Seiten werden ausgedruckt.
<h2>Diese</h2>
Es wird nur die Seite ausgedruckt, die gerade editiert wird
(das ist der Standardwert, wenn der <a href=#84>PRINT</a>-Befehl
in einem Schaltplan-Editor Fenster verwendet wird).
<h2>Hierarchie</h2>
Schaltplanseiten von Modulen werden f&uuml;r jede Verwendung in Modulinstanzen
mit entsprechenden Bauteil- und Netznamen gedruckt.
<h2>Drucker...</h2>
Ruft den System-Druckerdialog auf, in dem der Drucker ausgew&auml;hlt werden kann
sowie druckerspezifische Parameter eingestellt werden k&ouml;nnen.
<h2>PDF...</h2>
Erzeugt eine PDF-Datei (Portable Document Format) mit den gew&auml;hlten Druckeinstellungen.
<p>
Die restlichen Optionen dienen der <a href=#118>Seiteneinrichtung</a>.


<a name=117>
<h1>Drucken eines Textes</h1>
Wenn Sie <b>Print</b> aus dem
<a href=#14>Kontext-Men&uuml;</a> des Icons einer Textdatei im
<a href=#13>Control Panel</a> oder aus dem <b>Datei</b>
Men&uuml; des <a href=#27>Text-Editors</a> ausw&auml;hlen, erhalten Sie
einen Dialog mit folgenden Optionen:
<h2>Lange Zeilen umbrechen</h2>
Schaltet den Zeilenumbruch f&uuml;r zu lange Zeilen ein.
<h2>Drucker...</h2>
Ruft den System-Druckerdialog auf, in dem der Drucker ausgew&auml;hlt werden kann
sowie druckerspezifische Parameter eingestellt werden k&ouml;nnen.
<h2>PDF...</h2>
Erzeugt eine PDF-Datei (Portable Document Format) mit den gew&auml;hlten Druckeinstellungen.
<p>
Die restlichen Optionen dienen der <a href=#118>Seiteneinrichtung</a>.


<a name=118>
<h1>Seiteneinrichtung</h1>
Der Druck-Dialog enth&auml;lt einige Optionen die bestimmen, wie eine Zeichnung oder ein Text
auf dem Papier erscheinen soll.
<h2>Rand</h2>
Definiert den linken, oberen, rechten und unteren Rand. Die Werte werden
entweder in Millimeter oder Inch angegeben, je nachdem, welche Einheit
weniger Dezimalstellen ergibt.
<p>
Die Standardwerte f&uuml;r die R&auml;nder werden vom Druckertreiber &uuml;bernommen
und definieren die maximal bedruckbare Fl&auml;che.
Sie k&ouml;nnen hier auch kleinere Werte angeben, wobei es von Ihrem Drucker
abh&auml;ngt, ob die angegebenen R&auml;nder dann eingehalten werden k&ouml;nnen oder nicht.
<p>
Nach der Auswahl eines anderen Druckers kann es sein, dass neue
ger&auml;tespezifische Grenzen wirksam werden; die vorgegebenen R&auml;nder
werden dann automatisch verg&ouml;&szlig;ert, falls der neue Drucker dies erfordert.
Beachten Sie bitte, dass die Werte nicht automatisch verkleinert werden,
auch wenn der neue Drucker kleinere Werte zulassen w&uuml;rde. Um die
kleinstm&ouml;glichen Werte f&uuml;r die R&auml;nder zu ermitteln, geben Sie in jedes Feld
<tt>0</tt> ein. Dieser Wert wird dann durch das ger&auml;tespezifische Minimum
ersetzt.
<h2>Kalibrieren</h2>
Falls Sie mit Ihrem Drucker Produktionsvorlagen erstellen wollen,
kann es n&ouml;tig sein, den Drucker zu kalibrieren um exakte 1:1
Ausdrucke Ihrer Layouts zu erhalten.
<p>
Der Wert im <b>X</b> Feld gibt den Kalibrierungsfaktor in der Richtung
an, in der sich der Druckkopf bewegt. Der Wert im <b>Y</b> Feld
kalibriert die Koordinaten in Papiervorschubrichtung.
<p>
<b>ACHTUNG: Wenn Sie mit Ihrem Drucker Produktionsvorlagen erzeugen,
pr&uuml;fen Sie bitte immer das Druckergebnis auf Einhaltung der exakten Ma&szlig;e!</b>
<p>
Die Standardwerte von <tt>1</tt> gehen davon aus, dass der Drucker in beiden
Richtungen exakt druckt.
<h2>Anordnung</h2>
Definiert die vertikale und horizontale Anordnung der Zeichnung auf dem Papier.
<h2>Bildunterschrift</h2>
Aktiviert die Ausgabe einer Bildunterschrift mit Datum und Uhrzeit des
Ausdrucks sowie dem Dateinamen.
<p>
Bei gespiegelter Ausgabe enth&auml;lt die Bildunterschrift das Wort
"mirrored", und falls der Vergr&ouml;&szlig;erungsfaktor nicht
<tt>1.0</tt> ist, wird er als <b>f=...</b> mit angegeben
(der Vergr&ouml;&szlig;erungsfaktor wird mit 4 Nachkommastellen ausgegeben, so dass
auch eine Angabe von <b>f=1.0000</b> nicht bedeutet, dass der Faktor
<i>exakt</i> <tt>1.0</tt> ist).


<a name=119>
<h1>CAM-Prozessor</h1>
Mit dem CAM-Prozessor k&ouml;nnen Sie jede Layer-Kombination an ein Peripherieger&auml;t
oder in eine Datei ausgeben.
<p>
Die folgenden Hilfe-Themen f&uuml;hren Sie durch die erforderlichen
Schritte, von der Auswahl der Daten-Datei bis zur Konfiguration des
Ausgabeger&auml;ts (Device).
<ul>
<li><a href=#120>Datei ausw&auml;hlen</a>
<li><a href=#122>Device ausw&auml;hlen</a>
<li><a href=#133>Ausgabe-Datei w&auml;hlen</a>
<li><a href=#135>Plot-Layer w&auml;hlen</a>
<li><a href=#123>Device-Parameter einstellen</a>
<li><a href=#134>Flag-Optionen einstellen</a>
</ul>
Sie k&ouml;nnen verschiedene Parameters&auml;tze zu einem
<a href=#121>CAM-Prozessor-Job</a> zusammenstellen,
mit dessen Hilfe Sie einen kompletten Satz von Ausgabedateien durch
Anklicken eines Buttons erzeugen k&ouml;nnen.
<p>
<b>Siehe auch</b> <a href=#115>Drucken auf dem System-Drucker</a>


<a name=120>
<h1>CAM-Prozessor-Hauptmen&uuml;</h1>
Im <i>CAM-Prozessor-Hauptmen&uuml;</i> k&ouml;nnen Sie w&auml;hlen, von welcher
Datei die Ausgabe generiert werden soll, Sie k&ouml;nnen Blenden- und
Bohrer-Konfigurationsdateien bearbeiten oder Job-Dateien laden und
sichern.
<h2>Datei</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>&Ouml;ffnen          </td><td width=20><td>Board...  Board-Datei f&uuml;r Ausgabe laden</td></tr>
<tr><td>                </td><td width=20><td>Schaltplan...  Schaltplan-Datei f&uuml;r Ausgabe laden</td></tr>
<tr><td>                </td><td width=20><td>Bohrertabelle...  Bohrer-Konfigurationsdatei zum Editieren laden</td></tr>
<tr><td>                </td><td width=20><td>Blendentabelle...  Blenden-Konfigurationsdatei zum Editieren laden</td></tr>
<tr><td>                </td><td width=20><td>Job...  Anderen Job laden oder neuen erzeugen</td></tr>
<tr><td>Zuletzt ge&ouml;ffnet</td><td width=20><td>L&auml;dt ein der zuletzt ge&ouml;ffneten Dateien</td></tr>
<tr><td>Job speichern...</td><td width=20><td>Gegenw&auml;rtigen Job sichern</td></tr>
<tr><td>Schlie&szlig;en       </td><td width=20><td>CAM-Prozessor-Fenster schlie&szlig;en</td></tr>
<tr><td>Beenden         </td><td width=20><td>Programm beenden</td></tr>
</table>
<h2>Layer</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Alle abw&auml;hlen      </td><td width=20><td>Alle Layer deselektieren</td></tr>
<tr><td>Ausgew&auml;hlte zeigen </td><td width=20><td>Nur die selektierten Layer anzeigen</td></tr>
<tr><td>Alle zeigen        </td><td width=20><td>Alle Layer anzeigen</td></tr>
</table>
<h2>Fenster</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Control Panel         </td><td width=20><td>Zum Control Panel wechseln</td></tr>
<tr><td>1 Schaltplan - ...    </td><td width=20><td>Zu Fenster 1 wechseln</td></tr>
<tr><td>2 Board - ...         </td><td width=20><td>Zu Fenster 2 wechseln</td></tr>
</table>
<h2>Hilfe</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Allgemein      </td><td width=20><td>Allgemeine Hilfe-Seite &ouml;ffnen</td></tr>
<tr><td>Kontext        </td><td width=20><td>&Ouml;ffnet die Hilfe-Seite f&uuml;r den momentanen Kontext</td></tr>
<tr><td>CAM-Prozessor  </td><td width=20><td>CAM-Prozessor-Hilfe &ouml;ffnen</td></tr>
<tr><td>Job-Hilfe      </td><td width=20><td>Hilfe zum Job-Mechanismus anzeigen</td></tr>
<tr><td>Device-Hilfe   </td><td width=20><td>Hilfe zu Ausgabe-Devices anzeigen</td></tr>
</table>


<a name=121>
<h1>CAM-Prozessor-Job</h1>
Ein CAM-Prozessor-<i>Job</i> besteht aus unterschiedlichen
<i>Sections</i>,
von denen jede einen kompletten Satz von CAM-Prozessor-Parametern
mit einer bestimmten Layer-Auswahl darstellt.
<p>
Ein typischer CAM-Prozessor-Job k&ouml;nnte zum Beispiel zwei Sections
enthalten: eine, die die Fotoplot-Dateien f&uuml;r die Best&uuml;ckungsseite
erzeugt, und eine weitere, die die entsprechenden Daten f&uuml;r die L&ouml;tseite
erzeugt.
<h2>Section</h2>
Der <i>Section</i>-Selektor zeigt die gegenw&auml;rtig aktive Job-Section
an. Durch Anklicken des Buttons k&ouml;nnen Sie jede der vorher
mit dem <i>Add</i>-Button
definierten Sections ausw&auml;hlen.
<h2>Prompt</h2>
Wenn Sie in dieses Feld einen Text eintragen, gibt der CAM-Prozessor
diese Meldung aus, bevor er die zugeh&ouml;rige Job-Section bearbeitet.
Wenn Sie zum Beispiel vor jeder Ausgabe das Papier in den Stiftplotter
einlegen wollen, k&ouml;nnte die Meldung "Bitte Papier wechseln!" lauten.
Jede Section kann ihre eigene Meldung haben. Wenn keine Meldung definiert
ist, wird die Section ohne vorherige Unterbrechung ausgef&uuml;hrt.
<h2>Add</h2>
Klicken Sie den <i>Add</i>-Button an, um dem Job eine neue Section
hinzuzuf&uuml;gen. Sie werden dann nach dem Namen der neuen Section gefragt.
F&uuml;r die neue Section gelten die Parametereinstellungen, die im Men&uuml; zu
sehen sind.<br>
Bitte achten Sie darauf, wenn Sie eine neue Job-Section anlegen, dass
Sie <b>zuerst mit 'Add' die neue Section anlegen</b>
und erst <b>danach die Parameter modifizieren</b>.
Wenn Sie zuerst die Parameter der gegenw&auml;rtigen Section modifizieren
und erst danach mit 'Add' die neue Section anlegen, werden Sie vom
Programm gefragt, ob Sie die &Auml;nderungen an der gegenw&auml;rtigen Section
abspeichern wollen oder nicht.
<h2>Del</h2>
Durch Anklicken des <i>Del</i>-Buttons l&ouml;schen Sie die gegenw&auml;rtige
Job-Section. Bevor die Section gel&ouml;scht wird, m&uuml;ssen Sie die R&uuml;ckfrage,
ob sie wirklich gel&ouml;scht werden soll, best&auml;tigen.
<h2>Process Section</h2>
Der <i>Process Section</i>-Button startet die Datenausgabe f&uuml;r die gegenw&auml;rtig
angezeigte Section.
<h2>Process Job</h2>
Der <i>Process Job</i>-Button startet die Datenausgabe f&uuml;r den gesamten
Job. Dabei wird die zuerst definierte Section zuerst bearbeitet.
Es entstehen die gleichen Ausgabedaten, als w&uuml;rden Sie der Reihe nach
die unterschiedlichen Sections ausw&auml;hlen und mit dem <i>Process Section</i>-Button
starten.


<a name=122>
<h1>Ausgabetreiber (Output Device)</h1>
Der Ausgabetreiber (<i>Output Device</i>) legt fest, welche Art von
Daten der CAM-Prozessor erzeugt. Sie k&ouml;nnen aus den unterschiedlichsten
Treiber den geeigneten ausw&auml;hlen, z.B. f&uuml;r Foto-Plotter, Bohrstationen etc.
<h2>Device</h2>
Durch Anklicken des Device-Selectors &ouml;ffnen Sie eine Liste
aller verf&uuml;gbaren Device-Treiber.
<h2>Skalierungsfaktor</h2>
Bei Ger&auml;ten, die eine Skalierung erlauben, k&ouml;nnen Sie in dieses Feld
einen Skalierungsfaktor eintragen. Werte &uuml;ber <tt>1</tt> f&uuml;hren
zu einer Vergr&ouml;&szlig;erung, Werte unter <tt>1</tt> verkleinern die Ausgabe.
<p>
Sie k&ouml;nnen die Gr&ouml;&szlig;e der Ausgabe auf eine bestimmte Anzahl von Seiten
beschr&auml;nken, indem Sie einen negativen Wert im Scale-Feld eingeben.
In diesem Fall wird der Skalierungsfaktor auf 1.0 voreingestellt und so lange
verkleinert, bis die Zeichnung gerade noch auf die angegebene Anzahl von
Seiten passt. Wird zum Beispiel "-2" eingegeben, so entsteht eine Zeichnung
die nicht mehr als zwei Seiten ben&ouml;tigt. Beachten Sie bitte, dass die zur
Verf&uuml;gung stehende Blattgr&ouml;&szlig;e (Width und Height Parameter) Ihres
Ausgabeger&auml;ts richtig eingestellt sein muss, damit dieser Mechanismus
funktioniert. Diese Gr&ouml;&szlig;en k&ouml;nnen in den Width- und Height-Feldern oder
durch Editieren der Datei eagle.def eingestellt werden.
<h2>Datei</h2>
Sie k&ouml;nnen in dieses Feld den Namen der
<a href=#133>Ausgabedatei</a>
direkt eingeben, oder Sie klicken den
Datei-Button an, um einen Dialog f&uuml;r die Definition
der Ausgabedatei zu &ouml;ffnen.<br>
Wenn Sie den Dateinamen aus dem Namen der
Schaltplan- oder Platinen-Datei ableiten wollen, k&ouml;nnen Sie den Namen
teilweise angeben (mindestens die Extension, z.B. <tt>.gbr</tt>). In
diesem Fall wird der Rest des Dateinamens von der Quelldatei
abgeleitet.
<h2>Blendentabelle</h2>
Sie k&ouml;nnen in dieses Feld den Namen der
<a href=#124>Blenden-Konfigurationsdatei</a>
direkt eingeben, oder Sie klicken den Wheel-Button an, um einen
Datei-Dialog zu &ouml;ffnen und die
Datei zu selektieren.<br>
Wenn Sie den Dateinamen aus dem Namen der
Schaltplan- oder Platinen-Datei ableiten wollen, k&ouml;nnen Sie den Namen
teilweise angeben (mindestens die Extension, z.B. <tt>.whl</tt>). In
diesem Fall wird der Rest des Dateinamens von der Quelldatei
abgeleitet.
<h2>Bohrertabelle</h2>
Sie k&ouml;nnen in dieses Feld den Namen der
<a href=#127>Bohrer-Konfigurationsdatei</a>
direkt eingeben, oder Sie klicken den Rack-Button an, um einen
Datei-Dialog zu &ouml;ffnen und die
Datei zu selektieren.<br>
Wenn Sie den Dateinamen aus dem Namen der
Schaltplan- oder Platinen-Datei ableiten wollen, k&ouml;nnen Sie den Namen
teilweise angeben (mindestens die Extension, z.B. <tt>.drl</tt>). In
diesem Fall wird der Rest des Dateinamens von der Quelldatei
abgeleitet.
Manche Treiber (wie zum Beispiel EXCELLON) k&ouml;nnen die Bohrerkonfiguration automatisch
generieren, wobei dann dieses Feld nicht verf&uuml;gbar ist.


<a name=123>
<h1>Device-Parameter</h1>
Abh&auml;ngig vom gew&auml;hlten <a href=#122>Ausgabetreiber</a>
gibt es verschiedene treiberspezifische Parameter, mit denen Sie
die Ausgabe an Ihre Bed&uuml;rfnisse anpassen k&ouml;nnen.
<ul>
<li><a href=#124>Blenden-Konfigurationsdatei</a>
<li><a href=#125>Blenden-Emulation</a>
<li><a href=#126>Blenden-Toleranzen</a>
<li><a href=#127>Bohrer-Konfigurationsdatei</a>
<li><a href=#128>Bohrer-Toleranzen</a>
<li><a href=#129>Offset</a>
<li><a href=#130>Seitengr&ouml;&szlig;e</a>
<li><a href=#131>Stiftdaten</a>
</ul>


<a name=124>
<h1>Blenden-Konfigurationsdatei</h1>
Dem Fotoplotter muss bekannt sein, welche Blenden den Codes in der Ausgabedatei
entsprechen. Diese Zuordnung ist in der Blenden-Konfigurationsdatei definiert.
<h2>Beispiel</h2>
<pre>
D010    round     0.004
D040    square    0.004
D100    rectangle 0.060 x 0.075
D104    oval      0.030 x 0.090
D110    draw      0.004
</pre>
Die Datei darf mehrere Blenden enthalten, die den gleichen D-Code benutzen, so
lange alle von einem der Typen draw oder round sind und die gleiche
Gr&ouml;&szlig;e haben.
Dies kann dazu benutzt werden um Blenden, die letztlich zum gleichen Zeichenergebnis
f&uuml;hren, auf einen gemeinsamen D-Code abzubilden.


<a name=125>
<h1>Blenden-Emulation</h1>
Wenn die Option "Blenden" gew&auml;hlt ist, werden nicht vorhandene
Blenden mit kleineren Blenden emuliert. Ist sie ausgeschaltet, werden
keine Blenden emuliert.
<p>
Achtung: Die Blendenemulation kann zu sehr langen Plot-Zeiten f&uuml;hren
(hohe Kosten!).


<a name=126>
<h1>Blenden-Toleranzen</h1>
Falls Sie Toleranzen f&uuml;r Draw- bzw. Blitz-Blenden (Flash) angeben,
verwendet der CAM-Prozessor Blenden innerhalb dieser Toleranz, falls
keine mit dem exakten Ma&szlig; verf&uuml;gbar ist.
<p>
Toleranzen werden in Prozent angegeben.
<p>
<b>Bitte beachten Sie, dass dadurch Ihre "Design Rules" unter Umst&auml;nden
nicht mehr eingehalten werden!</b>


<a name=127>
<h1>Bohrer-Konfigurationsdatei</h1>
Falls der Treiber f&uuml;r die Bohrstation die Bohrerkonfiguration nicht automatisch
generieren kann, muss bekannt sein, welche Bohrer den Codes in der Ausgabedatei
entsprechen. Diese Zuordnung ist in der Bohrer-Konfigurationsdatei definiert.
<p>
Die Datei kann mit Hilfe eines User-Language-Programms drillcfg.ulp, das sich im
ULP-Verzeichnis Ihrer EAGLE-Installation befindet, erzeugt werden.
Verwenden Sie dazu den Befehl <a href=#95>RUN</a>.
<h2>Beispiel</h2>
<pre>
T01   0.010
T02   0.016
T03   0.032
T04   0.040
T05   0.050
T06   0.070
</pre>


<a name=128>
<h1>Bohrer-Toleranzen</h1>
Falls Sie eine Toleranz f&uuml;r Bohrer angeben, verwendet der
CAM-Prozessor Bohrer innerhalb dieser Toleranz, falls keiner mit dem
exakten Ma&szlig; verf&uuml;gbar ist.
<p>
Toleranzen werden in Prozent angegeben.


<a name=129>
<h1>Offset</h1>
Offset in x- und y-Richtung (Inch, Dezimalzahl)
<p>
Kann dazu verwendet werden den Nullpunkt von gro&szlig;formatigen Plottern in die linke
untere Ecke zu verlegen.


<a name=130>
<h1>Bedruckbarer Bereich</h1>
<h2>Height</h2>
Bedruckbarer Bereich in y-Richtung (Inch).
<h2>Width</h2>
Bedruckbarer Bereich in x-Richtung (Inch).
<p>
Bitte beachten Sie, dass der CAM-Prozessor die Zeichnung auf mehrere
Teile aufteilt, falls das umschlie&szlig;ende Rechteck um alle in der
Datei enthaltenen Objekte (auch in Layern, die nicht ausgebeben
werden) nicht auf die bedruckbare Fl&auml;che passt.


<a name=131>
<h1>Stiftdaten</h1>
<h2>Diameter</h2>
Stift-Durchmesser in mm: Wird beim F&uuml;llen von Fl&auml;chen zur
Berechnung der notwendigen Anzahl von Linien benutzt.
<h2>Velocity</h2>
Stiftgeschwindigkeit in cm/s (bei Stift-Plottern, die
unterschiedliche Geschwindigkeiten unterst&uuml;tzen). Die
Plotter-Default-Geschwindigkeit w&auml;hlt man mit dem Wert 0.


<a name=132>
<h1>Eigenen Device-Treiber definieren</h1>
Die Ausgabetreiber sind in der Textdatei eagle.def definiert.
Dort finden Sie Details, wie man einen eigenen Treiber definiert.
Am besten kopieren Sie einen Block eines existierenden Treibers
f&uuml;r denselben Ger&auml;tetyp und passen dann die Paramter an.
<p>
Bitte verwenden Sie einen <a href=#27>Text-Editor</a>,
der keine Steuerzeichen in die Datei schreibt.


<a name=133>
<h1>Ausgabedatei</h1>
Die <i>Ausgabedatei</i> enth&auml;lt die Daten, die vom CAM-Prozessor
erzeugt werden.
<p>
Folgende Dateinamen sind &uuml;blich:
<pre>
=======================================================
Datei- Selekt. Layer        Bedeutung
name
=======================================================
*.cmp  Top, Via, Pad        Bauteilseite
*.ly2  Route2, Via, Pad     Multilayer-Innenlage
*.ly3  Route3, Via, Pad     Multilayer-Innenlage,
...                         ...
*.sol  Bot, Via, Pad        L&ouml;tseite
*.plc  tPl, Dim, tName,     Best&uuml;ckungsplan Bauteilseite
*.pls  bPl, Dim, bName,     Best&uuml;ckungsplan L&ouml;tseite
*.stc  tStop                L&ouml;tstopmaske Bauteilseite
*.sts  bStop                L&ouml;tstopmaske L&ouml;tseite
*.drd  Drills, Holes        Bohrdaten f&uuml;r NC-Bohrmaschine
=======================================================
</pre>
<h2>Platzhalter</h2>
Der Ausgabedateiname kann entweder direkt eingegeben oder mittels <i>Platzhaltern</i>
dynamisch zusammengesetzt werden. Ein Platzhalter besteht aus dem Prozentzeichen
(<tt>'%'</tt>) gefolgt von einem Buchstaben. Folgende Platzhalter sind
definitert:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%D{xxx}</tt></td><td width=20><td>ein String, der nur im Namen der Datendatei eingesetzt wird</td></tr>
<tr><td><tt>%E</tt>     </td><td width=20><td>die Extension der geladenen Datei (ohne den <tt>'.'</tt>)</td></tr>
<tr><td><tt>%H</tt>     </td><td width=20><td>das <a href=#15>Home-Verzeichnis</a> des Benutzers</td></tr>
<tr><td><tt>%I{xxx}</tt></td><td width=20><td>ein String, der nur im Namen der Info-Datei eingesetzt wird</td></tr>
<tr><td><tt>%L</tt>     </td><td width=20><td>die Layer-Nummern f&uuml;r blind&amp;buried Vias (siehe unten)</td></tr>
<tr><td><tt>%N</tt>     </td><td width=20><td>der Name der geladenen Datei (ohne Pfad und Extension)</td></tr>
<tr><td><tt>%P</tt>     </td><td width=20><td>Verzeichnis-Pfad der geladenen Datei (ohne Dateinamen)</td></tr>
<tr><td><tt>%%</tt>     </td><td width=20><td>das Zeichen <tt>'%'</tt></td></tr>
</table>
<p>
Zum Beispiel w&uuml;rde die folgende Definition
<p>
<tt>%N.cmp%I{.info}</tt>
<p>
den Namen <tt><i>boardname</i>.cmp</tt> f&uuml;r die Datendatei und <tt><i>boardname</i>.cmp.info</tt>
f&uuml;r die Info-Datei ergeben (falls das gew&auml;hlte Device eine Info-Datei erzeugt).
<h2>Bohrdaten mit blind&amp;buried Vias</h2>
Falls das Board "blind" oder "buried" Vias enth&auml;lt,
generiert der CAM-Prozessor separate Bohrdateien f&uuml;r jeden tats&auml;chlich
im Board vorkommenden Via-&Uuml;bergang. Die Dateinamen werden gebildet indem
die Nummern des Start- und End-Layers an den Basisnamen angeh&auml;ngt werden,
wie zum Beispiel in
<pre>
<i>boardname</i>.drl.0104
</pre>
welches die Bohrdatei f&uuml;r das Lagenpaket 1-4 w&auml;re. Wenn Sie die Layer-Nummern
an anderer Stelle stehen haben wollen, so k&ouml;nnen Sie daf&uuml;r den Platzhalter
<tt>%L</tt> verwenden:
<pre>
%N.%L.drl
</pre>
erg&auml;be demnach
<pre>
<i>boardname</i>.0104.drl
</pre>
Der Name der Drill-Info-Datei wird immer ohne Layer-Nummern erzeugt und
ein eventueller '.' vor dem <tt>%L</tt> wird entfernt.
Dateien aus fr&uuml;heren CAM-Prozessor-Aufrufen, die dem gegebenen Pattern f&uuml;r
den Namen der Bohrdateien entsprechen w&uuml;rden, werden gel&ouml;scht bevor neue
Dateien erzeugt werden. Es gibt eine Drill-Info-Datei pro Job, die (unter
anderem) eine Liste aller generierten Bohrdateien enth&auml;lt.


<a name=134>
<h1>Flag-Options</h1>
<h2>Mirror</h2>
Ausgabe spiegeln. Achtung, dabei entstehen negative
Koordinaten, deshalb sollte gleichzeitig Funktion "pos. Coord."
eingeschaltet sein.
<h2>Rotate</h2>
Die Zeichnung wird um 90 Grad gedreht. Achtung, dabei
entstehen negative Koordinaten, deshalb sollte gleichzeitig die
Funktion "pos. Coord." eingeschaltet sein.
<h2>Upside down</h2>
Die Zeichnung wird um 180 Grad gedreht. Zusammen mit Rotate
wird die Zeichnung um insgesamt 270 Grad gedreht. Achtung, dabei
entstehen negative Koordinaten, deshalb sollte gleichzeitig Funktion
"pos. Coord." eingeschaltet sein.
<h2>Pos. Coord</h2>
Die Zeichnung wird so ausgegeben, dass keine negativen
Koordinaten vorkommen. Sie wird an die Koordinatenachsen
herangeschoben. Achtung: negative Koordinaten f&uuml;hren bei vielen
Peripherieger&auml;ten zu Fehlern!
<h2>Quickplot</h2>
Beschleunigte Ausgabe, bei der nur die Umrisse von Objekten
erscheinen.
<h2>Optimize</h2>
Mit dieser Option schalten Sie die Wegoptimierung f&uuml;r die
Plotterausgabe ein oder aus.
<h2>Fill pads</h2>
Pads f&uuml;llen. Diese Funktion ist nur mit Treiber des Typs "generic",
wie z. B. mit PostScript m&ouml;glich.<br>
Wird die Option deselektiert, sind die Bohrungen in Pads und
Vias sichtbar.


<a name=135>
<h1>Layer und Farben</h1>
W&auml;hlen Sie die auszugebenden Layer, indem Sie die Check-Boxes in
der Layer-Liste anklicken.
<p>
Bei Peripherieger&auml;ten, die unterschiedliche Farben unterst&uuml;tzen,
geben Sie die Farbnummer f&uuml;r den jeweiligen Layer an.
<p>
Folgende Layer-Kombinationen und
<a href=#133>Ausgabe-Dateinamen</a>
sind &uuml;blich:
<pre>
=======================================================
Datei- Selekt. Layer        Bedeutung
name
=======================================================
*.cmp  Top, Via, Pad        Bauteilseite
*.ly2  Route2, Via, Pad     Multilayer-Innenlage
*.ly3  Route3, Via, Pad     Multilayer-Innenlage,
...                         ...
*.sol  Bot, Via, Pad        L&ouml;tseite
*.plc  tPl, Dim, tName,     Best&uuml;ckungsplan Bauteilseite
*.pls  bPl, Dim, bName,     Best&uuml;ckungsplan L&ouml;tseite
*.stc  tStop                L&ouml;tstopmaske Bauteilseite
*.sts  bStop                L&ouml;tstopmaske L&ouml;tseite
*.drd  Drills, Holes        Bohrdaten f&uuml;r NC-Bohrmaschine
=======================================================
</pre>


<a name=136>
<h1>Konturdaten</h1>
EAGLE kann Konturdaten erzeugen, die beispielsweise zum Fr&auml;sen von Prototyp-Platinen
verwendet werden k&ouml;nnen.
<p>
Das User-Language-Programm <i>outlines.ulp</i> enth&auml;lt alle Schritte um diese
Daten zu erzeugen. Die folgende ausf&uuml;hrliche Beschreibung zeigt was zu tun ist, um
Konturdaten zu generieren.
<h2>Board vorbereiten</h2>
Zuerst definieren Sie ein <a href=#81>POLYGON</a> in dem Layer f&uuml;r den
die Konturdaten erzeugt werden sollen.
Das Polygon muss folgende Eigenschaften haben:
<ul>
<li>es muss den Namen _OUTLINES_ haben
<li>es muss das <b>einzige</b> Element mit dem Signalnamen _OUTLINES_ sein
<li>der Wert f&uuml;r <i>Rank</i> muss <tt>'6'</tt> sein
<li>der Wert f&uuml;r <i>Width</i> muss dem Durchmesser des Fr&auml;swerkzeugs entsprechen
<li>es muss gro&szlig; genug sein, um die ganze Board-Fl&auml;che zu bedecken
</ul>
Wenn sich ein solches Polygon in Ihrem Layout befindet, berechnet es der
<a href=#86>RATSNEST</a>-Befehl in der Weise, dass seine <i>Konturen</i>
genau den Linien entsprechen, die mit dem Fr&auml;swerkzeug gefahren werden m&uuml;ssen,
um die einzelnen Signale voneinander freizufr&auml;sen.
Die <i>F&uuml;llung</i> des berechneten Polygons bestimmt, was weggefr&auml;st werden muss, um
alle unn&ouml;tigen Kupferfl&auml;chen zu entfernen.
<h2>Ausgeben der Daten</h2>
Die Konturdaten k&ouml;nnen &uuml;ber ein <a href=#144>User Language Program</a>
aus dem Board extrahiert werden. Die Datei <i>outlines.ulp</i>, die mit EAGLE geliefert wird,
enth&auml;lt diesen Prozess vollst&auml;ndig. Wenn Sie ein eigenes ULP schreiben wollen,
verwenden Sie am besten <i>outlines.ulp</i> als Ausgangsbasis.
Sehen Sie die Hilfe-Seite zu <a href=#209>UL_POLYGON</a> f&uuml;r weitere Details
&uuml;ber das Erzeugen von Konturdaten mit Hilfe eines Polygons.
<h2>Durchmesser des Fr&auml;swerkzeugs</h2>
Der Durchmesser des Fr&auml;sers (und somit die Strichbreite <i>width</i> des Polygons)
muss so klein sein, dass es m&ouml;glich ist zwischen zwei unterschiedlichen Signalen
durchzukommen, um diese zu isolieren.
<b>
F&uuml;hren Sie in jedem Fall einen <a href=#48>Design Rule Check</a> (DRC) mit
den Werten f&uuml;r Mindestabst&auml;nde zwischen unterschiedlichen Signalen (<i>Clearance</i>) durch,
die dem Durchmesser des Fr&auml;swerkzeugs entsprechen!</b>
<p>
Werte ungleich 0 f&uuml;r den Isolate-Parameter k&ouml;nnen daf&uuml;r verwendet werden, beim
sequentiellen Arbeiten mit unterschiedlichen Fr&auml;serdurchmessern bereits gefr&auml;ste
Bereiche auszusparen.
<h2>Herstellen des urspr&uuml;nglichen Zustands im Board</h2>
Stellen Sie sicher, dass Sie nach dem Erzeugen der Konturdaten das Polygon mit
dem Namen _OUTLINES_ l&ouml;schen. Dieses spezielle Polygon verursacht ansonsten
Kurzschl&uuml;sse im Board, da es nicht den &uuml;blichen <a href=#139>Design Rules</a>
entspricht!


<a name=137>
<h1>Autorouter</h1>
Der integrierte Autorouter kann vom Board-Fenster aus mit dem Befehl
<a href=#34>AUTO</a> gestartet werden.
<p>
Der Autorouter wird auch als "Follow-me"-Router im
<a href=#94>ROUTE</a>-Befehl verwendet.
<p>
Bitte &uuml;berpr&uuml;fen Sie Ihre <a href=#376>Lizenz</a>, um
festzustellen, ob Sie Zugriff zum Autorouter haben.


<a name=138>
<h1>&Uuml;berpr&uuml;fen des Designs</h1>
EAGLE hat zwei Befehle zur &Uuml;berpr&uuml;fung Ihres Designs:
<ul>
<li>Electrical Rule Check (<a href=#50>ERC</a>)
<li>Design Rule Check (<a href=#48>DRC</a>)
</ul>
Der ERC wird in einem Schaltplan-Fenster ausgef&uuml;hrt. Er &uuml;berpr&uuml;ft das
Design auf elektrische Konsistenz.
<p>
Der DRC wird in einem Platinen-Fenster ausgef&uuml;hrt. Er &uuml;berpr&uuml;ft das
Design auf &Uuml;berlappung von unterschiedlichen Potentialen,
Abstandsverletzungen etc.


<a name=139>
<h1>Design Rules</h1>
<i>Design Rules</i> legen alle Parameter fest denen ein Platinen-Layout entsprechen muss.
<p>
Der <a href=#48>Design Rule Check</a> pr&uuml;ft das Board gegen&uuml;ber diesen Regeln
und meldet Verst&ouml;&szlig;e gegen sie.
<p>
Die Design Rules eines Boards k&ouml;nnen mit Hilfe des Design-Rule-Dialogs modifiziert werden.
Der Dialog &ouml;ffnet sich, wenn man den <a href=#48>DRC</a>-Befehl ohne
abschlie&szlig;endes <tt>';'</tt> aufruft.
<p>
Neu angelegte Boards &uuml;bernehmen ihre Design Rules aus der Datei 'default.dru',
die in dem ersten Verzeichnis, das im "Optionen/Verzeichnisse/Design-Regeln"-Pfad
aufgef&uuml;hrt ist, gesucht wird.
Ist keine solche Datei vorhanden, so gelten die programminternen Standardwerte.
<p>
<b>Hinweis</b> zu den Werten f&uuml;r <b>Clearance</b> und <b>Distance</b>:
Die Genauigkeit ist begrenzt durch die interne Aufl&ouml;sung der Koordinaten (1/320000mm).
<h2>Datei</h2>
Das <i>Datei</i>-Tab zeigt eine Beschreibung des aktuellen Satzes von Design Rules und erlaubt
&uuml;ber <i>Change</i> diese Beschreibung zu ver&auml;ndern (das ist empfehlenswert, wenn Sie eigene
Regeln definieren). &Uuml;ber <i>Load</i> kann man einen anderen Satz von Design Rules
aus einer Datei laden, <i>Save as..</i> speichert die aktuellen Einstellungen in eine
Datei.<br>
Bitte beachten Sie, dass die Design Rules immer in der Board-Datei gespeichert werden,
so dass diese Regeln auch f&uuml;r die Produktion der Platine bei Weitergabe der brd-Datei
an den Leiterplatten-Hersteller gelten. Die "Load..." und "Save as..." Buttons dienen
lediglich dazu die Design Rules einer Platine in eine externe Datei zu kopieren bzw.
sie von dort zu laden.
<p>
Falls die Design Rules ver&auml;ndert wurden, wird an den Namen in der Titelzeile
des Dialogs ein Stern (<tt>'*'</tt>) angeh&auml;ngt, um die Ver&auml;nderung anzuzeigen.
Diese Markierung verschwindet wieder, sobald die Design Rules explizit abgespeichert
werden, oder ein neuer Satz von Design Rules geladen wird.
<h2>Layers</h2>
Im <i>Layers</i>-Tab legt man fest welche Layer die Platine tats&auml;chlich verwendet,
wie dick die einzelnen Kupfer- bzw. Isolationslagen sind und welche Via-&Uuml;berg&auml;nge
m&ouml;glich sind (bitte beachten Sie, dass sich dies nur auf echte <i>Vias</i> bezieht;
selbst wenn kein Via von Layer 1 bis 16 im Layer-Setup definiert wurde sind <i>Pads</i>
dennoch erlaubt).
<p>
Das Layer-Setup wird durch den String im "Setup"-Feld definiert. Dieser String
besteht aus einer Sequenz von Layer-Nummern, getrennt durch jeweils ein <tt>'*'</tt>
oder <tt>'+'</tt>, wobei <tt>'*'</tt> f&uuml;r <i>Kern</i>-Material (auch als <i>FR4</i>
oder dergleichen bekannt) und <tt>'+'</tt> f&uuml;r <i>Prepreg</i> (oder sonstiges
Isolationsmaterial) steht. Die tats&auml;chliche <i>Kern</i>- und <i>Prepreg</i>-Sequenz
hat keine weitergehende Bedeutung f&uuml;r EAGLE, ausser der unterschiedlichen farblichen
Darstellung in der Anzeige oben links auf diesem Tab (das tats&auml;chliche Multilayer-Setup
muss auf jeden Fall mit dem Leiterplatten-Hersteller abgesprochen werden). Die Vias
werden dadurch definiert, dass eine Sequenz von Layern in <tt>(...)</tt> eingeschlossen
wird. Der Setup-String
<pre>
(1*16)
</pre>
w&uuml;rde demnach f&uuml;r eine zweilagige Platine bestehend aus den Layern 1 und 16 stehen,
mit ganz durchgehenden Vias (dies ist auch der Standardwert).<br>
F&uuml;r eine Multilayer-Platine k&ouml;nnte das Setup etwa so aussehen:
<pre>
((1*2)+(15*16))
</pre>
was eine vierlagige Platine darstellt deren Layer-Paare 1/2 und 15/16 auf Kern-Material
gefertigt und durchgebohrt werden, und schlie&szlig;lich mit Prepreg verpresst und am Ende
nochmals ganz durchgebohrt werden.<br>
Neben Vias die durch einen ganzen Lagenstapel gehen (gemeinhin als <i>buried</i> Vias bekannt
wenn sie keine Verbindung zum Top- und Bottom-Layer haben) gibt es auch solche, die
nicht ganz durch den Lagenstapel gebohrt werden, sondern an einem Layer im Inneren
des Stapels enden. Solche Vias werden <i>blind</i> Vias genannt und werden im "Setup"-String
dadurch festgelegt, dass eine Layer-Sequenz in <tt>[t:...:b]</tt> eingeschlossen wird,
wobei <i>t</i> und <i>b</i> die Layer bezeichnen bis zu denen das Via von der Ober-
bzw. Unterseite aus gesehen geht. Ein m&ouml;gliches Setup mit <i>blind</i> Vias k&ouml;nnte so
aussehen:
<pre>
[2:1+((2*3)+(14*15))+16:15]
</pre>
Dies ist im wesentlichen das vorherige Beispiel, erweitert um zwei zus&auml;tzliche
Aussenlagen, die mit den n&auml;chstinneren Lagen durch <i>blind</i> Vias verbunden sind.
Es ist auch m&ouml;glich nur einen der Parameter <i>t</i> bzw. <i>b</i> zu benutzen, so dass
<pre>
[2:1+((2*3)+(15*16))]
</pre>
ebenfalls ein g&uuml;ltiges Setup w&auml;re. <i>blind</i> Vias m&uuml;ssen nicht am Top oder Bottom
Layer beginnen, sondern k&ouml;nnen auch in innenliegenden Lagenstapeln verwendet werden, etwa in
<pre>
[2:1+[3:2+(3*4)+5:4]+16:5]
</pre>
Ein <i>blind</i> Via von Layer <i>a</i> nach Layer <i>b</i> implementiert auch alle
m&ouml;glichen <i>blind</i> Vias von Layer <i>a</i> nach allen Layern zwischen <i>a</i> und <i>b</i>,
so dass
<pre>
[3:1+2+(3*16)]
</pre>
<i>blind</i> Vias von Layer 1 nach 2 und von Layer 1 nach 3 erlauben w&uuml;rde.
<h2>Clearance</h2>
Im <i>Clearance</i>-Tab definiert man verschiedene Mindestabst&auml;nde zwischen
Objekten in den Signallayern. Das sind &uuml;blicherweise Mindestwerte, die vom
Fertigungsprozess beim Leiterplatten-Hersteller vorgegeben werden. Sprechen
Sie sich dazu mit dem Hersteller ab.<br>
Der aktuelle Mindestabstand zwischen Objekten, die zu unterschiedlichen Signalen
geh&ouml;ren, werden auch von den Werten der unterschiedlichen <a href=#39>Netzklassen</a> beeinflusst.
<p>
<p>
Bitte beachten Sie, dass ein Polygon mit dem besonderen Namen _OUTLINES_ dazu verwendet
wird <a href=#136>Kontur-Daten</a> zu erzeugen und dieses die Design Rules
<b>nicht</b> einh&auml;lt.
<h2>Distance</h2>
Im <i>Distance</i>-Tab legt man die Mindestabst&auml;nde zwischen Objekten in den Signallayern
und dem Platinenrand (Dimension) und zwischen Bohrungen (Holes) fest.
Achtung: Es werden nur Signale gegen&uuml;ber Dimension gepr&uuml;ft, die auch tats&auml;chlich
an mindestens einem Pad oder Smd angeschlossen sind. So ist es erlaubt, Eckwinkel
zur Markierung der Platinenbegrenzung in den Signallayern zu zeichnen ohne
dass der DRC Fehler meldet.
<p>
Aus Gr&uuml;nden der Kompatibilit&auml;t zu Version 3.5x gilt:
Wird der Parameter f&uuml;r den Mindestabstand zwischen Kupfer und Dimension auf <tt>0</tt>
gesetzt, so werden Objekte im Dimension-Layer beim Freirechnen der Polygone nicht
mehr ber&uuml;cksichtigt (ausgenommen Holes, die immer ber&uuml;cksichtigt werden). Es findet
dann auch keine Abstandspr&uuml;fung zwischen Kupfer und Dimension mehr statt.
<h2>Sizes</h2>
Unter <i>Sizes</i> legt man die Mindestbreite von Objekten in Signallayern und den
Mindestbohrdurchmesser fest. Diese Werte sind absolute Minimalma&szlig;e, die vom
Herstellungsprozess der Platine bestimmt werden. Sprechen Sie sich hierzu
mit dem Leiterplatten-Hersteller ab.<br>
Die Mindestbreite von Leiterbahnen und der Mindestbohrdurchmesser von Durchkontaktierungen
kann ausserdem f&uuml;r unterschiedliche Netzklassen festgelegt werden.
<h2>Restring</h2>
Im <i>Restring</i>-Tab definiert man die Mindestbreite des Kupferrings, die nach
dem Bohren eines Pads oder Vias um die Bohrung herum stehen bleibt. Die Werte
werden in Prozent des Bohrdurchmessers angegeben. Ausserdem kann ein Minimal- und
ein Maximalwert festgelegt werden. Die Restringbreiten f&uuml;r Pads k&ouml;nnen im Top-,
Bottom- und in den Innen-Layern unterschiedlich sein, w&auml;hrend bei Durchkontaktierungen
(Vias) nur zwischen Aussen- und Innenlagen unterschieden wird.<br>
Wenn f&uuml;r den tats&auml;chlichen Durchmesser eines Pads (in der Bibliothek festgelegt) oder
eines Vias ein gr&ouml;&szlig;erer Wert vorgegeben wird, wird dieser in den Aussenlagen verwendet.
Pads k&ouml;nnen beim Anlegen von Packages mit dem Durchmesser 0 gezeichnet werden, so
dass der Restring vollst&auml;ndig in Abh&auml;ngigkeit des Bohrdurchmessers berechnet werden
kann.
<h2>Shapes</h2>
Unter <i>Shapes</i> definiert man die Formen der Smds und Pads.<br>
Smds werden &uuml;blicherweise als Rechtecke (mit "Roundness" = 0) in der Bibliothek
definiert. Wenn Sie in Ihrem Design gerundete Smds verwenden wollen, kann man hier
einen Rundungsfaktor (Roundness) angeben.<br>
Pads werden normalerweise als Octagon (l&auml;ngliche Octagons wo sinnvoll)
in der Bibliothek festgelegt. In den Combo-Boxen k&ouml;nnen Sie festlegen,
ob die Pads im Layout so verwendet werden wie sie auch in der Bibliothek
definiert wurden, oder ob alle rechteckig, rund oder octagonal sein sollen.
Das kann man f&uuml;r Top- und Bottom-Layer separat definieren.<br>
Wird das "erste" Pad in der Bibliothek als solches markiert, kann man in der
dritten Combo-Box bestimmen, welche Form dieses Pad haben soll
(entweder rund, rechteckig, octagonal oder keine spezielle Form).<br>
Die Elongation-Parameter legen das Aussehen von Pads mit der Form Long bzw. Offset fest.
<h2>Supply</h2>
Unter <i>Supply</i> legt man die Thermal-Isolation zwischen Pads und Signalpolygonen
fest.
<h2>Masks</h2>
Im <i>Masks</i>-Tab legt man die Abmessungen von L&ouml;tstop- (solder stop) und
Lotpasten-Symbolen (cream mask) fest. Sie werden in Prozent der kleineren Seite
eines Smds, Pads oder Vias angegeben und werden durch einen Minimal- bzw.
Maximalwert begrenzt.<br>
Eine L&ouml;tstopmaske wird automatisch f&uuml;r Smds, Pads und solche Vias erzeugt, die den
angegebenen Wert f&uuml;r den Bohrdurchmesser im Parameter "Limit" &uuml;berschreiten.<br>
Die Lotpastenmaske (cream frame) wird nur f&uuml;r Smds ezeugt.
<h2>Misc</h2>
Unter <i>Misc</i> kann man die Pr&uuml;fung von Raster, Winkel, Schriftart und
Sperrfl&auml;chen aktivieren. Ausserdem k&ouml;nnen Sie festlegen, ob eine &Uuml;berpr&uuml;fung gemacht werden soll
wegen Texten, die nicht in Vektorschrift geschrieben sind (standardm&auml;&szlig;ig ein).
Es gibt auch eine Option zum &Uuml;berpr&uuml;fen von Kupfer in unzul&auml;ssigen Bereichen (Layer
tRestrict/bRestrict. Standard ist an).
<p>


<a name=140>
<h1>Querverweise</h1>
Es gibt mehrere M&ouml;glichkeiten, Querverweise in EAGLE Schaltpl&auml;nen zu
erzeugen, die in den folgenden Abschnitten beschrieben werden.
<ul>
<li><a href=#141>Querverweis-Labels</a>
<li><a href=#142>Bauteil-Querverweise</a>
<li><a href=#143>Kontaktspiegel</a>
</ul>


<a name=141>
<h1>Querverweis-Labels</h1>
Ein einfaches Label kann dazu benutzt werden, den Namen eines Netzes im Schaltplan
sichtbar zu machen. Wird bei einem Label die <i>xref</i>-Eigenschaft aktiviert,
so &auml;ndert sich sein Verhalten und es wird zum <i>Querverweis-Label</i>.
<p>
Querverweis-Labels werden typischerweise am rechten oder linken Rand einer
Schaltplanseite platziert und zeigen die n&auml;chste (bzw. vorherige) Seite an,
auf der ein bestimmtes Netz vorkommt. Eine genaue Beschreibung der
Funktionsweise finden Sie beim <a href=#62>LABEL</a>-Befehl.


<a name=142>
<h1>Bauteil-Querverweise</h1>
Elektro-Schaltpl&auml;ne enthalten oft elektromechanische Relais ("Sch&uuml;tze"), die
aus einem Spulensymbol und einem oder mehreren Kontaktsymbolen bestehen. Wenn Spule
und Kontakte auf unterschiedliche Schaltplanseiten verteilt sind, ist es n&uuml;tzlich,
wenn bei jedem Kontakt angegeben ist, auf welcher Seite seine Spule zu finden ist.
Dies kann dadurch erreicht werden, dass dem Spulengatter im Device-Set der Add-Level
<i>Must</i> gegeben wird (siehe <a href=#30>ADD</a>-Befehl) und der
Platzhaltertext <tt>'&gt;XREF'</tt> in den Kontaktsymbolen platziert wird
(siehe <a href=#104>TEXT</a>-Befehl).
<p>
Bei der sp&auml;teren Anzeige wird der <tt>'&gt;XREF'</tt>-Platzhaltertext (gem&auml;&szlig;
dem <a href=#97>Format f&uuml;r Bauteil-Querverweise</a>) durch die
Seitennummer und Zeichnungsrahmen-Koordinate des <i>Must</i>-Gatters dieses
Bauteils ersetzt.
<p>
Das Kapitel <a href=#143>Kontaktspiegel</a> erkl&auml;rt,
wie auf der Seite, die die Spule enth&auml;lt, ein Querverweis auf die Kontakte
dargestellt werden kann.


<a name=143>
<h1>Kontaktspiegel</h1>
In einem aus mehreren Seiten bestehenden Elektro-Schaltplan mit
elektro-mechanischen Relais, deren Spulen und Kontakte auf unterschiedliche
Seiten verteilt sind, ist es n&uuml;tzlich sehen zu k&ouml;nnen, auf welchen Seiten
sich die einzelnen Kontakte eines Relais befinden.
EAGLE kann einen solchen <i>Kontaktspiegel</i> automatisch anzeigen, wenn
folgende Voraussetzungen erf&uuml;llt sind.
<p>
Die Kontakt-Symbole m&uuml;ssen den Platzhaltertext <tt>'&gt;XREF'</tt> enthalten,
damit <a href=#142>Bauteil-Querverweise</a> erzeugt
werden.
<p>
Die Kontakt-Symbole sollten so gezeichnet werden, dass die Pins nach oben bzw.
unten zeigen, und dass der Ursprung in der Mitte des Symbols liegt.
<p>
Das erste Kontakt-Gatter in der Device-Set-Zeichnung sollte an der X-Koordinate
0 platziert werden, und seine Y-Koordinate sollte so gro&szlig; sein, dass sein unterer
Pin sich im positiven Bereich befindet, typischerweise bei 100mil. Die restlichen
Kontakt-Gatter sollten rechts davon platziert werden, mit ihrem Ursprung
an der gleichen Y-Koordinate wie das erste. Das Spulen-Gatter kann an einer
beliebigen Stelle platziert werden.
<p>
Im Schaltplan wird der Kontaktspiegel an der selben X-Koordinate dargestellt wie
die Spule, und direkt unterhalb der Y-Koordinate, die durch den Platzhaltertext
<tt>'&gt;CONTACT_XREF'</tt> definiert wird. Dieser Platzhaltertext kann entweder
in einem Zeichnungsrahmen-Symbol oder direkt auf der Schaltplanseite platziert
werden. Kommt er an beiden Stellen vor, so wird derjenige in der Schaltplanseite
genommen. Der Text selber ist auf der Schaltplanseite nicht sichtbar.
<p>
Die grafische Darstellung des Kontaktspiegels besteht aus allen Gattern, die einen
<tt>'&gt;XREF'</tt> Platzhaltertext haben (ausgenommen das erste <i>Must</i>-Gatter,
welches die Spule ist und normalerweise keinen solchen Text hat). Die Gatter werden
um 90 Grad gedreht und von oben nach unten in dem gleichen Abstand dargestellt,
den sie im Device-Set von links nach rechts haben. Ihre Seitennummern und
Zeichnungsrahmen-Koordinaten werden rechts neben jedem verwendeten Gatter angezeigt.
Jegliche anderen Texte, die in den Symbolen definiert wurden, werden nicht
dargestellt, wenn die Symbole zur Anzeige des Kontaktspiegels verwendet werden.
<p>
Beachten Sie bitte, dass der Kontaktspiegel nicht mit der Maus selektiert werden kann.
Falls Sie ihn verschieben wollen, so bewegen Sie die Spule und der Kontaktspiegel
folgt ihr automatisch.
Es kann vorkommen, dass der Kontaktspiegel nach dem Einf&uuml;gen, Verschieben, L&ouml;schen
oder Vertauschen von Kontakt-Gattern, bzw. einer Ver&auml;nderung des <tt>'&gt;CONTACT_XREF'</tt>
Platzhaltertexts, nicht mehr aktuell ist. Ein neuer Bildaufbau aktualisiert ihn wieder.


<a name=144>
<h1>User Language</h1>
Die EAGLE-User-Language gestattet den Zugriff auf die EAGLE-Datenstrukturen
und kann beliebige Ausgabedateien erzeugen.
<p>
Um diese Eigenschaft zu Nutzen, m&uuml;ssen Sie ein
<a href=#145>User-Language-Programm (ULP) schreiben</a>
und anschlie&szlig;end <a href=#146>ausf&uuml;hren</a>.
<p>
Die folgenden Abschnitte beschreiben die User Language im Detail:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#147>Syntax</a>             </td><td width=20><td>Syntax-Regeln</td></tr>
<tr><td><a href=#170>Daten-Typen</a>         </td><td width=20><td>Definiert die grundlegenden Datentypen (Data types)</td></tr>
<tr><td><a href=#177>Objekt-Typen</a>       </td><td width=20><td>Definiert die EAGLE-Objekte (Objects)</td></tr>
<tr><td><a href=#224>Definitionen</a>        </td><td width=20><td>Zeigt, wie man eine Definition schreibt</td></tr>
<tr><td><a href=#228>Operatoren</a>          </td><td width=20><td>Liste der g&uuml;ltigen Operatoren (Operators)</td></tr>
<tr><td><a href=#235>Ausdr&uuml;cke</a>        </td><td width=20><td>Zeigt, wie man einen Ausdruck (Expression) schreibt</td></tr>
<tr><td><a href=#242>Statements</a>         </td><td width=20><td>Definiert die g&uuml;ltigen Statements</td></tr>
<tr><td><a href=#254>Builtins</a> </td><td width=20><td>Liste der Builtin-Constants, -Functions etc.</td></tr>
<tr><td><a href=#332>Dialoge</a> </td><td width=20><td>zeigt wie man grafische Dialoge in ein ULP integriert</td></tr>
</table>


<a name=145>
<h1>Schreiben eines ULP</h1>
Ein User-Language-Programm ist eine reine Textdatei und wird in einer C-&auml;hnlichen
<a href=#147>Syntax</a> geschrieben.
User-Language-Programme
verwenden die Extension <tt>.ulp</tt>. Sie k&ouml;nnen ein ULP mit jedem beliebigen Text-Editor schreiben,
vorausgesetzt, er f&uuml;gt keine Steuerzeichen ein, oder Sie k&ouml;nnen den
<a href=#27>EAGLE-Text-Editor</a> verwenden.
<p>
Ein User-Language-Programm besteht aus zwei wesentlichen Bestandteilen:
<a href=#224>Definitionen</a> und
<a href=#242>Statements</a>.
<p>
<a href=#224>Definitionen</a> werden verwendet, um Konstanten,
Variablen und Funktionen zu definieren, die wiederum in
<a href=#242>Statements</a> verwendet werden.
<p>
Ein einfaches ULP k&ouml;nnte so aussehen:
<pre>
#usage "Add the characters in the word 'Hello'\n"
       "Usage: RUN sample.ulp"
// Definitions:
string hello = "Hello";
int count(string s)
{
  int c = 0;
  for (int i = 0; s[i]; ++i)
      c += s[i];
  return c;
}
// Statements:
output("sample") {
  printf("Count is: %d\n", count(hello));
  }
</pre>
Der Wert der <tt><a href=#153>#usage</a></tt>-Directive zeigt im
<a href=#13>Control Panel</a> die Beschreibung des Programms an.
<p>
Soll das Ergebnis des ULPs ein Befehl sein, der im Editor-Fenster ausgef&uuml;hrt
werden soll, kann man die Funktion <tt><a href=#276>exit()</a></tt>
verwenden um den Befehl an das Editor-Fenster zu schicken.


<a name=146>
<h1>ULP ausf&uuml;hren</h1>
User-Language-Programme werden mit Hilfe des
<a href=#95>RUN</a>-Befehls von der Kommandozeile eines
Editor-Fensters aus ausgef&uuml;hrt.
<p>
Ein ULP kann die Information zur&uuml;ckgeben, ob es erfolgreich abgeschlossen
wurde oder nicht. Sie k&ouml;nnen die
<tt><a href=#276>exit()</a></tt>-Funktion verwenden, um das Programm
zu beenden und den R&uuml;ckgabewert (return value) zu setzen.
<p>
Ein "return value" von <tt>0</tt> bedeutet, das ULP wurde normal beendet
(erfolgreich), w&auml;hrend jeder andere Wert einen unnormalen Programmabbruch
anzeigt.
<p>
Der Default-R&uuml;ckgabewert jedes ULP ist <tt>0</tt>.
<p>
Wird der <a href=#95>RUN</a>-Befehl als Teil einer
<a href=#96>Script-Datei</a>, ausgef&uuml;hrt, dann wird die Script-Datei
abgebrochen, wenn das ULP mit einem "return value" ungleich <tt>0</tt> beendet
wurde.
<p>
Eine spezielle Variante der Funktion <tt><a href=#276>exit()</a></tt> kann
verwendet werden, um einen Befehl als Ergebnis des ULPs an ein Editor-Fenster zu schicken.


<a name=147>
<h1>Syntax</h1>
Die Grundbausteine eines User-Language-Programms sind:
<ul>
<li><a href=#148>Whitespace</a>
<li><a href=#149>Kommentare</a>
<li><a href=#150>Direktiven</a>
<li><a href=#154>Schl&uuml;sselw&ouml;rter (Keywords)</a>
<li><a href=#155>Identifier</a>
<li><a href=#156>Konstanten</a>
<li><a href=#162>Punctuator-Zeichen</a>
</ul>
Alle unterliegen bestimmten Regeln, die in den entsprechenden Abschnitten
beschrieben werden.


<a name=148>
<h1>Whitespace</h1>
Bevor ein User-Language-Programm ausgef&uuml;hrt werden kann, muss es von einer
Datei eingelesen werden. W&auml;hrend dieses Vorgangs wird er Inhalt der Datei
zerlegt (<i>parsed</i>) in Tokens und in <i>Whitespace</i>.
<p>
Leerzeichen (blanks), Tabulatoren, Newline-Zeichen und
<a href=#149>Kommentar</a> werden als <i>Whitespace</i>
behandelt und nicht ber&uuml;cksichtigt.
<p>
Die einzige Stelle, an der ASCII-Zeichen, die <i>Whitespace</i>
repr&auml;sentieren, ber&uuml;cksichtigt werden, ist innerhalb von
<a href=#156>Literal Strings</a>,
wie in
<pre>
string s = "Hello World";
</pre>
wo das Leerzeichen zwischen <tt>'o'</tt> und <tt>'W'</tt> ein Teil des Strings bleibt.
<p>
Wenn dem abschlie&szlig;enden Newline-Zeichen einer Zeile ein Backslash
(<tt>\</tt>), vorausgeht, werden Backslash und Newline nicht ber&uuml;cksichtigt.
<pre>
"Hello \
World"
</pre>
wird als <tt>"Hello World"</tt> interpretiert.


<a name=149>
<h1>Kommentare</h1>
Wenn man ein ULP schreibt, sollte man m&ouml;glichst erkl&auml;renden Text
hinzuf&uuml;gen, der einen Eindruck davon vermittelt, was dieses Programm
tut. Sie k&ouml;nnen auch Ihren Namen und, falls verf&uuml;gbar, Ihre Email-Adresse
hinzuf&uuml;gen, damit die Anwender Ihres Programms die M&ouml;glichkeit haben,
mit Ihnen Kontakt aufzunehmen, wenn Sie Probleme oder
Verbesserungsvorschl&auml;ge haben.
<p>
Es gibt zwei M&ouml;glichkeiten, Kommentare einzuf&uuml;gen. Die erste verwendet
die Syntax
<pre>
/* some comment text */
</pre>
bei der alle Zeichen zwischen (und einschlie&szlig;lich) den Zeichen
<tt>/*</tt> und <tt>*/</tt> als Kommentar interpretiert wird.
Solche Kommentare k&ouml;nnen &uuml;ber mehrere Zeilen gehen, wie in
<pre>
/* This is a
   multi line comment
*/
</pre>
aber sie lassen sich nicht verschachteln. Das erste <tt>*/</tt> das einem <tt>/*</tt>
folgt, beendet den Kommentar.
<p>
Die zweite M&ouml;glichkeit, einen Kommentar einzuf&uuml;gen, verwendet die Syntax
<pre>
int i; // some comment text
</pre>
Dabei werden alle Zeichen nach (und einschlie&szlig;lich) dem <tt>//</tt>
bis zum Newline-Zeichen (aber nicht einschlie&szlig;lich) am Ende der Zeile
als Kommentar interpretiert.


<a name=150>
<h1>Direktiven</h1>
Folgende <i>Direktiven</i> sind verf&uuml;gbar:
<pre>
<a href=#151>#include</a>
<a href=#152>#require</a>
<a href=#153>#usage</a>
</pre>


<a name=151>
<h1>#include</h1>
Ein ULP kann Befehle aus einem anderen ULP durch die <tt>#include</tt>-Direktive
ausf&uuml;hren. Die Syntax lautet
<pre>
#include "<i>filename</i>"
</pre>
Die Datei <tt>filename</tt> wird zuerst im selben Verzeichnis in dem sich auch die
Source-Datei (das ist die Datei mit der <tt>#include</tt>-Directive) befindet, gesucht.
Wird sie dort nicht gefunden, wird in den angegebenen ULP-Verzeichnissen gesucht.
<p>
Die maximale "include-Tiefe" ist 10.
<p>
Jede <tt>#include</tt>-Direktive wird nur <b>einmal</b> ausgef&uuml;hrt. So wird
sichergestellt, dass keine Mehrfachdefinitionen von Variablen oder Funktionen entstehen,
die Fehler verursachen k&ouml;nnten.
<h2>Hinweis zur Kompatibilit&auml;t zwischen den Betriebssystemen</h2>
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
Enth&auml;lt <i>filename</i> eine Pfadangabe, ist es das Beste als Trennzeichen immer den
<b>Forward-Slash</b> (/)zu verwenden (auch unter Windows!). Laufwerksbuchstaben unter
Windows sollten vermieden werden. Wird das ber&uuml;cksichtigt, l&auml;uft das ULP unter
allen Betriebssystemen.
</td></tr></table>


<a name=152>
<h1>#require</h1>
Mit der Zeit kann es vorkommen, dass neuere EAGLE-Versionen neue oder ver&auml;nderte
User Language Funktionen implementieren, die Fehlermeldungen verursachen k&ouml;nnen,
wenn ein solches ULP aus einer &auml;lteren EAGLE-Version heraus aufgerufen wird.
Um dem Benutzer eine konkrete Meldung zu geben, dass dieses ULP mindestens eine
bestimmte EAGLE-Version ben&ouml;tigt, kann ein ULP die <tt>#require</tt>-Direktive
enthalten. Die Syntax lautet
<pre>
#require <i>version</i>
</pre>
Die <i>version</i> muss als <a href=#159>Real-Konstante</a>
der Form
<pre>
V.RRrr
</pre>
angegeben werden, wobei <tt>V</tt> die Versionsnummer ist, <tt>RR</tt> die Release-Nummer
und <tt>rr</tt> die (optionale) Revisions-Nummer (beide mit f&uuml;hrenden Nullen
aufgef&uuml;llt, falls sie kleiner als 10 sind). Falls also zum Beispiel ein ULP
mindestens die EAGLE-Version 4.11r06 voraussetzt (welches die Betaversion war die
als erste die <tt>#require</tt>-Direktive implementierte), k&ouml;nnte es
<pre>
#require 4.1106
</pre>
benutzen. Entsprechend w&uuml;rde f&uuml;r Version 5.1.2
<pre>
#require 5.0102
</pre>
gelten.


<a name=153>
<h1>#usage</h1>
Jedes User-Language-Programm sollte Informationen &uuml;ber seine Funktion, die Benutzung und
evtl. auch &uuml;ber den Autor enthalten.<br>
Die Direktive
<pre>
#usage <i>text</i> [, <i>text</i>...]
</pre>
ist die &uuml;bliche Methode diese Information verf&uuml;gbar zu machen.
<p>
Wird die <tt>#usage</tt>-Direktive verwendet,
wird ihr <tt>Text</tt> (der eine <a href=#160>String-Konstante</a> sein muss)
im <a href=#13>Control Panel</a> verwendet, um die Beschreibung des Programms anzuzeigen.
<p>
F&uuml;r den Fall, dass das ULP diese Information z. B. in einer
<a href=#336>dlgMessageBox()</a> ben&ouml;tigt, ist dieser <tt>Text</tt> durch die
<a href=#255>Builtin-Konstante</a> <tt>usage</tt> im ULP verf&uuml;gbar.
<p>
Es wird nur die <tt>#usage</tt>-Direktive des Hauptprogramms (das ist die Datei, die mit
dem <a href=#95>RUN</a>-Befehl gestartet wurde) ber&uuml;cksichtigt.
Deshalb sollten reine <a href=#151>include</a>-Dateien auch eine
eigene <tt>#usage</tt>-Directive enthalten.
<p>
Am besten ist die <tt>#usage</tt>-Direktive an den Anfang der Datei zu stellen,
so muss das Control Panel nicht den ganzen Text der Datei durchsuchen,
um die Informationen, die angezeigt werden sollen, zu finden.
<p>
Soll die Usage-Information in mehreren Sprachen verf&uuml;gbar gemacht werden, so
sind die Texte der verschiedenen Sprachen durch Kommas getrennt anzugeben.
Dabei muss jeder Text mit dem zweibuchstabigen Code der jeweiligen Sprache
(so wie er auch von der <a href=#278>language()</a>-Funktion geliefert wird),
gefolgt von einem Doppelpunkt und beliebig vielen Leerzeichen beginnen.
Falls f&uuml;r die auf dem aktuellen System verwendete Sprache kein passender
Text gefunden wird, so wird der erste angegebene Text verwendet (dieser
sollte generell Englisch sein um das Programm einer m&ouml;glichst gro&szlig;en Zahl
von Benutzern zug&auml;nglich zu machen).
<h2>Beispiel</h2>
<pre>
#usage "en: A sample ULP\n"
           "Implements an example that shows how to use the EAGLE User Language\n"
           "Usage: RUN sample.ulp\n"
           "Author: john@home.org",
       "de: Beispiel eines ULPs\n"
           "Implementiert ein Beispiel das zeigt, wie man die EAGLE User Language benutzt\n"
           "Aufruf: RUN sample.ulp\n"
           "Autor: john@home.org"
</pre>


<a name=154>
<h1>Schl&uuml;sselw&ouml;rter (Keywords)</h1>
Die folgenden <i>Schl&uuml;sselw&ouml;rter</i> sind f&uuml;r spezielle Zwecke reserviert
und d&uuml;rfen nicht als normale Identifier-Namen verwendet werden:
<pre>
<a href=#246>break</a>
<a href=#252>case</a>
<a href=#171>char</a>
<a href=#247>continue</a>
<a href=#252>default</a>
<a href=#248>do</a>
<a href=#250>else</a>
<a href=#225>enum</a>
<a href=#249>for</a>
<a href=#250>if</a>
<a href=#172>int</a>
<a href=#226>numeric</a>
<a href=#173>real</a>
<a href=#251>return</a>
<a href=#174>string</a>
<a href=#252>switch</a>
<a href=#170>void</a>
<a href=#253>while</a>
</pre>
Zus&auml;tzlich sind die Namen von
<a href=#254>Builtins</a> und
<a href=#177>Objekt-Typen</a>
reserviert und d&uuml;rfen nicht als Identifier-Namen verwendet werden.


<a name=155>
<h1>Identifier</h1>
Ein <i>Identifier</i> ist ein Name, der dazu benutzt wird, eine benutzerdefinierte
<a href=#225>Konstante</a>,
<a href=#226>Variable</a> oder
<a href=#227>Funktion</a>
einzuf&uuml;hren.
<p>
Identifier bestehen aus einer Sequenz von Buchstaben (<tt>a b c</tt>..., <tt>A B C</tt>...),
Ziffern (<tt>1 2 3</tt>...) und Unterstreichungszeichen (<tt>_</tt>). Das erste Zeichen
eines Identifiers <b>muss</b> ein Buchstabe oder ein Unterstreichungszeichen sein.
<p>
Identifier sind case-sensitive, das bedeutet, dass
<pre>
int Number, number;
</pre>
zwei unterschiedliche Integer-Variablen definieren w&uuml;rde.
<p>
Die maximale L&auml;nge eines Identifiers ist 100 Zeichen, von denen alle signifikant sind.


<a name=156>
<h1>Konstanten</h1>
Konstanten sind gleichbleibende Daten, die in ein User-Language-Programm
geschrieben werden. Analog zu den verschiedenen
<a href=#170>Datentypen</a>
gibt es auch unterschiedliche Typen von Konstanten.
<ul>
<li><a href=#157>Character-Konstanten</a>
<li><a href=#158>Integer-Konstanten</a>
<li><a href=#159>Real-Konstanten</a>
<li><a href=#160>String-Konstanten</a>
</ul>


<a name=157>
<h1>Character-Konstanten</h1>
Eine <i>Character-Konstante</i> besteht aus einem einzelnen Buchstaben
oder einer
<a href=#161>Escape-Sequenz</a>, eingeschlossen in
einfachen Hochkommas, wie in
<pre>
'a'
'='
'\n'
</pre>
Der Typ der Character-Konstante ist
<tt><a href=#171>char</a></tt>.


<a name=158>
<h1>Integer-Konstanten</h1>
Abh&auml;ngig vom ersten (eventuell auch vom zweiten) Zeichen wird eine
<i>Integer-Konstante</i> unterschiedlich interpretiert:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>erstes</td>       <td width=20><td>zweites</td>      <td width=20><td>Konstante interpretiert als</td></tr>
<tr><td><tt>0</tt></td>   <td width=20><td><tt>1-7</tt></td> <td width=20><td>oktal (Basis 8)</td></tr>
<tr><td><tt>0</tt></td>   <td width=20><td><tt>x,X</tt></td> <td width=20><td>hexadezimal (Basis 16)</td></tr>
<tr><td><tt>1-9</tt></td> <td width=20><td>            </td> <td width=20><td>dezimal (Basis 10)</td></tr>
</table>
<p>
Der Typ einer Integer-Konstante ist
<tt><a href=#172>int</a></tt>.
<h2>Beispiele</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>16</tt>      </td><td width=20><td>dezimal</td></tr>
<tr><td><tt>020</tt>     </td><td width=20><td>oktal</td></tr>
<tr><td><tt>0x10</tt>    </td><td width=20><td>hexadezimal</td></tr>
</table>


<a name=159>
<h1>Real-Konstanten</h1>
Eine <i>Real-Konstante</i> folgt dem allgemeinen Muster
<pre>
[-]<i>int</i>.<i>frac</i>[e|E[&plusmn;]<i>exp</i>]
</pre>
wobei die einzelnen Teile f&uuml;r
<ul>
<li>Vorzeichen (optional)
<li>Dezimal-Integer
<li>Dezimalpunkt
<li>Dezimalbruch
<li><tt>e</tt> oder <tt>E</tt> und ein Integer-Exponent mit Vorzeichen
</ul>
stehen.
<p>
Sie k&ouml;nnen entweder Dezimal-Integer-Zahl oder Dezimalbruch weglassen
(aber nicht beides). Sie k&ouml;nnen entweder den Dezimalpunkt oder
den Buchstaben <tt>e</tt> oder <tt>E</tt> und den Integer-Exponenten mit
Vorzeichen weglassen (aber nicht beides).
<p>
Der Typ einer Real-Konstante ist
<tt><a href=#173>real</a></tt>.
<h2>Beispiele</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Konstante  </td><td width=20><td>Wert</td></tr>
<tr><td><tt>23.45e6</tt>    </td><td width=20><td>23.45 x 10^6</td></tr>
<tr><td><tt>.0</tt>         </td><td width=20><td>0.0</td></tr>
<tr><td><tt>0.</tt>         </td><td width=20><td>0.0</td></tr>
<tr><td><tt>1.</tt>         </td><td width=20><td>1.0</td></tr>
<tr><td><tt>-1.23</tt>      </td><td width=20><td>-1.23</td></tr>
<tr><td><tt>2e-5</tt>       </td><td width=20><td>2.0 x 10^-5</td></tr>
<tr><td><tt>3E+10</tt>      </td><td width=20><td>3.0 x 10^10</td></tr>
<tr><td><tt>.09E34</tt>     </td><td width=20><td>0.09 x 10^34</td></tr>
</table>


<a name=160>
<h1>String-Konstanten</h1>
Eine <i>String-Konstante</i> besteht aus einer Sequenz von Buchstaben
oder einer <a href=#161>Escape-Sequenz</a>,
eingeschlossen in doppelte Anf&uuml;hrungszeichen, wie in
<pre>
"Hello world\n"
</pre>
Der Typ einer String-Konstante ist
<tt><a href=#174>string</a></tt>.
<p>
String-Konstanten k&ouml;nnen jede beliebige L&auml;nge haben, vorausgesetzt
es steht gen&uuml;gend Speicher zur Verf&uuml;gung.
<p>
String-Konstanten k&ouml;nnen einfach aneinandergereiht werden
um l&auml;ngere Strings zu bilden:
<pre>
string s = "Hello" " world\n";
</pre>
Es ist auch m&ouml;glich, eine String-Konstante &uuml;ber mehrere Zeilen zu schreiben,
indem man das Newline-Zeichen mit Hilfe des Backslash (<tt>\</tt>) "ausblendet":
<pre>
string s = "Hello \
world\n";
</pre>


<a name=161>
<h1>Escape-Sequenzen</h1>
Eine <i>Escape-Sequenz</i> besteht aus einem Backslash (<tt>\</tt>),
gefolgt von einem oder mehreren Sonderzeichen:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Sequenz    </td><td width=20><td>Bedeutung</td></tr>
<tr><td><tt>\a</tt>  </td><td width=20><td>audible bell</td></tr>
<tr><td><tt>\b</tt>  </td><td width=20><td>backspace</td></tr>
<tr><td><tt>\f</tt>  </td><td width=20><td>form feed</td></tr>
<tr><td><tt>\n</tt>  </td><td width=20><td>new line</td></tr>
<tr><td><tt>\r</tt>  </td><td width=20><td>carriage return</td></tr>
<tr><td><tt>\t</tt>  </td><td width=20><td>horizontal tab</td></tr>
<tr><td><tt>\v</tt>  </td><td width=20><td>vertical tab</td></tr>
<tr><td><tt>\\</tt>  </td><td width=20><td>backslash</td></tr>
<tr><td><tt>\'</tt>  </td><td width=20><td>single quote</td></tr>
<tr><td><tt>\"</tt>  </td><td width=20><td>double quote</td></tr>
<tr><td><tt>\O</tt>  </td><td width=20><td><tt>O</tt> = bis 3 octal digits</td></tr>
<tr><td><tt>\xH</tt> </td><td width=20><td><tt>H</tt> = bis 2 hex digits</td></tr>
</table>
<p>
Jedes Zeichen nach dem Backslash, das nicht in der Liste aufgef&uuml;hrt ist,
wird als dieses Zeichen (ohne Backslash) behandelt.
<p>
Escape-Sequenzen k&ouml;nnen in
<a href=#157>Character-Konstanten</a> und
<a href=#160>String-Konstanten</a> verwendet werden.
<h2>Beispiele</h2>
<pre>
'\n'
"A tab\tinside a text\n"
"Ring the bell\a\n"
</pre>


<a name=162>
<h1>Punctuator-Zeichen</h1>
Die <i>Punctuator-Zeichen</i>, die in einem User-Language-Programm
benutzt werden k&ouml;nnen, sind
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>[]</tt>  </td><td width=20><td><a href=#163>Eckige Klammern (Brackets)</a></td></tr>
<tr><td><tt>()</tt>  </td><td width=20><td><a href=#164>Runde Klammern (Parentheses)</a></td></tr>
<tr><td><tt>{}</tt>  </td><td width=20><td><a href=#165>Geschweifte Klammern (Braces)</a></td></tr>
<tr><td><tt>,</tt>   </td><td width=20><td><a href=#166>Komma</a></td></tr>
<tr><td><tt>;</tt>   </td><td width=20><td><a href=#167>Semikolon</a></td></tr>
<tr><td><tt>:</tt>   </td><td width=20><td><a href=#168>Doppelpunkt (Colon)</a></td></tr>
<tr><td><tt>=</tt>   </td><td width=20><td><a href=#169>Gleichheitszeichen</a></td></tr>
</table>
<p>
Andere Sonderzeichen werden als
<a href=#228>Operatoren</a>
verwendet.


<a name=163>
<h1>Eckige Klammern</h1>
Eckige Klammern (<i>Brackets</i>) werden verwendet in Array-Definitionen:
<pre>
int ai[];
</pre>
in Array-Subscripts
<pre>
n = ai[2];
</pre>
und in String-Subscripts, um auf die einzelnen Zeichen eines Strings
zuzugreifen
<pre>
string s = "Hello world";
char c = s[2];
</pre>


<a name=164>
<h1>Runde Klammern</h1>
Runde Klammern (<i>Parentheses</i>) gruppieren
<a href=#235>Ausdr&uuml;cke</a>
(&auml;ndern eventuell die Priorit&auml;t der <a href=#228>Operatoren</a>),
isolieren bedingte Ausdr&uuml;cke und bezeichnen
<a href=#241>Funktionsaufrufe</a> und Funktionsparameter:
<pre>
d = c * (a + b);
if (d == z) ++x;
func();
void func2(int n) { ... }
</pre>


<a name=165>
<h1>Geschweifte Klammern</h1>
Geschweifte Klammern (<i>Braces</i>) bezeichnen den Beginn und das Ende
einer Verbundanweisung (<i>Compound Statement</i>)
<pre>
if (d == z) {
   ++x;
   func();
   }
</pre>
und werden auch verwendet, um die Werte f&uuml;r die Array-Initialisierung zu
gruppieren:
<pre>
int ai[] = { 1, 2, 3 };
</pre>


<a name=166>
<h1>Komma</h1>
Das <i>Komma</i> trennt die Elemente einer Funktionsargument-Liste
oder die Parameter eines Funktionsaufrufs:
<pre>
int func(int n, real r, string s) { ... }
int i = func(1, 3.14, "abc");
</pre>
Es trennt auch die Wertangaben bei der Array-Initialisierung:
<pre>
int ai[] = { 1, 2, 3 };
</pre>
und es begrenzt die Elemente einer Variablen-Definition:
<pre>
int i, j, k;
</pre>


<a name=167>
<h1>Semikolon</h1>
Der <i>Semikolon</i> schlie&szlig;t ein <a href=#242>Statement</a>
ab, wie in
<pre>
i = a + b;
</pre>
und er begrenzt die Init-, Test- und Inkrement-Ausdr&uuml;cke eines
<a href=#249>for</a> Statements:
<pre>
for (int n = 0; n &lt; 3; ++n) {
    func(n);
    }
</pre>


<a name=168>
<h1>Doppelpunkt</h1>
Der <i>Doppelpunkt</i> bezeichnet das Ende eines Labels in einem
<a href=#252>Switch</a>-Statement:
<pre>
switch (c) {
  case 'a': printf("It was an 'a'\n"); break;
  case 'b': printf("It was a  'b'\n"); break;
  default:  printf("none of them\n");
  }
</pre>


<a name=169>
<h1>Gleichheitszeichen</h1>
Das <i>Gleichheitszeichen</i> trennt Variablen-Definitionen von
Initialisierungsliste:
<pre>
int i = 10;
char c[] = { 'a', 'b', 'c' };
</pre>
Es wird auch als
<a href=#233>Zuweisungsoperator</a> verwendet.


<a name=170>
<h1>Datentypen</h1>
Ein User-Language-Programm kann Variablen unterschiedlicher Typen definieren,
die unterschiedliche Arten von EAGLE-Daten repr&auml;sentieren.
<p>
Die vier grundlegenden Datentypen sind
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt><a href=#171>char</a></tt>  </td><td width=20><td>f&uuml;r Einzelzeichen</td></tr>
<tr><td><tt><a href=#172>int</a></tt>  </td><td width=20><td>f&uuml;r Ganzzahlen</td></tr>
<tr><td><tt><a href=#173>real</a></tt>  </td><td width=20><td>f&uuml;r Gleitkommazahlen</td></tr>
<tr><td><tt><a href=#174>string</a></tt>  </td><td width=20><td>f&uuml;r Textinformation</td></tr>
</table>
<p>
Neben diesen grundlegenden Datentypen gibt es auch
High-level-<a href=#177>Objekt-Typen</a>,
die die Datenstrukturen repr&auml;sentieren, wie sie in den EAGLE-Dateien
gespeichert sind.
<p>
Der Datentyp <tt>void</tt> wird nur als Return-Typ einer
<a href=#227>Funktion</a> verwendet. Er zeigt
an, dass diese Funktion keinen Wert zur&uuml;ckgibt.


<a name=171>
<h1>char</h1>
Der Datentyp <tt>char</tt> speichert Einzelzeichen, wie die Buchstaben des
Alphabets oder kleine Zahlen ohne Vorzeichen.
<p>
Eine Variable des Typs <tt>char</tt> belegt 8 bit (1 Byte), und kann jeden Wert
im Bereich <tt>0..255</tt> speichern.
<p>
<b>Siehe auch</b> <a href=#228>Operatoren</a>,
<a href=#157>Character-Konstanten</a>


<a name=172>
<h1>int</h1>
Der Datentyp <tt>int</tt> speichert Ganzzahlen mit Vorzeichen, wie die Koordinaten
eines Objekts.
<p>
Eine Variable vom Typ <tt>int</tt> belegt 32 bit (4 Byte), und kann
jeden Wert im Bereich <tt>-2147483648..2147483647</tt> speichern.
<p>
<b>Siehe auch</b> <a href=#158>Integer-Konstanten</a>


<a name=173>
<h1>real</h1>
Der Datentyp <tt>real</tt> speichert Gleitkommazahlen mit Vorzeichen, z.B.
den Rasterabstand.
<p>
Eine Variable vom Typ <tt>real</tt> belegt 64 bit (8 Byte), und kann jeden Wert
im Bereich <tt>&plusmn;2.2e-308..&plusmn;1.7e+308</tt> mit einer Genauigkeit von 15 Digits
speichern.
<p>
<b>Siehe auch</b> <a href=#159>Real-Konstanten</a>


<a name=174>
<h1>string</h1>
Der Datentyp <tt>string</tt> speichert Textinformation, z.B. den Namen eines Bauteils
oder eines Netzes.
<p>
Eine Variable des Typs <tt>string</tt> ist nicht auf eine bestimmte L&auml;nge beschr&auml;nkt,
vorausgesetzt, es steht gen&uuml;gend Speicher zur Verf&uuml;gung.
<p>
Variablen des Typs <tt>string</tt> sind ohne explizite L&auml;nge definiert. Sie
"wachsen" automatisch, soweit erforderlich, w&auml;hrend der Programmausf&uuml;hrung.
<p>
Die Elemente einer <tt>String</tt>-Variablen sind vom Typ
<tt><a href=#172>int</a></tt>, und
man kann auf sie individuell zugreifen, indem man
<tt>[index]</tt> benutzt.
<p>
Das erste Zeichen eines <tt>Strings</tt> hat den Index <tt>0</tt>:
<pre>
string s = "Layout";
printf("Third char is: %c\n", s[2]);
</pre>
Hier w&uuml;rde das Zeichen <tt>'y'</tt> ausgedruckt.
Beachten Sie, dass <tt>s[2]</tt> das dritte Zeichen des Strings
<tt>s</tt> liefert!
<p>
Eine verlustfreie Typ-Umwandlung nach <tt><a href=#171>char</a></tt> ist
f&uuml;r Standard ASCII Strings m&ouml;glich:
<pre>
string s = "Layout";
char c = s[2];
</pre>
<p>
<b>Siehe auch</b> <a href=#228>Operatoren</a>,
<a href=#257>Builtin-Functions</a>,
<a href=#160>String-Konstanten</a>
<h2>Implementierungs-Details</h2>
Der Datentyp <tt>string</tt> ist implementiert wie von C her bekannte
"Zero-terminated-Strings".
Betrachtet man die folgende Variablen-Definition
<pre>
string s = "abcde";
</pre>
dann ist <tt>s[4]</tt> das Zeichen <tt>'e'</tt>, und <tt>s[5]</tt> ist das Zeichen
<tt>'\0'</tt>, oder der Integer-Wert <tt>0x00</tt>.
Diese Tatsache kann dazu ausgenutzt werden, das Ende eines Strings
ohne die Funktion <tt><a href=#296>strlen()</a></tt> festzustellen, wie
in
<pre>
for (int i = 0; s[i]; ++i) {
    // do something with s[i]
    }
</pre>
Es ist auch v&ouml;llig in Ordnung, einen String "abzuschneiden", indem man
den Wert "0" an der gew&uuml;nschten Stelle einf&uuml;gt:
<pre>
string s = "abcde";
s[3] = 0;
</pre>
Als Ergebnis erh&auml;lt man f&uuml;r den String <tt>s</tt> den Wert <tt>"abc"</tt>.
Beachten Sie bitte, dass alles, was auf den Wert "0" folgt, wirklich
verschwunden ist, und auch nicht mehr zur&uuml;ckgeholt werden kann, indem
der urspr&uuml;ngliche Wert wieder eingesetzt wird. Das gleiche gilt auch
f&uuml;r jede andere Operation, bei der ein Zeichen zu 0 wird, wie etwa --s[3].


<a name=175>
<h1>Typ-Umwandlung</h1>
Der Typ des Ergebnisses eines arithmetischen
<a href=#235>Ausdrucks</a>, wie z.B. <tt>a + b</tt>,
wobei <tt>a</tt> und <tt>b</tt> unterschiedliche arithmetische Typen sind,
ist gleich dem "gr&ouml;&szlig;eren" der beiden Operanden-Typen.
<p>
Arithmetische Typen sind
<tt><a href=#171>char</a></tt>,
<tt><a href=#172>int</a></tt> und
<tt><a href=#173>real</a></tt>
(in dieser Reihenfolge). Ist zum Beispiel <tt>a</tt> vom Typ
<tt><a href=#172>int</a></tt>
und <tt>b</tt> vom Typ
<tt><a href=#173>real</a></tt>, dann ist das Ergebnis
<tt>a + b</tt> vom Typ
<tt><a href=#173>real</a></tt>.
<p>
<b>Siehe auch</b> <a href=#176>Typecast</a>


<a name=176>
<h1>Typecast</h1>
Der Ergebnis-Typ eines arithmetischen
<a href=#235>Ausdrucks</a>
kann explizit in einen anderen arithmetischen Typ umgewandelt werden,
indem man einen
<i>Typecast</i> darauf anwendet.
<p>
Die allgemeine Syntax eines Typecast ist
<pre>
type(expression)
</pre>
wobei <tt>type</tt>
<tt><a href=#171>char</a></tt>,
<tt><a href=#172>int</a></tt> oder
<tt><a href=#173>real</a></tt> ist und
<tt>expression</tt> jeder arithmetische
<a href=#235>Ausdruck</a> sein kann.
<p>
Wenn man mit Typecast einen Ausdruck vom Typ
<tt><a href=#173>real</a></tt> in
<tt><a href=#172>int</a></tt> umwandelt, wird der Dezimalbruch
des Wertes abgeschnitten.
<p>
<b>Siehe auch</b> <a href=#175>Typ-Umwandlung</a>


<a name=177>
<h1>Objekt-Typen</h1>
Die EAGLE-Datenstruktur wird in XML-Dateien gespeichert:
<ul>
<li>Library (*.lbr)
<li>Schaltplan (*.sch)
<li>Board (*.brd)
</ul>
Diese Dateien enthalten Objekte, die hierarchisch gegliedert sind.
In einem User-Language-Programm kann man auf die Hierarchiestufen mit
Hilfe der entsprechenden Builtin-Zugriffs-Statements zugreifen:
<pre>
<a href=#325>library</a>(L) { ... }
<a href=#329>schematic</a>(S) { ... }
<a href=#323>board</a>(B) { ... }
</pre>
Diese Zugriffs-Statements schaffen einen Kontext, innerhalb dessen Sie
auf alle Objekte in Bibliotheken, Schaltpl&auml;nen oder Platinen zugreifen k&ouml;nnen.
<p>
Auf die "Properties" dieser Objekte kann mit Hilfe von <i>Members</i>
zugegriffen werden.
<p>
Es gibt zwei Arten von Members:
<ul>
<li>Data members
<li>Loop members
</ul>
<b>Data members</b> liefern die Objektdaten unmittelbar.
Zum Beispiel in
<pre>
board(B) {
  printf("%s\n", B.name);
  }
</pre>
liefert Data member <i>name</i> des Board-Objekts <i>B</i>
den Board-Namen.<br>
Data members k&ouml;nnen auch andere Objekte zur&uuml;ckgeben, wie in
<pre>
board(B) {
  printf("%f\n", B.grid.size);
  }
</pre>
wo Data member <i>grid</i> des Boards ein Grid-Objekt zur&uuml;ckliefert,
dessen Data member <i>size</i> dann Grid-Size (Rastergr&ouml;&szlig;e) zur&uuml;ckgibt.
<p>
<b>Loop members</b> werden verwendet, um auf Mehrfach-Objekte
derselben Art zuzugreifen, die in einem Objekt einer h&ouml;heren Hierarchiestufe
enthalten sind:
<pre>
board(B) {
  B.elements(E) {
    printf("%-8s %-8s\n", E.name, E.value);
    }
  }
</pre>
Dieses Beispiel verwendet Loop member <i>elements()</i> des Boards,
um eine Schleife durch alle Board-Elemente zu realisieren. Der Block nach
dem <tt>B.elements(E)</tt>-Statement wird der Reihe nach f&uuml;r jedes Element
ausgef&uuml;hrt, und das gegenw&auml;rtige Element kann innerhalb des Blocks unter
dem Namen <tt>E</tt> angesprochen werden.
<p>
Loop members behandeln Objekte in alpha-numerisch sortierter Reihenfolge,
falls die Objekte einen Namen haben.
<p>
Eine Loop-member-Funktion erzeugt eine Variable vom erforderlichen Typ,
um die Objekte zu speichern. Sie d&uuml;rfen jeden g&uuml;ltigen Namen f&uuml;r eine
derartige Variable verwenden, so dass das obige Beispiel auch so lauten k&ouml;nnte:
<pre>
board(MyBoard) {
  MyBoard.elements(TheCurrentElement) {
    printf("%-8s %-8s\n", TheCurrentElement.name, TheCurrentElement.value);
    }
  }
</pre>
Das Ergebnis w&auml;re identisch mit dem vorhergehenden Beispiel. Der G&uuml;ltigkeitsbereich
einer Variablen, die von einer Loop-member-Funktion angelegt wird, ist
auf das Statement oder den Block unmittelbar nach dem Loop-Funktionsaufruf
beschr&auml;nkt.
<p>
<h2>Objekt-Hierarchie einer Bibliothek:</h2>
<pre>
<a href=#200>LIBRARY</a>
  <a href=#194>GRID</a>
  <a href=#199>LAYER</a>
  <a href=#188>DEVICESET</a>
    <a href=#187>DEVICE</a>
    <a href=#193>GATE</a>
  <a href=#204>PACKAGE</a>
    <a href=#185>CONTACT</a>
      <a href=#205>PAD</a>
      <a href=#217>SMD</a>
    <a href=#183>CIRCLE</a>
    <a href=#195>HOLE</a>
    <a href=#212>RECTANGLE</a>
    <a href=#192>FRAME</a>
    <a href=#189>DIMENSION</a>
    <a href=#219>TEXT</a>
    <a href=#223>WIRE</a>
    <a href=#209>POLYGON</a>
      <a href=#223>WIRE</a>
  <a href=#218>SYMBOL</a>
    <a href=#207>PIN</a>
    <a href=#183>CIRCLE</a>
    <a href=#212>RECTANGLE</a>
    <a href=#192>FRAME</a>
    <a href=#189>DIMENSION</a>
    <a href=#219>TEXT</a>
    <a href=#223>WIRE</a>
    <a href=#209>POLYGON</a>
      <a href=#223>WIRE</a>
</pre>
<h2>Objekt-Hierarchie eines Schaltplans:</h2>
<pre>
<a href=#213>SCHEMATIC</a>
  <a href=#194>GRID</a>
  <a href=#199>LAYER</a>
  <a href=#200>LIBRARY</a>
  <a href=#180>ATTRIBUTE</a>
  <a href=#220>VARIANTDEF</a>
  <a href=#206>PART</a>
    <a href=#180>ATTRIBUTE</a>
    <a href=#221>VARIANT</a>
  <a href=#215>SHEET</a>
    <a href=#183>CIRCLE</a>
    <a href=#212>RECTANGLE</a>
    <a href=#192>FRAME</a>
    <a href=#189>DIMENSION</a>
    <a href=#219>TEXT</a>
    <a href=#223>WIRE</a>
    <a href=#209>POLYGON</a>
      <a href=#223>WIRE</a>
    <a href=#196>INSTANCE</a>
      <a href=#180>ATTRIBUTE</a>
    <a href=#202>MODULEINST</a>
    <a href=#182>BUS</a>
      <a href=#214>SEGMENT</a>
        <a href=#198>LABEL</a>
          <a href=#219>TEXT</a>
          <a href=#223>WIRE</a>
        <a href=#223>WIRE</a>
    <a href=#203>NET</a>
      <a href=#214>SEGMENT</a>
        <a href=#197>JUNCTION</a>
        <a href=#208>PINREF</a>
        <a href=#211>PORTREF</a>
        <a href=#219>TEXT</a>
        <a href=#223>WIRE</a>
  <a href=#201>MODULE</a>
    <a href=#206>PORT</a>
    <a href=#206>PART</a>
    <a href=#215>SHEET</a>
      (siehe oben)
</pre>
<h3>&Auml;nderungshinweis von Version 5 zu Version 6, Kompatibilit&auml;t:</h3>
<ul>
<li>Das Instance steht seit Version 6 in der Hierarchie nicht mehr unter dem Part, sondern unter dem Sheet.</li>
<li>Das Part steht nicht mehr unter dem Sheet, sondern direkt unter dem Schaltplan.</li>
</ul>
Aus Kompatibilit&auml;tsgr&uuml;nden werden die Zugriffe &uuml;ber die entsprechenden Memberfunktionen
zwar weiterhin unterst&uuml;tzt, das Verhalten der <a href=#311>Objekt-Funktionen</a> entspricht aber der neuen Hierarchie.
<h2>Objekt-Hierarchie einer Platine:</h2>
<pre>
<a href=#181>BOARD</a>
  <a href=#194>GRID</a>
  <a href=#199>LAYER</a>
  <a href=#200>LIBRARY</a>
  <a href=#180>ATTRIBUTE</a>
  <a href=#220>VARIANTDEF</a>
  <a href=#183>CIRCLE</a>
  <a href=#195>HOLE</a>
  <a href=#212>RECTANGLE</a>
  <a href=#192>FRAME</a>
  <a href=#189>DIMENSION</a>
  <a href=#219>TEXT</a>
  <a href=#223>WIRE</a>
  <a href=#209>POLYGON</a>
    <a href=#223>WIRE</a>
  <a href=#190>ELEMENT</a>
    <a href=#180>ATTRIBUTE</a>
    <a href=#221>VARIANT</a>
  <a href=#216>SIGNAL</a>
    <a href=#186>CONTACTREF</a>
    <a href=#209>POLYGON</a>
      <a href=#223>WIRE</a>
    <a href=#222>VIA</a>
    <a href=#223>WIRE</a>
</pre>


<a name=178>
<h1>UL_ARC</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle1</tt>       </td><td width=20><td><a href=#173>real</a> (Startwinkel, <tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>angle2</tt>       </td><td width=20><td><a href=#173>real</a> (Endwinkel, <tt>0.0</tt>...<tt>719.9</tt>)</td></tr>
<tr><td><tt>cap</tt>          </td><td width=20><td><a href=#172>int</a> (<tt>CAP_...</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>radius</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#172>int</a> (Startpunkt)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#172>int</a> (Endpunkt)</td></tr>
<tr><td><tt>xc, yc</tt>       </td><td width=20><td><a href=#172>int</a> (Mittelpunkt)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#223>UL_WIRE</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CAP_FLAT</tt>  </td><td width=20><td>flache Kreisbogen-Enden</td></tr>
<tr><td><tt>CAP_ROUND</tt>   </td><td width=20><td>runde Kreisbogen-Enden</td></tr>
</table>
<h2>Anmerkung</h2>
Start- und Endwinkel werden im mathematisch positiven Sinne ausgegeben
(also gegen den Uhrzeigersinn, "counterclockwise"),
wobei gilt <tt>angle1</tt> &lt; <tt>angle2</tt>.
Um diese Bedingung einzuhalten kann es sein, dass Start- und Endpunkt eines UL_ARC
gegen&uuml;ber denen des UL_WIRE, von dem der Kreisbogen abstammt, vertauscht sind.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.wires(W) {
    if (W.arc)
       printf("Arc: (%f %f), (%f %f), (%f %f)\n",
              u2mm(W.arc.x1), u2mm(W.arc.y1), u2mm(W.arc.x2), u2mm(W.arc.y2), u2mm(W.arc.xc), u2mm(W.arc.yc));
    }
  }
</pre>


<a name=179>
<h1>UL_AREA</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#172>int</a> (linke untere Ecke)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#172>int</a> (rechte obere Ecke)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#187>UL_DEVICE</a>,
<a href=#204>UL_PACKAGE</a>,
<a href=#215>UL_SHEET</a>,
<a href=#218>UL_SYMBOL</a>
<p>
UL_AREA ist ein Pseudo-Objekt, das Informationen &uuml;ber die Fl&auml;che liefert,
die ein Objekt einnimmt. F&uuml;r ein UL_PACKAGE bzw. UL_SYMBOL in einem
UL_ELEMENT- bzw. UL_INSTANCE-Kontext beinhalten die Koordinaten den Offset
des betreffenden Bauteils und die Fl&auml;che von Texten, die nach
<a href=#100>SMASH</a> verschoben wurden.
<h2>Beispiel</h2>
<pre>
board(B) {
  printf("Area: (%f %f), (%f %f)\n",
          u2mm(B.area.x1), u2mm(B.area.y1), u2mm(B.area.x2), u2mm(B.area.y2));
  }
</pre>


<a name=180>
<h1>UL_ATTRIBUTE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>constant</tt>    </td><td width=20><td><a href=#172>int</a> (0=variabel, d.h. &uuml;berschreiben erlaubt, 1=konstant - siehe Anmerkung)</td></tr>
<tr><td><tt>defaultvalue</tt> </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>display</tt>      </td><td width=20><td><a href=#172>int</a> (<tt>ATTRIBUTE_DISPLAY_FLAG_...</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>text</tt>         </td><td width=20><td><a href=#219>UL_TEXT</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#174>string</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#187>UL_DEVICE</a>,
<a href=#206>UL_PART</a>,
<a href=#196>UL_INSTANCE</a>,
<a href=#190>UL_ELEMENT</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ATTRIBUTE_DISPLAY_FLAG_OFF</tt>   </td><td width=20><td>keine Anzeige</td></tr>
<tr><td><tt>ATTRIBUTE_DISPLAY_FLAG_VALUE</tt>   </td><td width=20><td>Wert wird angezeigt</td></tr>
<tr><td><tt>ATTRIBUTE_DISPLAY_FLAG_NAME</tt>    </td><td width=20><td>Name wird angezeigt</td></tr>
</table>
<p>
Ein UL_ATTRIBUTE kann dazu benutzt werden, die <i>Attribute</i> anzusprechen,
die f&uuml;r ein Device in der Bibliothek definiert wurden, bzw. einem Bauteil
im Schaltplan oder Board zugewiesen wurden.
<h2>Anmerkung</h2>
<tt>display</tt> enth&auml;lt einen bitweise ODER-verkn&uuml;pften Wert, bestehend aus <tt>ATTRIBUTE_DISPLAY_FLAG_...</tt>,
der angibt welche Teile des Attributs dargestellt werden.
Dieser Wert ist nur dann g&uuml;ltig, wenn <tt>display</tt> in einem UL_INSTANCE- oder UL_ELEMENT-Kontext
benutzt wird.
<p>
In einem UL_ELEMENT-Kontext liefert <tt>constant</tt> nur bei aktiver F/B-Annotation
einen tats&auml;chlichen Wert, ansonsten wird 0 geliefert.
<p>
Das <tt>defaultvalue</tt>-Member liefert den Wert, wie er in der Bibliothek definiert
wurde (falls sich dieser vom tats&auml;chlichen Wert unterscheidet, ansonsten ist es
der selbe Wert wie bei <tt>value</tt>).
In einem UL_ELEMENT-Kontext liefert <tt>defaultvalue</tt> nur bei aktiver F/B-Annotation
einen tats&auml;chlichen Wert, ansonsten wird ein leerer String geliefert.
<p>
Das <tt>text</tt>-Member ist nur in einem UL_INSTANCE- oder UL_ELEMENT-Kontext
verf&uuml;gbar und liefert ein UL_TEXT-Objekt welches alle Text-Parameter enth&auml;lt.
Der Wert dieses Text-Objekts ist der Text wie er gem&auml;&szlig; dem 'display'-Parameter
des UL_ATTRIBUTE angezeigt wird. Wird diese Funktion aus einem anderen Kontext
heraus aufgerufen, so sind die Werte des zur&uuml;ckgegebenen UL_TEXT-Objekts
undefiniert.
<p>
Bei globalen Attributen sind nur <tt>name</tt> und <tt>value</tt> definiert.
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.parts(P) {
    P.attributes(A) {
      printf("%s = %s\n", A.name, A.value);
      }
    }
  }
schematic(SCH) {
  SCH.attributes(A) { // global attributes
    printf("%s = %s\n", A.name, A.value);
    }
  }
</pre>


<a name=181>
<h1>UL_BOARD</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>alwaysvectorfont</tt></td><td width=20><td><a href=#172>int</a> (<tt>ALWAYS_VECTOR_FONT_..., siehe Anmerkung</tt>)</td></tr>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#179>UL_AREA</a></td></tr>
<tr><td><tt>checked</tt>      </td><td width=20><td><a href=#172>int</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>grid</tt>         </td><td width=20><td><a href=#194>UL_GRID</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>verticaltext</tt></td><td width=20><td><a href=#172>int</a> (<tt>VERTICAL_TEXT_...</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#180>UL_ATTRIBUTE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#183>UL_CIRCLE</a></td></tr>
<tr><td><tt>classes()</tt>    </td><td width=20><td><a href=#184>UL_CLASS</a></td></tr>
<tr><td><tt>dimensions()</tt> </td><td width=20><td><a href=#189>UL_DIMENSION</a></td></tr>
<tr><td><tt>elements()</tt>   </td><td width=20><td><a href=#190>UL_ELEMENT</a></td></tr>
<tr><td><tt>errors()</tt>     </td><td width=20><td><a href=#191>UL_ERROR</a></td></tr>
<tr><td><tt>frames()</tt>     </td><td width=20><td><a href=#192>UL_FRAME</a></td></tr>
<tr><td><tt>holes()</tt>      </td><td width=20><td><a href=#195>UL_HOLE</a></td></tr>
<tr><td><tt>layers()</tt>     </td><td width=20><td><a href=#199>UL_LAYER</a></td></tr>
<tr><td><tt>libraries()</tt>  </td><td width=20><td><a href=#200>UL_LIBRARY</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#209>UL_POLYGON</a></td></tr>
<tr><td><tt>rectangles()</tt> </td><td width=20><td><a href=#212>UL_RECTANGLE</a></td></tr>
<tr><td><tt>signals()</tt>    </td><td width=20><td><a href=#216>UL_SIGNAL</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a></td></tr>
<tr><td><tt>variantdefs()</tt></td><td width=20><td><a href=#220>UL_VARIANTDEF</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#200>UL_LIBRARY</a>,
<a href=#213>UL_SCHEMATIC</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ALWAYS_VECTOR_FONT_GUI</tt></td><td width=20><td>die Option "Immer Vektor-Schrift" ist
im <a href=#17>User-Interface-Dialog</a> gesetzt</td></tr>
<tr><td><tt>ALWAYS_VECTOR_FONT_PERSISTENT</tt></td><td width=20><td>die Option "Immer Vektor-Schrift" ist
in diese Zeichnung eingepr&auml;gt</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>VERTICAL_TEXT_UP</tt></td><td width=20><td>Leserichtung f&uuml;r vertikale Texte: aufw&auml;rts</td></tr>
<tr><td><tt>VERTICAL_TEXT_DOWN</tt></td><td width=20><td>Leserichtung f&uuml;r vertikale Texte: abw&auml;rts</td></tr>
</table>
<h2>Anmerkung</h2>
Der Wert von <tt>alwaysvectorfont</tt> kann in einem logischen Kontext verwendet werden
oder er kann auch mit den <tt>ALWAYS_VECTOR_FONT_...</tt> Konstanten maskiert werden,
um die Herkunft dieser Einstellung zu ermitteln, wie zum Beispiel in
<pre>
if (B.alwaysvectorfont) {
   // alwaysvectorfont ist gesetzt
   }
if (B.alwaysvectorfont &amp; ALWAYS_VECTOR_FONT_GUI) {
   // alwaysvectorfont ist in der Benutzeroberfl&auml;che gesetzt
   }
</pre>
Der Wert von <tt>checked</tt> kann in einem logischen Kontext verwendet werden;
er ist nur gesetzt, wenn gerade ein 'Design Rule Check' (<a href=#48>DRC</a>)
durchgef&uuml;hrt wurde.
<p>
Das <tt>name</tt> Member liefert den vollst&auml;ndigen Dateinamen, inklusive Verzeichnis.
<p>
Das Loop member <tt>attributes()</tt> geht durch die <i>globalen</i> Attribute.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.elements(E) printf("Element: %s\n", E.name);
  B.signals(S)  printf("Signal: %s\n", S.name);
  }
</pre>


<a name=182>
<h1>UL_BUS</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>BUS_NAME_LENGTH</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>segments()</tt>   </td><td width=20><td><a href=#214>UL_SEGMENT</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#215>UL_SHEET</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>BUS_NAME_LENGTH</tt>   </td><td width=20><td>max. L&auml;nge eines Busnamens (obsolet - ab Version 4 k&ouml;nnen Bus-Namen beliebig lang sein)</td></tr>
</table>
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    SH.busses(B) printf("Bus: %s\n", B.name);
    }
  }
</pre>


<a name=183>
<h1>UL_CIRCLE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>radius</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Mittelpunkt)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#204>UL_PACKAGE</a>,
<a href=#215>UL_SHEET</a>,
<a href=#218>UL_SYMBOL</a>
<h2>Beispiel</h2>
<pre>
board(B) {
  B.circles(C) {
    printf("Circle: (%f %f), r=%d, w=%d\n",
           u2mm(C.x), u2mm(C.y), u2mm(C.radius), u2mm(C.width));
    }
  }
</pre>


<a name=184>
<h1>UL_CLASS</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>clearance[number]</tt></td><td width=20><td><a href=#172>int</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>drill</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>name</tt>        </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>number</tt>      </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>width</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
</table>
</dl>
<b>Siehe auch </b> <a href=#139>Design Rules</a>,
<a href=#203>UL_NET</a>,
<a href=#216>UL_SIGNAL</a>,
<a href=#213>UL_SCHEMATIC</a>,
<a href=#181>UL_BOARD</a>
<h2>Anmerkung</h2>
Das <tt>clearance</tt> Data Member liefert den Mindestabstand zwischen dieser
Netzklasse und der Netzklasse mit der angegebenen Nummer. Wird keine Nummer
angegeben (und damit auch keine eckigen Klammern), wird der Mindestabstand der
Netzklasse selber geliefert. Wird eine Nummer angegeben, so muss diese zwischen
0 und der Nummer dieser Netzklasse liegen.
<p>
Wenn <tt>name</tt> einen leeren String liefert, ist die Netzklasse nicht definiert und wird somit
auch nicht von einem Signal oder Netz benutzt.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.signals(S) {
    printf("%-10s %d %s\n", S.name, S.class.number, S.class.name);
    }
  }
</pre>


<a name=185>
<h1>UL_CONTACT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>CONTACT_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>pad</tt>          </td><td width=20><td><a href=#205>UL_PAD</a></td></tr>
<tr><td><tt>signal</tt>       </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>smd</tt>          </td><td width=20><td><a href=#217>UL_SMD</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Mittelpunkt, siehe Anmerkung)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#209>UL_POLYGON</a> (von beliebigen Pad-Formen)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a> (von beliebigen Pad-Formen)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#204>UL_PACKAGE</a>,
<a href=#205>UL_PAD</a>,
<a href=#217>UL_SMD</a>,
<a href=#186>UL_CONTACTREF</a>,
<a href=#208>UL_PINREF</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CONTACT_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines "Contact"-Namens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Das <tt>signal</tt> Data Member liefert den Namen des Signals, an das dieser Contact
angeschlossen ist (nur in einem Board-Kontext verf&uuml;gbar).
<p>
Die Koordinaten (<tt>x, y</tt>) des "Contacts" h&auml;ngen vom Kontext ab aus dem sie aufgerufen werden:
<ul>
<li>Wird "Contact" aus einem UL_LIBRARY-Kontext aufgerufen, sind die Koordinaten dieselben, wie
in der Package-Zeichnung
<li>In allen anderen F&auml;llen gelten die aktuellen Werte in der Board-Datei
</ul>
<h2>Beispiel</h2>
<pre>
library(L) {
  L.packages(PAC) {
    PAC.contacts(C) {
      printf("Contact: '%s', (%f %f)\n",
             C.name, u2mm(C.x), u2mm(C.y));
      }
    }
  }
</pre>


<a name=186>
<h1>UL_CONTACTREF</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>contact</tt>      </td><td width=20><td><a href=#185>UL_CONTACT</a></td></tr>
<tr><td><tt>element</tt>      </td><td width=20><td><a href=#190>UL_ELEMENT</a></td></tr>
<tr><td><tt>route</tt>        </td><td width=20><td><a href=#172>int</a> (<tt>CONTACT_ROUTE_...</tt>)</td></tr>
<tr><td><tt>routetag</tt>     </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#216>UL_SIGNAL</a>,
<a href=#208>UL_PINREF</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CONTACT_ROUTE_ALL</tt>   </td><td width=20><td>alle Kontakte m&uuml;ssen explizit angeschlossen werden</td></tr>
<tr><td><tt>CONTACT_ROUTE_ANY</tt>   </td><td width=20><td>beliebige Kontakte k&ouml;nnen angeschlossen werden</td></tr>
</table>
<h2>Anmerkung</h2>
Wenn <tt>route</tt> den Wert <tt>CONTACT_ROUTE_ANY</tt> hat, liefert das <tt>routetag</tt>
Member einen zus&auml;tzlichen String, der eine Gruppe von <tt>contactref</tt>s beschreibt,
die zu ein und demselben Pin geh&ouml;ren.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.signals(S) {
    printf("Signal '%s'\n", S.name);
    S.contactrefs(C) {
      printf("\t%s, %s\n", C.element.name, C.contact.name);
      }
    }
  }
</pre>


<a name=187>
<h1>UL_DEVICE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>activetechnology</tt> </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#179>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>library</tt>      </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>DEVICE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>package</tt>      </td><td width=20><td><a href=#204>UL_PACKAGE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>prefix</tt>       </td><td width=20><td><a href=#174>string</a> (<tt>DEVICE_PREFIX_LENGTH</tt>)</td></tr>
<tr><td><tt>technologies</tt> </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#174>string</a> ("On" oder "Off")</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#180>UL_ATTRIBUTE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>gates()</tt>      </td><td width=20><td><a href=#193>UL_GATE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#188>UL_DEVICESET</a>,
<a href=#200>UL_LIBRARY</a>,
<a href=#206>UL_PART</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>DEVICE_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Device-Namens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
<tr><td><tt>DEVICE_PREFIX_LENGTH</tt> </td><td width=20><td>max. empfohlene L&auml;nge eines Device-Pr&auml;fix (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<p>
Alle UL_DEVICE-Member, mit Ausnahme von <tt>name</tt> und <tt>technologies</tt>, liefern
dieselben Werte wie die zugeh&ouml;rigen UL_DEVICESET-Member in dem UL_DEVICE definiert wurde.
Das <tt>name</tt>-Member liefert den Namen der Package-Variante, f&uuml;r welche dieses
Device mit dem <a href=#76>PACKAGE</a>-Befehl erzeugt worden ist.
Bitte denken Sie daran: Der <tt>description</tt>-Text darf Newline-Zeichen (<tt>'\n'</tt>) enthalten.
<h2>Anmerkung</h2>
Der Wert des <tt>activetechnology</tt>-Member h&auml;ngt vom Kontext ab aus dem es aufgerufen wurde:
<ul>
<li>Wird das Device &uuml;ber das UL_DEVICESET, das gerade im Bibliotheks-Editor-Fenster bearbeitet wird, hergeleitet,
dann wird die aktive Technologie, die durch einen <a href=#103>TECHNOLOGY</a> Befehl eingestellt wurde, geliefert
<li>Wird das Device &uuml;ber UL_PART hergeleitet, wird die aktuelle Technologie, die von diesem
Bauteil benutzt wird, ausgegeben
<li>In allen anderen F&auml;llen wird ein leerer String geliefert.
</ul>
<p>
Das <tt>package</tt> Data Member liefert das <a href=#204>Package</a>,
das dem Device durch einen <a href=#76>PACKAGE</a>-Befehl zugewiesen
worden ist. Es kann als boolesche Funktion verwendet werden um zu pr&uuml;fen, ob dem Device
ein Package zugewiesen wurde (siehe Beispiel unten).
<p>
Der Wert des <tt>technologies</tt>-Member h&auml;ngt vom Kontext ab aus dem es aufgerufen wurde:
<ul>
<li>Wird das Device &uuml;ber UL_DEVICESET hergeleitet, liefert <tt>technologies</tt> einen String,
der alles &uuml;ber die Technologien des Devices, durch Leerzeichen getrennt, enth&auml;lt
<li>Wird das Device &uuml;ber UL_PART hergeleitet, wird nur die aktuelle Technologie, die von diesem
Bauteil benutzt wird, ausgegeben.
</ul>
<p>
Das Loop member <tt>attributes()</tt> erwartet einen zus&auml;tzlichen Parameter der
angibt, f&uuml;r welche Technology die Attribute geliefert werden sollen (siehe das
zweite Beispiel).
<h2>Beispiele</h2>
<pre>
library(L) {
  L.devicesets(S) {
    S.devices(D) {
      if (D.package)
         printf("Device: %s, Package: %s\n", D.name, D.package.name);
      D.gates(G) {
        printf("\t%s\n", G.name);
        }
      }
    }
  }
</pre>
<pre>
library(L) {
  L.devicesets(DS) {
    DS.devices(D) {
      string t[];
      int n = strsplit(t, D.technologies, ' ');
      for (int i = 0; i &lt; n; i++) {
          D.attributes(A, t[i]) {
            printf("%s = %s\n", A.name, A.value);
            }
          }
      }
    }
  }
</pre>


<a name=188>
<h1>UL_DEVICESET</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>activedevice</tt> </td><td width=20><td><a href=#187>UL_DEVICE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#179>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>library</tt>      </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>DEVICE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>prefix</tt>       </td><td width=20><td><a href=#174>string</a> (<tt>DEVICE_PREFIX_LENGTH</tt>)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#174>string</a> ("On" oder "Off")</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>devices()</tt>    </td><td width=20><td><a href=#187>UL_DEVICE</a></td></tr>
<tr><td><tt>gates()</tt>      </td><td width=20><td><a href=#193>UL_GATE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#187>UL_DEVICE</a>,
<a href=#200>UL_LIBRARY</a>,
<a href=#206>UL_PART</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>DEVICE_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge des Device-Namen (wird nur bei formatierten Ausgaben benutzt)</td></tr>
<tr><td><tt>DEVICE_PREFIX_LENGTH</tt> </td><td width=20><td>max. empfohlene L&auml;nge des Prefix (wird nur bei formatierten Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Wenn gerade ein <tt>deviceset</tt> im Bibliotheks-Editor-Fenster bearbeitet wird,
dann liefert das <tt>activedevice</tt>-Member das aktive Device, das durch einen <a href=#76>PACKAGE</a>
Befehl ausgew&auml;hlt wurde. Es kann als boolesche Funktion verwendet werden, um zu pr&uuml;fen, ob die Voraussetzungen
hierf&uuml;r gegeben sind (siehe Beispiel unten).
<p>
Das <tt>description</tt>-Member liefert den vollst&auml;ndigen Beschreibungstext, der mit dem
<a href=#45>DESCRIPTION</a>-Befehl erzeugt wurde, w&auml;hrend das <tt>headline</tt>-Member
nur die erste Zeile der Beschreibung ohne <a href=#370>HTML</a>-Tags ausgibt.
Wenn Sie <tt>description</tt>-Text schreiben, denken Sie daran, dass dieser Newline-Anweisungen
(<tt>'\n'</tt>) enthalten darf.
<h2>Beispiel</h2>
<pre>
library(L) {
  L.devicesets(D) {
    printf("Device set: %s, Description: %s\n", D.name, D.description);
    D.gates(G) {
      printf("\t%s\n", G.name);
      }
    }
  }
</pre>
<pre>
if (deviceset)
   deviceset(DS) {
     if (DS.activedevice)
        printf("Active Device: %s\n", DS.activedevice.name);
     }
</pre>


<a name=189>
<h1>UL_DIMENSION</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>dtype</tt>        </td><td width=20><td><a href=#172>int</a> (<tt>DIMENSION_...</tt>)</td></tr>
<tr><td><tt>extlength</tt>    </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>extoffset</tt>    </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>extwidth</tt>     </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>precision</tt>    </td><td width=20><td><a href=#172>int</a> (Genauigkeit der Ma&szlig;angabe)</td></tr>
<tr><td><tt>ratio</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>size</tt>         </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>unit</tt>         </td><td width=20><td><a href=#172>int</a> (Einheit, <tt>GRID_UNIT_...</tt>)</td></tr>
<tr><td><tt>visible</tt>      </td><td width=20><td><a href=#172>int</a> (Einheit, 0=off, 1=on)</td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#172>int</a> (erster Bezugspunkt)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#172>int</a> (zweiter Bezugspunkt)</td></tr>
<tr><td><tt>x3, y3</tt>       </td><td width=20><td><a href=#172>int</a> (Hilfspunkt f&uuml;r die Ausrichtung)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#194>UL_GRID</a>,
<a href=#204>UL_PACKAGE</a>,
<a href=#215>UL_SHEET</a>,
<a href=#218>UL_SYMBOL</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>DIMENSION_PARALLEL</tt>    </td><td width=20><td>lineare Bema&szlig;ung mit paralleler Ma&szlig;linie</td></tr>
<tr><td><tt>DIMENSION_HORIZONTAL</tt>  </td><td width=20><td>lineare Bema&szlig;ung mit waagerechter Ma&szlig;linie</td></tr>
<tr><td><tt>DIMENSION_VERTICAL</tt>    </td><td width=20><td>lineare Bema&szlig;ung mit senkrechter Ma&szlig;linie</td></tr>
<tr><td><tt>DIMENSION_RADIUS</tt>      </td><td width=20><td>Radius-Bema&szlig;ung</td></tr>
<tr><td><tt>DIMENSION_DIAMETER</tt>    </td><td width=20><td>Durchmesser-Bema&szlig;ung</td></tr>
<tr><td><tt>DIMENSION_ANGLE</tt>       </td><td width=20><td>Winkel-Bema&szlig;ung</td></tr>
<tr><td><tt>DIMENSION_LEADER</tt>      </td><td width=20><td>ein beliebiger Pfeil</td></tr>
</table>
<h2>Anmerkung</h2>
Die Loop-Members <tt>texts()</tt> und <tt>wires()</tt> gehen durch alle Texte und
Linien, aus denen die Bema&szlig;ung besteht.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.dimensions(D) {
    printf("Dimension: (%f %f), (%f %f), (%f %f)\n",
           u2mm(D.x1), u2mm(D.y1), u2mm(D.x2), u2mm(D.y2), u2mm(D.x3), u2mm(D.y3));
    }
  }
</pre>


<a name=190>
<h1>UL_ELEMENT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#173>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>attribute[]</tt>  </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>column</tt>       </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>locked</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>ELEMENT_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>package</tt>      </td><td width=20><td><a href=#204>UL_PACKAGE</a></td></tr>
<tr><td><tt>populate</tt>     </td><td width=20><td><a href=#172>int</a> (0=do not populate, 1=populate)</td></tr>
<tr><td><tt>row</tt>          </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>smashed</tt>      </td><td width=20><td><a href=#172>int</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>spin</tt>         </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#174>string</a>  (<tt>ELEMENT_VALUE_LENGTH</tt>)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Ursprung, Aufh&auml;ngepunkt)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#180>UL_ATTRIBUTE</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a> (siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#186>UL_CONTACTREF</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ELEMENT_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Element-Namens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
<tr><td><tt>ELEMENT_VALUE_LENGTH</tt>  </td><td width=20><td>max. empfohlene L&auml;nge eines Element-Values (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Mit dem <tt>attribute[]</tt>-Member kann man ein UL_ELEMENT nach dem Wert eines
bestimmten Attributs fragen (siehe das zweite Beispiel). Der zur&uuml;ckgelieferte
String ist leer, wenn es kein Attribut mit dem angegebenen Namen gibt, oder
wenn dieses Attribut explizit leer ist.
<p>
Das <tt>texts()</tt>-Member l&auml;uft nur durch die mittels <a href=#100><b>SMASH</b></a> vom
Element losgel&ouml;sten Texte und durch die sichtbaren Texte der Attribute, die diesem Element zugewiesen wurden.
Um alle Texte eines Elements zu bearbeiten (zum Beispiel um es zu zeichnen), m&uuml;ssen Sie eine Schleife
durch das <tt>texts()</tt>-Member des Elements selbst und
durch das <tt>texts()</tt>-Member des zum Element geh&ouml;renden
<a href=#204>Package</a>
bilden.
<p>
<tt>angle</tt> gibt an um wieviel Grad das Element gegen den Uhrzeigersinn um seinen
Aufh&auml;ngepunkt gedreht ist.
<p>
Die <tt>column</tt>- und <tt>row</tt>-Members liefern die Spalten- bzw. Zeilenposition
innerhalb des <a href=#192>Rahmens</a> in der Board-Zeichnung.
Falls es in der Zeichnung keinen Rahmen gibt, oder das Element au&szlig;erhalb des Rahmens liegt,
wird ein <tt>'?'</tt> (Fragezeichen) zur&uuml;ckgegeben.
<p>
Das <tt>smashed</tt>-Member gibt Auskunft dar&uuml;ber, ob ein Element gesmasht ist.
Diese Funktion kann auch verwendet werden um herauszufinden, ob es einen losgel&ouml;sten
Platzhaltertext gibt, indem der Name des Platzhalters in eckigen Klammern angegeben
wird, wie in <tt>smashed["VALUE"]</tt>. Dies ist n&uuml;tzlich falls Sie einen solchen Text
mit dem <a href=#71>MOVE</a>-Befehl etwa durch <tt>MOVE R5&gt;VALUE</tt>
selektieren wollen. G&uuml;ltige Platzhalternamen sind "NAME" und "VALUE", sowie die
Namen etwaiger benutzerdefinierter <a href=#180>Attribute</a>.
Gro&szlig;-/Kleinschreibung spielt keine Rolle, und sie d&uuml;rfen ein vorangestelltes
<tt>'&gt;'</tt> Zeichen haben.
<h2>Beispiele</h2>
<pre>
board(B) {
  B.elements(E) {
    printf("Element: %s, (%f %f), Package=%s\n",
           E.name, u2mm(E.x), u2mm(E.y), E.package.name);
    }
  }
</pre>
<pre>
board(B) {
  B.elements(E) {
    if (E.attribute["REMARK"])
       printf("%s: %s\n", E.name, E.attribute["REMARK"]);
    }
  }
</pre>


<a name=191>
<h1>UL_ERROR</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#179>UL_AREA</a></td></tr>
<tr><td><tt>area2</tt>        </td><td width=20><td><a href=#179>UL_AREA</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>code</tt>         </td><td width=20><td><a href=#172>int</a> (Identifikations-Nummer)</td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>modulename</tt>   </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>s1</tt>           </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>s2</tt>           </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>s3</tt>           </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>s4</tt>           </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>s5</tt>           </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>s6</tt>           </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>sheet</tt>        </td><td width=20><td><a href=#172>int</a> (Seitennummer)</td></tr>
<tr><td><tt>signature</tt>    </td><td width=20><td><a href=#174>string</a> (Signatur-String)</td></tr>
<tr><td><tt>state</tt>        </td><td width=20><td><a href=#172>int</a> (<tt>ERROR_STATE_...</tt>)</td></tr>
<tr><td><tt>type</tt>         </td><td width=20><td><a href=#172>int</a> (<tt>ERROR_TYPE_...</tt>)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Mittelpunkt)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>contours()</tt>   </td><td width=20><td><a href=#223>UL_WIRE</a> (siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#213>UL_SCHEMATIC</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ERROR_STATE_ACTIVE</tt>     </td><td width=20><td>Fehler wurde weder bearbeitet, noch gebilligt</td></tr>
<tr><td><tt>ERROR_STATE_APPROVED</tt>   </td><td width=20><td>Fehler wurde gebilligt</td></tr>
<tr><td><tt>ERROR_STATE_PROCESSED</tt>  </td><td width=20><td>Fehler wurde bearbeitet</td></tr>
<tr><td><tt>ERROR_TYPE_NONE</tt>        </td><td width=20><td>kein Fehler</td></tr>
<tr><td><tt>ERROR_TYPE_WARNING</tt>     </td><td width=20><td>Warnung</td></tr>
<tr><td><tt>ERROR_TYPE_ERROR</tt>       </td><td width=20><td>Fehler</td></tr>
<tr><td><tt>ERROR_TYPE_CONSISTENCY</tt> </td><td width=20><td>Konsistenz-Fehler</td></tr>
</table>
<h2>Anmerkung</h2>
UL_ERROR ist ein Pseudo-Objekt, das Informationen &uuml;ber ERC- bzw. DRC-Fehler liefert.
<p>
Die Member <tt>layer</tt> und <tt>contours()</tt> sind nur im UL_BOARD Kontext und
die Member <tt>area2</tt>, <tt>modulename</tt>, <tt>s1..s6</tt> und <tt>sheet</tt>
sind nur im UL_SCHEMATIC Kontext verf&uuml;gbar.
<p>
Das Member <tt>area2</tt> ist eine zweite UL_AREA, die nur im Schaltplan bei einzelnen
ERC-Fehlern die entsprechende Region im Board angibt.
Die Member <tt>s1..s6</tt> sind 'string'-Werte, die bei bestimmten ERC-Fehlern
zus&auml;tzliche Informationen wie Namen liefern.
<p>
Das Loop-Member <tt>contours()</tt> geht durch die Umriss-Wires des DRC-Polygons.
<h2>Beispiel</h2>
<pre>
string s1;
string ErrLst[];
int ErrCnt = 0;
string ErrLstHeader;
if (board) board(B) {
   ErrLstHeader = "Code\tState\tDescription\tLayer\tSignature";
   if (B.checked) {
      B.errors(ER) {
         if (ER.state == ERROR_STATE_ACTIVE) {
            sprintf(s1, "%d\t%d\t%s\t%d\t%s", ER.code, ER.state, ER.description, ER.layer, ER.signature);
            ErrLst[ErrCnt++] = s1;
         }
      }
   }
}
if (schematic) schematic(SCH) {
   ErrLstHeader = "Code\tState\tDescription\tSheet\tModule\ts1\ts2\ts3\ts4\ts5\ts6";
   if (SCH.checked) {
      SCH.errors(ER) {
         if (ER.state == ERROR_STATE_ACTIVE) {
            sprintf(s1, "%d\t%d\t%s\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s", ER.code, ER.state, ER.description, ER.sheet, ER.modulename, ER.s1, ER.s2, ER.s3, ER.s4, ER.s5, ER.s6);
            ErrLst[ErrCnt++] = s1;
         }
      }
   }
}
dlgDialog("Errors") {
   int sel = -1;
   dlgListView(ErrLstHeader, ErrLst, sel);
   dlgPushButton("+OK") dlgAccept();
};
</pre>


<a name=192>
<h1>UL_FRAME</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>columns</tt>      </td><td width=20><td><a href=#172>int</a> (<tt>-127</tt>...<tt>127</tt>)</td></tr>
<tr><td><tt>rows</tt>         </td><td width=20><td><a href=#172>int</a> (<tt>-26</tt>...<tt>26</tt>)</td></tr>
<tr><td><tt>border</tt>       </td><td width=20><td><a href=#172>int</a> (<tt>FRAME_BORDER_...</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#172>int</a> (lower left corner)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#172>int</a> (upper right corner)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#204>UL_PACKAGE</a>,
<a href=#215>UL_SHEET</a>,
<a href=#218>UL_SYMBOL</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>FRAME_BORDER_BOTTOM</tt>    </td><td width=20><td>unterer Rand wird dargestellt</td></tr>
<tr><td><tt>FRAME_BORDER_RIGHT</tt>     </td><td width=20><td>rechter Rand wird dargestellt</td></tr>
<tr><td><tt>FRAME_BORDER_TOP</tt>       </td><td width=20><td>oberer Rand wird dargestellt</td></tr>
<tr><td><tt>FRAME_BORDER_LEFT</tt>      </td><td width=20><td>linker Rand wird dargestellt</td></tr>
</table>
<h2>Anmerkung</h2>
<tt>border</tt> enth&auml;lt einen bitweise ODER-verkn&uuml;pften Wert, bestehend aus <tt>FRAME_BORDER_...</tt>,
der angibt welche der vier R&auml;nder dargestellt werden.
<p>
Die Loop-Members <tt>texts()</tt> und <tt>wires()</tt> gehen durch alle Texte und
Linien, aus denen der Frame besteht.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.frames(F) {
    printf("Frame: (%f %f), (%f %f)\n",
           u2mm(F.x1), u2mm(F.y1), u2mm(F.x2), u2mm(F.y2));
    }
  }
</pre>


<a name=193>
<h1>UL_GATE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>addlevel</tt>     </td><td width=20><td><a href=#172>int</a> (<tt>GATE_ADDLEVEL_...</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>GATE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>swaplevel</tt>    </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>symbol</tt>       </td><td width=20><td><a href=#218>UL_SYMBOL</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Aufh&auml;ngepunkt, siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#187>UL_DEVICE</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>GATE_ADDLEVEL_MUST</tt>    </td><td width=20><td>must</td></tr>
<tr><td><tt>GATE_ADDLEVEL_CAN</tt>     </td><td width=20><td>can</td></tr>
<tr><td><tt>GATE_ADDLEVEL_NEXT</tt>    </td><td width=20><td>next</td></tr>
<tr><td><tt>GATE_ADDLEVEL_REQUEST</tt> </td><td width=20><td>request</td></tr>
<tr><td><tt>GATE_ADDLEVEL_ALWAYS</tt>  </td><td width=20><td>always</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>GATE_NAME_LENGTH</tt>      </td><td width=20><td>max. empfohlene L&auml;nge eines Gate-Namens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Die Koordinaten des Aufh&auml;ngepunktes (x, y) sind immer bezogen auf die Lage des Gates
im Device, auch wenn das UL_GATE &uuml;ber ein <a href=#196>UL_INSTANCE</a> geholt wurde.
<h2>Beispiel</h2>
<pre>
library(L) {
  L.devices(D) {
    printf("Device: %s, Package: %s\n", D.name, D.package.name);
    D.gates(G) {
      printf("\t%s, swaplevel=%d, symbol=%s\n",
             G.name, G.swaplevel, G.symbol.name);
      }
    }
  }
</pre>


<a name=194>
<h1>UL_GRID</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>distance</tt>     </td><td width=20><td><a href=#173>real</a></td></tr>
<tr><td><tt>dots</tt>         </td><td width=20><td><a href=#172>int</a> (0=lines, 1=dots)</td></tr>
<tr><td><tt>multiple</tt>     </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>on</tt>           </td><td width=20><td><a href=#172>int</a> (0=off, 1=on)</td></tr>
<tr><td><tt>unit</tt>         </td><td width=20><td><a href=#172>int</a> (<tt>GRID_UNIT_...</tt>)</td></tr>
<tr><td><tt>unitdist</tt>     </td><td width=20><td><a href=#172>int</a> (<tt>GRID_UNIT_...</tt>)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#200>UL_LIBRARY</a>,
<a href=#213>UL_SCHEMATIC</a>,
<a href=#285>Unit Conversions</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>GRID_UNIT_MIC</tt>   </td><td width=20><td>Micron</td></tr>
<tr><td><tt>GRID_UNIT_MM</tt>    </td><td width=20><td>Millimeter</td></tr>
<tr><td><tt>GRID_UNIT_MIL</tt>   </td><td width=20><td>Mil</td></tr>
<tr><td><tt>GRID_UNIT_INCH</tt>  </td><td width=20><td>Inch</td></tr>
</table>
<h2>Anmerkung</h2>
<tt>unitdist</tt> liefert die Grid-Einheit mit der die tats&auml;chliche Gr&ouml;&szlig;e des Rasters
(die durch <tt>distance</tt> geliefert wird) definiert wurde, w&auml;hrend <tt>unit</tt>
die Grid-Einheit liefert, die f&uuml;r die Anzeige von Werten und die Umrechnung von
Benutzereingaben verwendet wird.
<h2>Beispiel</h2>
<pre>
board(B) {
  printf("Gridsize=%f\n", B.grid.distance);
  }
</pre>


<a name=195>
<h1>UL_HOLE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>diameter[layer]</tt> </td><td width=20><td><a href=#172>int</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>drill</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>drillsymbol</tt>  </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Mittelpunkt)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#204>UL_PACKAGE</a>
<h2>Anmerkung</h2>
<tt>diameter[]</tt> ist nur f&uuml;r die Layer <tt>LAYER_TSTOP</tt> und <tt>LAYER_BSTOP</tt> definiert
und liefert den Durchmesser der L&ouml;tstopmaske im jeweiligen Layer.
<p>
<tt>drillsymbol</tt> liefert die Nummer des Bohrsymbols, welches diesem Bohrdurchmesser
zugeordnet worden ist (siehe die Liste der definierten Bohrsymbole im Handbuch).
Ein Wert von <tt>0</tt> bedeutet, dass diesem Bohrdurchmesser kein Bohrsymbol zugeordnet ist.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.holes(H) {
    printf("Hole: (%f %f), drill=%f\n",
           u2mm(H.x), u2mm(H.y), u2mm(H.drill));
    }
  }
</pre>


<a name=196>
<h1>UL_INSTANCE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#173>real</a> (<tt>0</tt>, <tt>90</tt>, <tt>180</tt> und <tt>270</tt>)</td></tr>
<tr><td><tt>column</tt>       </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>gate</tt>         </td><td width=20><td><a href=#193>UL_GATE</a></td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>INSTANCE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>part</tt>         </td><td width=20><td><a href=#206>UL_PART</a></td></tr>
<tr><td><tt>row</tt>          </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>sheet</tt>        </td><td width=20><td><a href=#172>int</a> (0=unbenutzt, &gt;0=Seitennummer)</td></tr>
<tr><td><tt>smashed</tt>      </td><td width=20><td><a href=#172>int</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#174>string</a> (<tt>PART_VALUE_LENGTH</tt>)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Aufh&auml;ngepunkt)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#180>UL_ATTRIBUTE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>xrefs()</tt>      </td><td width=20><td><a href=#193>UL_GATE</a> (siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#208>UL_PINREF</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>INSTANCE_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Instance-Namen (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
<tr><td><tt>PART_VALUE_LENGTH</tt>      </td><td width=20><td>max. empfohlene L&auml;nge eines Bauteil-Values (Instances haben keinen eigenen Value!)</td></tr>
</table>
<h2>Anmerkung</h2>
Das <tt>attributes()</tt>-Member l&auml;uft nur durch die Attribute, die explizit dieser
Instance zugewiesen wurden (einschlie&szlig;lich <i>gesmashter</i> Attribute).
<p>
Das <tt>texts()</tt>-Member l&auml;uft nur durch die mittels <a href=#100><b>SMASH</b></a>
von der Instance losgel&ouml;sten Texte, und durch die sichtbaren Texte der Attribute, die dieser Instance zugewiesen wurden.
Um alle Texte einer Instance zu bearbeiten, m&uuml;ssen Sie eine Schleife
durch das <tt>texts()</tt>-Member der Instance selbst und
durch das <tt>texts()</tt>-Member des zu dem Gate der Instance geh&ouml;renden
<a href=#218>Symbols</a> bilden.
Wurden einer Instance Attribute zugewiesen, so liefert <tt>texts()</tt> deren Texte
so, wie sie momentan dargestellt werden.
<p>
Die <tt>column</tt>- und <tt>row</tt>-Members liefern die Spalten- bzw. Zeilenposition
innerhalb des <a href=#192>Rahmens</a> auf der Schaltplanseite, auf der diese
Instance platziert ist.
Falls es auf dieser Seite keinen Rahmen gibt, oder die Instance au&szlig;erhalb des Rahmens liegt,
wird ein <tt>'?'</tt> (Fragezeichen) zur&uuml;ckgegeben.
Diese Members k&ouml;nnen nur in einem UL_SHEET-Kontext verwendet werden.
<p>
Das <tt>smashed</tt>-Member gibt Auskunft dar&uuml;ber, ob eine Instance gesmasht ist.
Diese Funktion kann auch verwendet werden um herauszufinden, ob es einen losgel&ouml;sten
Platzhaltertext gibt, indem der Name des Platzhalters in eckigen Klammern angegeben
wird, wie in <tt>smashed["VALUE"]</tt>. Dies ist n&uuml;tzlich falls Sie einen solchen Text
mit dem <a href=#71>MOVE</a>-Befehl etwa durch <tt>MOVE R5&gt;VALUE</tt>
selektieren wollen. G&uuml;ltige Platzhalternamen sind "NAME", "VALUE", "PART" und "GATE", sowie die
Namen etwaiger benutzerdefinierter <a href=#180>Attribute</a>.
Gro&szlig;-/Kleinschreibung spielt keine Rolle, und sie d&uuml;rfen ein vorangestelltes
<tt>'&gt;'</tt> Zeichen haben.
<p>
Das <tt>xrefs()</tt>-Member l&auml;uft durch die Gatter des <a href=#143>Kontaktspiegels</a>
dieser Instance. Diese sind nur dann von Bedeutung, wenn das ULP eine zeichnerische
Darstellung des Schaltplans erzeugt (wie etwa eine DXF-Datei).
<h2>Beispiel</h2>
<pre>
schematic(S) {
  S.parts(P) {
    printf("Part: %s\n", P.name);
    P.instances(I) {
      if (I.sheet != 0)
         printf("\t%s used on sheet %d\n", I.name, I.sheet);
      }
    }
  }
</pre>


<a name=197>
<h1>UL_JUNCTION</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>diameter</tt>     </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Mittelpunkt)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#214>UL_SEGMENT</a>
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    SH.nets(N) {
      N.segments(SEG) {
        SEG.junctions(J) {
          printf("Junction: (%f %f)\n", u2mm(J.x), u2mm(J.y));
          }
        }
      }
    }
  }
</pre>


<a name=198>
<h1>UL_LABEL</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#173>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>spin</tt>         </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>text</tt>         </td><td width=20><td><a href=#219>UL_TEXT</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Aufh&auml;ngepunkt)</td></tr>
<tr><td><tt>xref</tt>         </td><td width=20><td><a href=#172>int</a> (0=normal, 1=Querverweis)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a> (siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#214>UL_SEGMENT</a>
<h2>Anmerkung</h2>
Falls <tt>xref</tt> ungleich 0 ist, l&auml;uft das <tt>wires()</tt> Loop member durch die
Wires, aus denen die Umrandung des Querverweis-Labels besteht. Ansonsten ist die
Schleife leer.
<p>
Die <tt>angle</tt>, <tt>layer</tt>, <tt>mirror</tt> und <tt>spin</tt> Members liefern
immer den selben Wert wie diejenigen des UL_TEXT-Objekts, das vom <tt>text</tt> Member
geliefert wird. Die <tt>x</tt> und <tt>y</tt> Members des Textes liefern etwas versetzte
Werte f&uuml;r Querverweis-Labels <tt>xref</tt> ungleich 0), ansonsten liefern sie die
gleichen Werte wie das UL_LABEL.
<p>
<tt>xref</tt> hat nur f&uuml;r Netz-Labels eine Bedeutung. F&uuml;r Bus-Labels liefert es immer 0.
<h2>Beispiel</h2>
<pre>
sheet(SH) {
  SH.nets(N) {
    N.segments(S) {
      S.labels(L) {
        printf("Label: (%f %f) '%s'", u2mm(L.x), u2mm(L.y), L.text.value);
        }
      }
    }
  }
</pre>


<a name=199>
<h1>UL_LAYER</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>color</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>fill</tt>         </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>LAYER_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>number</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>used</tt>         </td><td width=20><td><a href=#172>int</a> (0=unbenutzt, 1=benutzt)</td></tr>
<tr><td><tt>visible</tt>      </td><td width=20><td><a href=#172>int</a> (0=off, 1=on)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#200>UL_LIBRARY</a>,
<a href=#213>UL_SCHEMATIC</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>LAYER_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Layer-Namens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
<tr><td><tt>LAYER_TOP</tt>  </td><td width=20><td>Layer-Nummern</td></tr>
<tr><td><tt>LAYER_BOTTOM</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_PADS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_VIAS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_UNROUTED</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_DIMENSION</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TPLACE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BPLACE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TORIGINS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BORIGINS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TNAMES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BNAMES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TVALUES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BVALUES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TSTOP</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BSTOP</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TCREAM</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BCREAM</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TFINISH</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BFINISH</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TGLUE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BGLUE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TTEST</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BTEST</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TKEEPOUT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BKEEPOUT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TRESTRICT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BRESTRICT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_VRESTRICT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_DRILLS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_HOLES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_MILLING</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_MEASURES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_DOCUMENT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_REFERENCE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TDOCU</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BDOCU</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_NETS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BUSSES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_PINS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_SYMBOLS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_NAMES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_VALUES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_INFO</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_GUIDE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_USER</tt>  </td><td width=20><td>niedrigste Nummer f&uuml;r benutzerdefinierte Layer (100)</td></tr>
</table>
<h2>Beispiel</h2>
<pre>
board(B) {
  B.layers(L) printf("Layer %3d %s\n", L.number, L.name);
  }
</pre>


<a name=200>
<h1>UL_LIBRARY</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>grid</tt>         </td><td width=20><td><a href=#194>UL_GRID</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>LIBRARY_NAME_LENGTH</tt>, siehe Anmerkung)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>devices()</tt>    </td><td width=20><td><a href=#187>UL_DEVICE</a></td></tr>
<tr><td><tt>devicesets()</tt> </td><td width=20><td><a href=#188>UL_DEVICESET</a></td></tr>
<tr><td><tt>layers()</tt>     </td><td width=20><td><a href=#199>UL_LAYER</a></td></tr>
<tr><td><tt>packages()</tt>   </td><td width=20><td><a href=#204>UL_PACKAGE</a></td></tr>
<tr><td><tt>symbols()</tt>    </td><td width=20><td><a href=#218>UL_SYMBOL</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#213>UL_SCHEMATIC</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>LIBRARY_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Bibliotheksnamens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<p>
Das <tt>devices()</tt>-Member geht durch alle Package-Varianten und Technologien von
UL_DEVICESET in der Bibliothek, so dass alle m&ouml;glichen Device-Variationen verf&uuml;gbar werden.
Das <tt>devicesets()</tt>-Member geht nur durch die UL_DEVICESETs, die wiederum nach deren
UL_DEVICE-Member abgefragt werden k&ouml;nnen.
<h2>Anmerkung</h2>
Das <tt>description</tt>-Member liefert den vollst&auml;ndigen Beschreibungstext, der mit dem
<a href=#45>DESCRIPTION</a>-Befehl erzeugt wurde, w&auml;hrend das <tt>headline</tt>-Member
nur die erste Zeile der Beschreibung ohne <a href=#370>HTML</a>-Tags ausgibt.
Wenn Sie den <tt>description</tt>-Text benutzen, denken Sie daran, dass dieser Newline-Anweisungen (<tt>'\n'</tt>) enthalten darf.
Die <tt>description</tt> und <tt>headline</tt> Texte stehen nur direkt innerhalb einer Library-Zeichnung
zur Verf&uuml;gung, nicht wenn die Bibliothek aus einem UL_BOARD- oder UL_SCHEMATIC-Kontext heraus angesprochen wird.
<p>
Wird die Bibliothek aus einem UL_BOARD- oder UL_SCHEMATIC-Kontext heraus angesprochen, liefert <tt>name</tt>
den reinen Bibliotheksnamen (ohne Extension). Ansonsten wird der volle Dateiname ausgegeben.
<h2>Beispiel</h2>
<pre>
library(L) {
  L.devices(D)     printf("Dev: %s\n", D.name);
  L.devicesets(D)  printf("Dev: %s\n", D.name);
  L.packages(P)    printf("Pac: %s\n", P.name);
  L.symbols(S)     printf("Sym: %s\n", S.name);
  }
schematic(S) {
  S.libraries(L) printf("Library: %s\n", L.name);
  }
</pre>


<a name=201>
<h1>UL_MODULE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>dx, dy</tt>       </td><td width=20><td><a href=#172>int</a> (size)</td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>prefix</tt>       </td><td width=20><td><a href=#174>string</a></td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>parts()</tt>      </td><td width=20><td><a href=#206>UL_PART</a></td></tr>
<tr><td><tt>ports()</tt>      </td><td width=20><td><a href=#210>UL_PORT</a></td></tr>
<tr><td><tt>sheets()</tt>     </td><td width=20><td><a href=#215>UL_SHEET</a></td></tr>
<tr><td><tt>variantdefs()</tt></td><td width=20><td><a href=#220>UL_VARIANTDEF</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#210>UL_PORT</a>,
<a href=#213>UL_SCHEMATIC</a>
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.modules(M) {
    M.parts(P) printf("Part: %s\n", P.name);
    }
  }
</pre>


<a name=202>
<h1>UL_MODULEINST</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#173>real</a> (<tt>0</tt>, <tt>90</tt>, <tt>180</tt> und <tt>270</tt>)</td></tr>
<tr><td><tt>column</tt>       </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>module</tt>       </td><td width=20><td><a href=#201>UL_MODULE</a></td></tr>
<tr><td><tt>modulevariant</tt></td><td width=20><td><a href=#174>string</a> (gew&auml;hlte Best&uuml;ckungsvariante des Moduls)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>INSTANCE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>offset</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>row</tt>          </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>sheet</tt>        </td><td width=20><td><a href=#172>int</a> (Seitennummer)</td></tr>
<tr><td><tt>smashed</tt>      </td><td width=20><td><a href=#172>int</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Aufh&auml;ngepunkt)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#211>UL_PORTREF</a>,
<a href=#220>UL_VARIANTDEF</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>INSTANCE_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Instance-Namen (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Das <tt>texts</tt> Loop-Member liefert alle sichtbaren Texte der Modul-Instanz
(ob <tt>smashed</tt> oder nicht spielt hier keine Rolle).
<p>
Die <tt>column</tt>- und <tt>row</tt>-Members liefern die Spalten- bzw. Zeilenposition
innerhalb des <a href=#192>Rahmens</a> auf der Schaltplanseite, auf der diese
Instanz platziert ist.
Falls es auf dieser Seite keinen Rahmen gibt, oder die Instanz au&szlig;erhalb des Rahmens liegt,
wird ein <tt>'?'</tt> (Fragezeichen) zur&uuml;ckgegeben.
Diese Members k&ouml;nnen nur in einem UL_SHEET-Kontext verwendet werden.
<p>
Das <tt>smashed</tt>-Member gibt Auskunft dar&uuml;ber, ob eine Instanz gesmasht ist.
Diese Funktion kann auch verwendet werden um herauszufinden, ob es einen losgel&ouml;sten
Platzhaltertext gibt, indem der Name des Platzhalters in eckigen Klammern angegeben
wird, wie in <tt>smashed["NAME"]</tt>. Dies ist n&uuml;tzlich falls Sie einen solchen Text
mit dem <a href=#71>MOVE</a>-Befehl etwa durch <tt>MOVE R5&gt;NAME</tt>
selektieren wollen.
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    SH.moduleinsts(MI) {
      printf("Module instance %s is located on sheet %d\n", MI.name, MI.sheet);
      }
    }
  }
</pre>


<a name=203>
<h1>UL_NET</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>class</tt>        </td><td width=20><td><a href=#184>UL_CLASS</a></td></tr>
<tr><td><tt>column</tt>       </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>NET_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>row</tt>          </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>pinrefs()</tt>    </td><td width=20><td><a href=#208>UL_PINREF</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>portrefs()</tt>   </td><td width=20><td><a href=#211>UL_PORTREF</a></td></tr>
<tr><td><tt>segments()</tt>   </td><td width=20><td><a href=#214>UL_SEGMENT</a> (siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#215>UL_SHEET</a>,
<a href=#213>UL_SCHEMATIC</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>NET_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Netznamens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Das Loop member <tt>pinrefs()</tt> kann nur benutzt werden, wenn das
Net innerhalb eines UL_SCHEMATIC-Kontexts verwendet wird.<br>
Das Loop member <tt>segments()</tt> kann nur benutzt werden,
wenn das Net innerhalb eines UL_SHEET-Kontexts verwendet wird.
<p>
Die <tt>column</tt>- und <tt>row</tt>-Members liefern die Spalten- bzw. Zeilenpositionen
innerhalb des <a href=#192>Rahmens</a> auf der Schaltplanseite, auf der dieses Netz
liegt. Da ein Netz sich &uuml;ber einen bestimmten Bereich erstrecken kann, liefert jede dieser
Funktionen zwei durch ein Leerzeichen getrennte Werte zur&uuml;ck. Im Falle von <tt>column</tt>
sind die die am weitesten links bzw. rechts liegende Spalte, die von diesem Netz ber&uuml;hrt wird,
und bei <tt>row</tt> ist es die am weitesten oben bzw. unten liegende Zeile.
<p>
Bei der Ermittlung der Spalte und Zeile eines Netzes auf einer Schaltplanseite
wird zun&auml;chst die Spalte und dann die Zeile innerhalb dieser Spalte betrachtet.
Hierbei haben XREF-Labels Vorrang vor normalen Labels, und diese wiederum Vorrang
vor Netz-Wires.
<p>
Falls es auf dieser Seite keinen Rahmen gibt, wird <tt>"? ?"</tt> (zwei Fragezeichen) zur&uuml;ckgegeben.
Liegt irgend ein Punkt des Netzes au&szlig;erhalb des Rahmens, so kann jeder der Werte <tt>'?'</tt>
(Fragezeichen) sein.
Diese Members k&ouml;nnen nur in einem UL_SHEET-Kontext verwendet werden.
<h2>Beispiel</h2>
<pre>
schematic(S) {
  S.nets(N) {
    printf("Net: %s\n", N.name);
    // N.segments(SEG) will NOT work here!
    }
  }
schematic(S) {
  S.sheets(SH) {
    SH.nets(N) {
      printf("Net: %s\n", N.name);
      N.segments(SEG) {
        SEG.wires(W) {
          printf("\tWire: (%f %f) (%f %f)\n",
                 u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2));
          }
        }
      }
    }
  }
</pre>


<a name=204>
<h1>UL_PACKAGE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#179>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>library</tt>      </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>PACKAGE_NAME_LENGTH</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#183>UL_CIRCLE</a></td></tr>
<tr><td><tt>contacts()</tt>   </td><td width=20><td><a href=#185>UL_CONTACT</a></td></tr>
<tr><td><tt>dimensions()</tt> </td><td width=20><td><a href=#189>UL_DIMENSION</a></td></tr>
<tr><td><tt>frames()</tt>     </td><td width=20><td><a href=#192>UL_FRAME</a></td></tr>
<tr><td><tt>holes()</tt>      </td><td width=20><td><a href=#195>UL_HOLE</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#209>UL_POLYGON</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>rectangles()</tt> </td><td width=20><td><a href=#212>UL_RECTANGLE</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a> (siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#187>UL_DEVICE</a>,
<a href=#190>UL_ELEMENT</a>,
<a href=#200>UL_LIBRARY</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PACKAGE_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Package-Namens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Das <tt>description</tt>-Member liefert den vollst&auml;ndigen Beschreibungstext, der mit dem
<a href=#45>DESCRIPTION</a>-Befehl erzeugt wurde, w&auml;hrend das <tt>headline</tt>-Member
nur die erste Zeile der Beschreibung ohne <a href=#370>HTML</a>-Tags ausgibt.
Wenn Sie <tt>description</tt>-Text schreiben, denken Sie daran, dass dieser Newline-Anweisungen (<tt>'\n'</tt>) enthalten darf.
<p>
Stammt das UL_PACKAGE aus einem UL_ELEMENT-Kontext, so durchl&auml;uft das <tt>texts()</tt>-Member
nur die nicht losgel&ouml;sten Texte dieses Elements.
<p>
Stammt das UL_PACKAGE aus einem UL_ELEMENT-Kontext, sind Polygone und Wires, die zu einem Kontakt mit beliebiger Pad-Form
geh&ouml;ren, nur durch die Loop-Member <tt>polygons()</tt> und <tt>wires()</tt> dieses Kontakts verf&uuml;gbar.
<h2>Beispiel</h2>
<pre>
library(L) {
  L.packages(PAC) {
    printf("Package: %s\n", PAC.name);
    PAC.contacts(C) {
      if (C.pad)
         printf("\tPad: %s, (%f %f)\n",
                 C.name, u2mm(C.pad.x), u2mm(C.pad.y));
      else if (C.smd)
         printf("\tSmd: %s, (%f %f)\n",
                 C.name, u2mm(C.smd.x), u2mm(C.smd.y));
      }
    }
  }
board(B) {
  B.elements(E) {
    printf("Element: %s, Package: %s\n", E.name, E.package.name);
    }
  }
</pre>


<a name=205>
<h1>UL_PAD</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#173>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>diameter[layer]</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>drill</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>drillsymbol</tt>  </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>elongation</tt>   </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>flags</tt>        </td><td width=20><td><a href=#172>int</a> (<tt>PAD_FLAG_...</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>PAD_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>shape[layer]</tt> </td><td width=20><td><a href=#172>int</a> (<tt>PAD_SHAPE_...</tt>)</td></tr>
<tr><td><tt>signal</tt>       </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Mittelpunkt, siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#204>UL_PACKAGE</a>,
<a href=#185>UL_CONTACT</a>,
<a href=#217>UL_SMD</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PAD_FLAG_STOP</tt>   </td><td width=20><td>L&ouml;tstopmaske generieren</td></tr>
<tr><td><tt>PAD_FLAG_THERMALS</tt>         </td><td width=20><td>Thermals generieren</td></tr>
<tr><td><tt>PAD_FLAG_FIRST</tt>            </td><td width=20><td>spezielle Form f&uuml;r "erstes Pad" verwenden</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PAD_SHAPE_SQUARE</tt>   </td><td width=20><td>square</td></tr>
<tr><td><tt>PAD_SHAPE_ROUND</tt>    </td><td width=20><td>round</td></tr>
<tr><td><tt>PAD_SHAPE_OCTAGON</tt>  </td><td width=20><td>octagon</td></tr>
<tr><td><tt>PAD_SHAPE_LONG</tt>     </td><td width=20><td>long</td></tr>
<tr><td><tt>PAD_SHAPE_OFFSET</tt>   </td><td width=20><td>offset</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PAD_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Pad-Namens (identisch mit <tt>CONTACT_NAME_LENGTH</tt>)</td></tr>
</table>
<h2>Anmerkung</h2>
Die Parameter des Pads h&auml;ngen vom Kontext ab in dem es angesprochen wird:
<ul>
<li>Wird das Pad aus einem UL_LIBRARY-Kontext angesprochen, sind die Koordinaten (<tt>x, y</tt>) und der Winkel (<tt>angle</tt>) dieselben, wie
in der Package-Zeichnung
<li>In allen anderen F&auml;llen gelten die aktuellen Werte vom Board
</ul>
<p>
Durchmesser und Form des Pads h&auml;ngen vom Layer ab f&uuml;r den es erzeugt werden soll, da diese Werte,
abh&auml;ngig von den <a href=#139>Design Rules</a>, unterschiedlich sein k&ouml;nnen.
Wird als Index f&uuml;r das Data Member "diameter" oder "shape" einer der <a href=#199>Layer</a>
LAYER_TOP...LAYER_BOTTOM, LAYER_TSTOP oder LAYER_BSTOP angegeben, berechnet sich der Wert nach den
Vorgaben der Design Rules. Gibt man LAYER_PADS an, wird der in der Bibliothek definierte Wert
verwendet.
<p>
<tt>drillsymbol</tt> liefert die Nummer des Bohrsymbols, welches diesem Bohrdurchmesser
zugeordnet worden ist (siehe die Liste der definierten Bohrsymbole im Handbuch).
Ein Wert von <tt>0</tt> bedeutet, dass diesem Bohrdurchmesser kein Bohrsymbol zugeordnet ist.
<p>
<tt>angle</tt> gibt an um wieviel Grad das Pad gegen den Uhrzeigersinn um seinen
Mittelpunkt gedreht ist.
<p>
<tt>elongation</tt> ist nur f&uuml;r die Pad-Formen PAD_SHAPE_LONG und PAD_SHAPE_OFFSET g&uuml;ltig
und bestimmt um wieviel Prozent die lange Seite eines solchen Pads l&auml;nger ist als
seine schmale Seite. F&uuml;r alle anderen Pad-Formen liefert dieses Member den Wert 0.
<p>
Der Wert, den <tt>flags</tt> liefert, muss mit den <tt>PAD_FLAG_...</tt> Konstanten
maskiert werden um die einzelnen Flag-Einstellungen zu ermitteln, wie zum Beispiel in
<pre>
if (pad.flags &amp; PAD_FLAG_STOP) {
   ...
   }
</pre>
Falls Ihr ULP lediglich die Objekte darstellen soll, brauchen Sie sich nicht
explizit um diese Flags zu k&uuml;mmern. Die <tt>diameter[]</tt> und <tt>shape[]</tt>
Members liefern die richtigen Daten; ist zum Beispiel <tt>PAD_FLAG_STOP</tt>
gesetzt, so liefert <tt>diameter[LAYER_TSTOP]</tt> den Wert <tt>0</tt>, was
zur Folge haben sollte, dass in diesem Layer nichts gezeichnet wird.
Das <tt>flags</tt> Member ist haupts&auml;chlich f&uuml;r ULPs gedacht, die Script-Dateien
erzeugen mit denen Bibliotheksobjekte kreiert werden.
<h2>Beispiel</h2>
<pre>
library(L) {
  L.packages(PAC) {
    PAC.contacts(C) {
      if (C.pad)
         printf("Pad: '%s', (%f %f), d=%f\n",
                 C.name, u2mm(C.pad.x), u2mm(C.pad.y), u2mm(C.pad.diameter[LAYER_BOTTOM]));
      }
    }
  }
</pre>


<a name=206>
<h1>UL_PART</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attribute[]</tt>  </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>device</tt>       </td><td width=20><td><a href=#187>UL_DEVICE</a></td></tr>
<tr><td><tt>deviceset</tt>    </td><td width=20><td><a href=#188>UL_DEVICESET</a></td></tr>
<tr><td><tt>module</tt>       </td><td width=20><td><a href=#201>UL_MODULE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>modulepart</tt>   </td><td width=20><td>UL_PART (siehe Anmerkung)</td></tr>
<tr><td><tt>modulepath</tt>   </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>PART_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>populate</tt>     </td><td width=20><td><a href=#172>int</a> (0=do not populate, 1=populate)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#174>string</a> (<tt>PART_VALUE_LENGTH</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#180>UL_ATTRIBUTE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>instances()</tt>  </td><td width=20><td><a href=#196>UL_INSTANCE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>variants()</tt>   </td><td width=20><td><a href=#221>UL_VARIANT</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#213>UL_SCHEMATIC</a>,
<a href=#215>UL_SHEET</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PART_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Part-Namens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
<tr><td><tt>PART_VALUE_LENGTH</tt>  </td><td width=20><td>max. empfohlene L&auml;nge eines Part-Values (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Mit dem <tt>attribute[]</tt>-Member kann man ein UL_PART nach dem Wert eines
bestimmten Attributs fragen (siehe das zweite Beispiel). Der zur&uuml;ckgelieferte
String ist leer, wenn es kein Attribut mit dem angegebenen Namen gibt, oder
wenn dieses Attribut explizit leer ist.
<p>
Beim Durchlaufen der <tt>attributes()</tt> eines UL_PART haben nur die
<tt>name</tt>, <tt>value</tt>, <tt>defaultvalue</tt> und <tt>constant</tt>
Members des resultierenden UL_ATTRIBUTE g&uuml;ltige Werte.
<p>
Wenn sich Part in einem UL_SHEET-Kontext befindet, bearbeitet
Loop member <tt>instances()</tt> nur solche Instances, die tats&auml;chlich
auf dieser Seite benutzt werden.
Wenn sich Part in einem UL_SCHEMATIC- oder UL_MODULE-Kontext befindet, geht die Schleife
durch alle Instances.
<p>
Wenn das Part ein <i>virtuelles</i> Part ist (virtuelle Parts k&ouml;nnen mit <tt>UL_SCHEMATIC.allparts()</tt>
ermittelt werden, siehe <a href=#213>UL_SCHEMATIC</a>), so ist <tt>instances()</tt> leer.
<p>
Wenn das Part von einem Modul stammt oder virtuell ist, bezieht sich <tt>module</tt> darauf.
Wenn nicht (Part im Hauptschaltplan), ist <tt>module</tt> Null.
<p>
Wenn das Part virtuell ist, so ist <tt>modulepart</tt> das entsprechende reale Part vom Herkunfts-Modul <tt>module</tt>.
Ist es ein Part des Hauptschaltplans oder ist es selbst ein Part aus einem Modul, so ist <tt>modulepart</tt> Null.
<p>
Wenn das Part virtuell ist, so ist <tt>modulepath</tt> ein String mit der Sequenz von Modul-Instanznamen,
die zu dem Modul f&uuml;hren, welches das benutzte Part enth&auml;lt. Diese Namen sind durch ':' getrennt.
In anderen F&auml;llen ist dieser String leer.<br>
Zum Beispiel hat ein virtuelles Part mit Namen 'MI1:R1' den <tt>modulepath</tt> 'MI1'.<br>
'R101', das von einer Modul-Instanz 'MX' mit Offset-Notation stammt, liefert <tt>modulepath</tt> 'MX'.<br>
'MAIN:SUB1:SUBSUB1:C5' hat <tt>modulepath</tt> 'MAIN:SUB1:SUBSUB1'.
<h2>Beispiele</h2>
<pre>
schematic(S) {
  S.parts(P) printf("Part: %s\n", P.name);
}
</pre>
<pre>
schematic(S) {
  S.allparts(P) {
    if (P.attribute["REMARK"])
       printf("%s: %s\n", P.name, P.attribute["REMARK"]);
    if (P.modulepart) {
       P.modulepart.instances(I)
         printf("%s is a virtual part from %s in module %s with part instance on sheet %d\n",
                P.name, P.modulepart.name, P.module.name, I.sheet);
    }
    else {
       P.instances(I)
         printf("%s is a part on main schematic with instance on sheet %d\n",
                P.name, I.sheet);
    }
  }
}
</pre>
<pre>
schematic(S) {
  S.allparts(P) {
    if (P.modulepart) {
       string miNames[];
       int nr = strsplit(miNames, P.modulepath, ':');
       if (nr == 1)
          printf("%s is a virtual part created by module instance %s in main schematic.\n",
                 P.name, miNames[0]);
       else {
          printf("%s is a virtual part in a multiple hierarchy created by this path of module instances:\n", P.name);
          for (int i = 0; i &lt; nr; ++i)
              printf("%s\n", miNames[i]);
       }
    }
  }
}
</pre>


<a name=207>
<h1>UL_PIN</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#173>real</a> (<tt>0</tt>, <tt>90</tt>, <tt>180</tt> und <tt>270</tt>)</td></tr>
<tr><td><tt>contact</tt>      </td><td width=20><td><a href=#185>UL_CONTACT</a> (veraltet, siehe Anmerkung)</td></tr>
<tr><td><tt>direction</tt>    </td><td width=20><td><a href=#172>int</a> (<tt>PIN_DIRECTION_...</tt>)</td></tr>
<tr><td><tt>function</tt>     </td><td width=20><td><a href=#172>int</a> (<tt>PIN_FUNCTION_FLAG_...</tt>)</td></tr>
<tr><td><tt>length</tt>       </td><td width=20><td><a href=#172>int</a> (<tt>PIN_LENGTH_...</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>PIN_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>net</tt>          </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>route</tt>        </td><td width=20><td><a href=#172>int</a> (<tt>CONTACT_ROUTE_...</tt>)</td></tr>
<tr><td><tt>swaplevel</tt>    </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>visible</tt>      </td><td width=20><td><a href=#172>int</a> (<tt>PIN_VISIBLE_FLAG_...</tt>)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Anschlusspunkt)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#183>UL_CIRCLE</a></td></tr>
<tr><td><tt>contacts()</tt>   </td><td width=20><td><a href=#185>UL_CONTACT</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#218>UL_SYMBOL</a>,
<a href=#208>UL_PINREF</a>,
<a href=#186>UL_CONTACTREF</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_DIRECTION_NC</tt>  </td><td width=20><td>Not connected</td></tr>
<tr><td><tt>PIN_DIRECTION_IN</tt>  </td><td width=20><td>Input</td></tr>
<tr><td><tt>PIN_DIRECTION_OUT</tt> </td><td width=20><td>Output (totem-pole)</td></tr>
<tr><td><tt>PIN_DIRECTION_IO</tt>  </td><td width=20><td>In/Output (bidirectional)</td></tr>
<tr><td><tt>PIN_DIRECTION_OC</tt>  </td><td width=20><td>Open Collector</td></tr>
<tr><td><tt>PIN_DIRECTION_PWR</tt> </td><td width=20><td>Power-Input-Pin</td></tr>
<tr><td><tt>PIN_DIRECTION_PAS</tt> </td><td width=20><td>Passiv</td></tr>
<tr><td><tt>PIN_DIRECTION_HIZ</tt> </td><td width=20><td>High-Impedance-Output</td></tr>
<tr><td><tt>PIN_DIRECTION_SUP</tt> </td><td width=20><td>Supply-Pin</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_FUNCTION_FLAG_NONE</tt>  </td><td width=20><td>kein Symbol</td></tr>
<tr><td><tt>PIN_FUNCTION_FLAG_DOT</tt>   </td><td width=20><td>Inverter-Symbol</td></tr>
<tr><td><tt>PIN_FUNCTION_FLAG_CLK</tt>   </td><td width=20><td>Taktsymbol</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_LENGTH_POINT</tt>  </td><td width=20><td>kein Wire</td></tr>
<tr><td><tt>PIN_LENGTH_SHORT</tt>  </td><td width=20><td>0.1-Inch-Wire</td></tr>
<tr><td><tt>PIN_LENGTH_MIDDLE</tt> </td><td width=20><td>0.2-Inch-Wire</td></tr>
<tr><td><tt>PIN_LENGTH_LONG</tt>   </td><td width=20><td>0.3-Inch-Wire</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Pin-Namens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_VISIBLE_FLAG_OFF</tt>   </td><td width=20><td>kein Name sichtbar</td></tr>
<tr><td><tt>PIN_VISIBLE_FLAG_PAD</tt>   </td><td width=20><td>Pad-Name sichtbar</td></tr>
<tr><td><tt>PIN_VISIBLE_FLAG_PIN</tt>   </td><td width=20><td>Pin-Name sichtbar</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CONTACT_ROUTE_ALL</tt>   </td><td width=20><td>alle Kontakte m&uuml;ssen explizit angeschlossen werden</td></tr>
<tr><td><tt>CONTACT_ROUTE_ANY</tt>   </td><td width=20><td>beliebige Kontakte k&ouml;nnen angeschlossen werden</td></tr>
</table>
<h2>Anmerkung</h2>
Das <tt>contacts()</tt> Loop Member geht durch die <a href=#185>Contacts</a>,
mit denen der Pin durch einen <a href=#41>CONNECT</a>-Befehl verbunden
worden ist.
Dies ist der Fall in einem UL_DEVICE-Kontext oder von UL_PINREF her kommend, nicht aber
&uuml;ber UL_LIBRARY.symbols(). Ist dies nicht der Fall, so ist die Liste leer.
<p>
Das <tt>contact</tt> Data Member liefert den <a href=#185>Contact</a>,
der dem Pin durch einen <a href=#41>CONNECT</a>-Befehl zugewiesen
worden ist.
<b><i>Dieses Member ist veraltet! Es funktioniert aus Kompatibilit&auml;tsgr&uuml;nden und
solange nur ein Pad mit dem Pin verbunden wurde, verursacht aber einen Laufzeitfehler
wenn es mit einem Pin benutzt wird, der mit mehreren Pads verbunden ist.</i></b>
<p>
Das Member <tt>route</tt> macht ebenfalls nur Sinn, wenn ein Bezug zu Kontakten vorhanden ist,
mit denen der Pin verbunden worden ist. Sonst ist der Wert auf 0 gesetzt.
<p>
Die Koordinaten (und der Layer, im Falle eines SMD) des durch das
<tt>contact</tt> Data Member gelieferten Contacts h&auml;ngen vom Kontext ab,
in dem es aufgerufen wird:
<ul>
<li>falls der Pin von einem UL_PART stammt, welches auf einer Schaltplanseite verwendet
wird, und wenn es ein dazugeh&ouml;riges Element im Board gibt, dann erh&auml;lt
der Contact die Koordinaten die er im Board hat
<li>in allen anderen F&auml;llen erh&auml;lt der Contact die Koordinaten wie sie
in der Package-Zeichnung definiert sind
</ul>
Das <tt>name</tt> Data Member liefert den Namen des Pins immer so, wie er in der Bibliothek
definiert wurde, einschlie&szlig;lich eines etwaigen <tt>'@'</tt>-Zeichens f&uuml;r Pins mit dem gleichen Namen
(siehe <a href=#79>PIN</a>-Befehl).<br>
Das <tt>texts</tt> Loop-Member dagegen liefert den Pin-Namen (sofern er sichtbar ist) immer
in der Form, wie er im aktuellen Zeichnungstyp dargestellt wird.
<p>
Das <tt>net</tt> Data Member liefert den Namen des Netzes, an das der Pin angeschlossen ist
(nur in einem UL_SCHEMATIC-Kontext verf&uuml;gbar).
<h2>Beispiel</h2>
<pre>
library(L) {
  L.symbols(S) {
    printf("Symbol: %s\n", S.name);
    S.pins(P) {
      printf("\tPin: %s, (%f %f)", P.name, u2mm(P.x), u2mm(P.y));
      if (P.direction == PIN_DIRECTION_IN)
         printf(" input");
      if ((P.function &amp; PIN_FUNCTION_FLAG_DOT) != 0)
         printf(" inverted");
      printf("\n");
      }
    }
  }
</pre>


<a name=208>
<h1>UL_PINREF</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>instance</tt>     </td><td width=20><td><a href=#196>UL_INSTANCE</a></td></tr>
<tr><td><tt>part</tt>         </td><td width=20><td><a href=#206>UL_PART</a></td></tr>
<tr><td><tt>pin</tt>          </td><td width=20><td><a href=#207>UL_PIN</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#214>UL_SEGMENT</a>,
<a href=#186>UL_CONTACTREF</a>
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    printf("Sheet: %d\n", SH.number);
    SH.nets(N) {
      printf("\tNet: %s\n", N.name);
      N.segments(SEG) {
        SEG.pinrefs(P) {
          printf("connected to: %s, %s, %s\n",
                 P.part.name, P.instance.name, P.pin.name);
          }
        }
      }
    }
  }
</pre>


<a name=209>
<h1>UL_POLYGON</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>isolate</tt>      </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>orphans</tt>      </td><td width=20><td><a href=#172>int</a> (0=off, 1=on)</td></tr>
<tr><td><tt>pour</tt>         </td><td width=20><td><a href=#172>int</a> (<tt>POLYGON_POUR_...</tt>)</td></tr>
<tr><td><tt>rank</tt>         </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>spacing</tt>      </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>thermals</tt>     </td><td width=20><td><a href=#172>int</a> (0=off, 1=on)</td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>contours()</tt>   </td><td width=20><td><a href=#223>UL_WIRE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>fillings()</tt>   </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#204>UL_PACKAGE</a>,
<a href=#215>UL_SHEET</a>,
<a href=#216>UL_SIGNAL</a>,
<a href=#218>UL_SYMBOL</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>POLYGON_POUR_SOLID</tt>   </td><td width=20><td>solid</td></tr>
<tr><td><tt>POLYGON_POUR_HATCH</tt>   </td><td width=20><td>hatch</td></tr>
<tr><td><tt>POLYGON_POUR_CUTOUT</tt>  </td><td width=20><td>cutout</td></tr>
</table>
<h2>Anmerkung</h2>
Die Loop-Member <tt>contours()</tt> und <tt>fillings()</tt> gehen durch alle Wires, mit
denen das Polygon gezeichnet wird, sofern es zu einem Signal geh&ouml;rt und mit
dem Befehl <a href=#86>RATSNEST</a> freigerechnet wurde.
Das Loop-Member <tt>wires()</tt> geht immer durch die Wires, die vom Benutzer gezeichnet
wurden. F&uuml;r nicht freigerechnete Signal-Polygone liefert <tt>contours()</tt> dasselbe
Ergebnis wie <tt>wires()</tt>. <tt>Fillings()</tt> hat dann keine Bedeutung.
<p>
Wird das <tt>contours()</tt> Loop-Member ohne einem zweiten Parameter aufgerufen,
so l&auml;uft es durch alle Umriss-Linien, egal ob sie zu einem positiven oder negativen
Polygon geh&ouml;ren. Falls Sie daran interessiert sind, die positiven und negativen
Umriss-Linien getrennt voneienander zu erhalten, k&ouml;nnen Sie <tt>contours()</tt>
mit einem zus&auml;tzlichen Integer-Parameter aufrufen (siehe zweites Beispiel unten).
Das Vorzeichen dieses Parameters bestimmt, ob ein positives oder negatives Polygon
behandelt wird, und der Wert gibt den Index dieses Polygons an. Falls es kein
Polygon mit dem gegebenen Index gibt, wird die Anweisung nicht ausgef&uuml;hrt.
Ein weiterer Vorteil dieser Methode ist, dass Sie Anfang und Ende eines bestimmten
Polygons nicht selber (durch Vergleich von Koordinaten) bestimmen m&uuml;ssen. F&uuml;r jeden
Index wird die Anweisung f&uuml;r alle Wires dieses Polygons ausgef&uuml;hrt.
Mit <tt>0</tt> als zweitem Parameter ist das Verhalten genau so, als w&auml;re kein
zweiter Parameter angegeben worden.
<h2>Polygon-Strichst&auml;rke</h2>
Wenn Sie das Loop-Member <tt>fillings()</tt> verwenden um die F&uuml;ll-Linien
des Polygons zu erreichen, stellen Sie sicher, dass die Strichst&auml;rke
<i>width</i> des Polygons nicht null ist (sie sollte etwas &uuml;ber null liegen,
bzw. mindestens der Aufl&ouml;sung des Ausgabetreibers mit dem Sie die Zeichnung ausgeben
wollen entsprechen).
<b>Zeichnen Sie ein Polygon mit Strichst&auml;rke = 0, ergibt sich eine riesige Datenmenge, da
das Polygon mit der kleinsten Editor-Aufl&ouml;sung von 1/320000mm berechnet wird. </b>
<h2>Teilpolygone</h2>
Ein berechnetes Polygon kann aus verschiedenen getrennten Teilen (<i>positive</i>Polygone
genannt) bestehen, wobei jedes davon Aussparungen (<i>negative</i> Polygone genannt)
enthalten kann, die von anderen Objekten, die vom Polygon subtrahiert werden,
herr&uuml;hren. Negative Polygone k&ouml;nnen wiederum weitere positive Polygone enthalten
und so weiter.
<p>
Die Wires, die mit <tt>contours()</tt> erreicht werden, beginnen immer in einem
positiven Polygon. Um herauszufinden wo ein Teilpolygon endet und das n&auml;chste beginnt,
speichern Sie einfach die Koordinate (x1,y1) des ersten Wires und pr&uuml;fen diese
gegen&uuml;ber (x2,y2) jedes folgenden Wires. Sobald die beiden Werte identisch sind,
ist der letzte Wire des Teilpolygons gefunden. Es gilt immer, dass
der zweite Punkt (x2,y2) identisch mit dem ersten Punkt (x1,y1) des n&auml;chsten Wires
in diesem Teilpolygon ist.
<p>
Um herauszufinden ob man innerhalb bzw. ausserhalb der Polygons ist, nehmen
Sie einen beliebigen Umriss-Wire und stellen sich Sie vor, von dessen Punkt (x1,y1)
zum Punkt (x2,y2) zu sehen. Rechts vom Wire ist immer innerhalb des Polygons.
Hinweis: Wenn Sie einfach ein Polygon zeichnen wollen, brauchen Sie all
diese Details nicht.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.signals(S) {
    S.polygons(P) {
      int x0, y0, first = 1;
      P.contours(W) {
        if (first) {
           // a new partial polygon is starting
           x0 = W.x1;
           y0 = W.y1;
           }
        // ...
        // do something with the wire
        // ...
        if (first)
           first = 0;
        else if (W.x2 == x0 &amp;&amp; W.y2 == y0) {
           // this was the last wire of the partial polygon,
           // so the next wire (if any) will be the first wire
           // of the next partial polygon
           first = 1;
           }
        }
      }
    }
  }
</pre>
<p>
<pre>
board(B) {
  B.signals(S) {
    S.polygons(P) {
      // handle only the "positive" polygons:
      int i = 1;
      int active;
      do {
         active = 0;
         P.contours(W, i) {
           active = 1;
           // do something with the wire
           }
         i++;
         } while (active);
      }
    }
  }
</pre>


<a name=210>
<h1>UL_PORT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>border</tt>       </td><td width=20><td><a href=#172>int</a> (<tt>MODULE_BORDER_...</tt>)</td></tr>
<tr><td><tt>bus</tt>          </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>direction</tt>    </td><td width=20><td><a href=#172>int</a> (<tt>PIN_DIRECTION_... (siehe Anmerkung)</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>PORT_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>net</tt>          </td><td width=20><td><a href=#174>string</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Anschlusspunkt)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>nets()</tt>       </td><td width=20><td><a href=#203>UL_NET</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#201>UL_MODULE</a>,
<a href=#202>UL_MODULEINST</a>,
<a href=#211>UL_PORTREF</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>MODULE_BORDER_BOTTOM</tt>    </td><td width=20><td>am unteren Rand des Modul-Rahmens</td></tr>
<tr><td><tt>MODULE_BORDER_RIGHT</tt>     </td><td width=20><td>am rechten Rand des Modul-Rahmens</td></tr>
<tr><td><tt>MODULE_BORDER_TOP</tt>       </td><td width=20><td>am oberen Rand des Modul-Rahmens</td></tr>
<tr><td><tt>MODULE_BORDER_LEFT</tt>      </td><td width=20><td>am linken Rand des Modul-Rahmens</td></tr>
<tr><td><tt>PORT_NAME_LENGTH</tt>        </td><td width=20><td>max. empfohlene L&auml;nge eines Portnamens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Die Konstanten von <tt>direction</tt> sind identisch mit denen von PIN_DIRECTION_... (allerdings
gibt es bei einem Port kein PIN_DIRECTION_SUP).
<p>
Die Member <tt>bus</tt> und <tt>net</tt> liefern den Namen des Busses bzw. Netzes, an welchem
der Port angeschlossen ist (nur im UL_MODULEINST-Kontext verf&uuml;gbar).
Zus&auml;tzlich geht das Loop-Member <tt>nets</tt> durch alle vorhandenen Netze dieser
Verbindung.
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.modules(M) {
    M.ports(P) printf("Port: %s\n", P.name);
    }
  }
</pre>


<a name=211>
<h1>UL_PORTREF</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>moduleinst</tt>   </td><td width=20><td><a href=#202>UL_MODULEINST</a></td></tr>
<tr><td><tt>port</tt>         </td><td width=20><td><a href=#210>UL_PORT</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#214>UL_SEGMENT</a>
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    printf("Sheet: %d\n", SH.number);
    SH.nets(N) {
      printf("\tNet: %s\n", N.name);
      N.segments(SEG) {
        SEG.portrefs(P) {
          printf("\tconnected to: %s, %s\n",
                 P.moduleinst.name, P.port.name);
          }
        }
      }
    }
  }
</pre>


<a name=212>
<h1>UL_RECTANGLE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#173>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#172>int</a> (linke untere Ecke)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#172>int</a> (rechte obere Ecke)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#204>UL_PACKAGE</a>,
<a href=#215>UL_SHEET</a>,
<a href=#218>UL_SYMBOL</a>
<p>
Die Koordinaten (x1 y1) und (x2 y2) beziehen sich immer auf die urspr&uuml;ngliche Lage des Rechtecks
ohne die Rotation zu ber&uuml;cksichtigen.
<p>
<tt>angle</tt> gibt an um wieviel Grad das Rechteck gegen den Uhrzeigersinn um seinen
Mittelpunkt gedreht ist. Der Mittelpunkt ergibt sich aus <tt>(x1+x2)/2</tt> und <tt>(y1+y2)/2</tt>.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.rectangles(R) {
    printf("Rectangle: (%f %f), (%f %f)\n",
           u2mm(R.x1), u2mm(R.y1), u2mm(R.x2), u2mm(R.y2));
    }
  }
</pre>


<a name=213>
<h1>UL_SCHEMATIC</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>alwaysvectorfont</tt></td><td width=20><td><a href=#172>int</a> (<tt>ALWAYS_VECTOR_FONT_..., siehe Anmerkung</tt>)</td></tr>
<tr><td><tt>checked</tt>      </td><td width=20><td><a href=#172>int</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>grid</tt>         </td><td width=20><td><a href=#194>UL_GRID</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a>  (siehe Anmerkung)</td></tr>
<tr><td><tt>verticaltext</tt></td><td width=20><td><a href=#172>int</a> (<tt>VERTICAL_TEXT_...</tt>)</td></tr>
<tr><td><tt>xreflabel</tt>    </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>xrefpart</tt>     </td><td width=20><td><a href=#174>string</a></td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>allparts()</tt>   </td><td width=20><td><a href=#206>UL_PART</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#180>UL_ATTRIBUTE</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>classes()</tt>    </td><td width=20><td><a href=#184>UL_CLASS</a></td></tr>
<tr><td><tt>errors()</tt>     </td><td width=20><td><a href=#191>UL_ERROR</a></td></tr>
<tr><td><tt>layers()</tt>     </td><td width=20><td><a href=#199>UL_LAYER</a></td></tr>
<tr><td><tt>libraries()</tt>  </td><td width=20><td><a href=#200>UL_LIBRARY</a></td></tr>
<tr><td><tt>modules()</tt>    </td><td width=20><td><a href=#201>UL_MODULE</a></td></tr>
<tr><td><tt>nets()</tt>       </td><td width=20><td><a href=#203>UL_NET</a></td></tr>
<tr><td><tt>parts()</tt>      </td><td width=20><td><a href=#206>UL_PART</a></td></tr>
<tr><td><tt>sheets()</tt>     </td><td width=20><td><a href=#215>UL_SHEET</a></td></tr>
<tr><td><tt>variantdefs()</tt></td><td width=20><td><a href=#220>UL_VARIANTDEF</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#200>UL_LIBRARY</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ALWAYS_VECTOR_FONT_GUI</tt></td><td width=20><td>die Option "Immer Vektor-Schrift" ist
im <a href=#17>User-Interface-Dialog</a> gesetzt</td></tr>
<tr><td><tt>ALWAYS_VECTOR_FONT_PERSISTENT</tt></td><td width=20><td>die Option "Immer Vektor-Schrift" ist
in diese Zeichnung eingepr&auml;gt</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>VERTICAL_TEXT_UP</tt></td><td width=20><td>Leserichtung f&uuml;r vertikale Texte: aufw&auml;rts</td></tr>
<tr><td><tt>VERTICAL_TEXT_DOWN</tt></td><td width=20><td>Leserichtung f&uuml;r vertikale Texte: abw&auml;rts</td></tr>
</table>
<h2>Anmerkung</h2>
Der Wert von <tt>alwaysvectorfont</tt> kann in einem logischen Kontext verwendet werden
oder er kann auch mit den <tt>ALWAYS_VECTOR_FONT_...</tt> Konstanten maskiert werden,
um die Herkunft dieser Einstellung zu ermitteln, wie zum Beispiel in
<pre>
if (SCH.alwaysvectorfont) {
   // alwaysvectorfont ist gesetzt
   }
if (SCH.alwaysvectorfont &amp; ALWAYS_VECTOR_FONT_GUI) {
   // alwaysvectorfont ist in der Benutzeroberfl&auml;che gesetzt
   }
</pre>
Der Wert von <tt>checked</tt> kann in einem logischen Kontext verwendet werden;
er ist nur gesetzt, wenn gerade ein 'Electrical Rule Check' (<a href=#50>ERC</a>)
durchgef&uuml;hrt wurde.
Das <tt>name</tt> Member liefert den vollst&auml;ndigen Dateinamen, inklusive Verzeichnis.
<p>
Die Member <tt>xreflabel</tt> und <tt>xrefpart</tt> liefern die Format-Strings, die f&uuml;r die Darstellung von
<a href=#62>Querverweis-Labels</a> und <a href=#142>Bauteil-Querverweise</a> benutzt werden.
<p>
Das Loop-Member <tt>attributes()</tt> geht durch die <i>globalen</i> Attribute.
<h3>Virtuelle Bauteile, <tt>allparts()</tt> Loop-Member</h3>
Hierarchische Bauteile werden &uuml;ber Modul-Instanzen definiert und existieren eigentlich im Schaltplan
nicht, lediglich die Bauteile in den Modulen. Aus diesem Grund nennen wir sie manchmal 'Virtuelle Bauteile'.
Ein Modul-Bauteil kann &uuml;ber mehrere Modul-Instanzen von mehreren virtuellen Bauteilen benutzt werden.
Da jedes virtuelle Bauteil einem (real existierenden) Element im Board entspricht,
stellt die User Language diese Bauteile ebenfalls zur Verf&uuml;gung, z.B. f&uuml;r die BOM-Generierung.<br>
Das Loop-Member <tt>allparts()</tt> geht durch die <tt>parts()</tt> des Haupt-Schaltplans
und durch alle virtuellen Bauteile.
<h2>Beispiel</h2>
<pre>
schematic(S) {
  S.parts(P) printf("Part: %s\n", P.name);
  }
</pre>


<a name=214>
<h1>UL_SEGMENT</h1>
<dl>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>junctions()</tt>  </td><td width=20><td><a href=#197>UL_JUNCTION</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>labels()</tt>     </td><td width=20><td><a href=#198>UL_LABEL</a></td></tr>
<tr><td><tt>pinrefs()</tt>    </td><td width=20><td><a href=#208>UL_PINREF</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>portrefs()</tt>   </td><td width=20><td><a href=#211>UL_PORTREF</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a> (veraltet, siehe Anmerkung)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#182>UL_BUS</a>,
<a href=#203>UL_NET</a>
<h2>Anmerkung</h2>
Die Loop members <tt>junctions()</tt> und <tt>pinrefs()</tt>
sind nur f&uuml;r Netzsegmente zug&auml;nglich.
<p>
Das Loop member <tt>texts()</tt> wurde in fr&uuml;heren EAGLE-Versionen benutzt um durch die
Labels eines Segments zu gehen und ist nur noch aus Kompatibilit&auml;tsgr&uuml;nden vorhanden.
Es liefert den Text von Querverweis-Labels nicht an der richtigen Position. Benutzen
Sie das <tt>labels()</tt> Loop member um die Labels eines Segments anzusprechen.
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    printf("Sheet: %d\n", SH.number);
    SH.nets(N) {
      printf("\tNet: %s\n", N.name);
      N.segments(SEG) {
        SEG.pinrefs(P) {
          printf("connected to: %s, %s, %s\n",
                 P.part.name, P.instance.name, P.pin.name);
          }
        }
      }
    }
  }
</pre>


<a name=215>
<h1>UL_SHEET</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#179>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>number</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>busses()</tt>     </td><td width=20><td><a href=#182>UL_BUS</a></td></tr>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#183>UL_CIRCLE</a></td></tr>
<tr><td><tt>dimensions()</tt> </td><td width=20><td><a href=#189>UL_DIMENSION</a></td></tr>
<tr><td><tt>frames()</tt>     </td><td width=20><td><a href=#192>UL_FRAME</a></td></tr>
<tr><td><tt>instances()</tt>  </td><td width=20><td><a href=#196>UL_INSTANCE</a></td></tr>
<tr><td><tt>moduleinsts()</tt></td><td width=20><td><a href=#202>UL_MODULEINST</a></td></tr>
<tr><td><tt>nets()</tt>       </td><td width=20><td><a href=#203>UL_NET</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#209>UL_POLYGON</a></td></tr>
<tr><td><tt>rectangles()</tt> </td><td width=20><td><a href=#212>UL_RECTANGLE</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#213>UL_SCHEMATIC</a>
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.sheets(S) {
    printf("Sheet: %d\n", S.number);
    }
  }
</pre>


<a name=216>
<h1>UL_SIGNAL</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>airwireshidden</tt></td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>class</tt>         </td><td width=20><td><a href=#184>UL_CLASS</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>SIGNAL_NAME_LENGTH</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>contactrefs()</tt> </td><td width=20><td><a href=#186>UL_CONTACTREF</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#209>UL_POLYGON</a></td></tr>
<tr><td><tt>vias()</tt>       </td><td width=20><td><a href=#222>UL_VIA</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SIGNAL_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Signalnamens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Beispiel</h2>
<pre>
board(B) {
  B.signals(S) printf("Signal: %s\n", S.name);
  }
</pre>


<a name=217>
<h1>UL_SMD</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#173>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>dx[layer], dy[layer]</tt>   </td><td width=20><td><a href=#172>int</a> (size)</td></tr>
<tr><td><tt>flags</tt>        </td><td width=20><td><a href=#172>int</a> (<tt>SMD_FLAG_...</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>SMD_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>roundness</tt>    </td><td width=20><td><a href=#172>int</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>signal</tt>       </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Mittelpunkt, siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#204>UL_PACKAGE</a>,
<a href=#185>UL_CONTACT</a>,
<a href=#205>UL_PAD</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SMD_FLAG_STOP</tt>   </td><td width=20><td>L&ouml;tstopmaske generieren</td></tr>
<tr><td><tt>SMD_FLAG_THERMALS</tt>         </td><td width=20><td>Thermals generieren</td></tr>
<tr><td><tt>SMD_FLAG_CREAM</tt>            </td><td width=20><td>Lotpastenmaske generieren</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SMD_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlenen L&auml;nge eines Smd-Namens (identisch mit <tt>CONTACT_NAME_LENGTH</tt>)</td></tr>
</table>
<h2>Anmerkung</h2>
Die Parameter des SMDs h&auml;ngen vom Kontext ab in dem es angesprochen wird:
<ul>
<li>Wird das Smd aus einem UL_LIBRARY-Kontext angesprochen, entsprechen die Werte der Koordinaten (<tt>x, y</tt>), des Winkels (<tt>angle</tt>)
und die Angabe f&uuml;r Layer und Roundness denen in der Package-Zeichnung
<li>in allen anderen F&auml;llen erhalten Sie die aktuellen Werte aus dem Board
</ul>
Ruft man die Data Member <tt>dx</tt> und <tt>dy</tt> mit einem optionalen Layer-Index auf,
werden die Werte f&uuml;r den zugeh&ouml;rigen Layer, entsprechend den <a href=#139>Design Rules</a>
ausgegeben.
G&uuml;ltige <a href=#199>Layer</a> sind LAYER_TOP, LAYER_TSTOP und LAYER_TCREAM f&uuml;r ein
Smd im Top-Layer, und LAYER_BOTTOM, LAYER_BSTOP und LAYER_BCREAM f&uuml;r ein Smd im Bottom-Layer.
<p>
<tt>angle</tt> gibt an um wieviel Grad das Smd gegen den Uhrzeigersinn um seinen
Mittelpunkt gedreht ist.
<p>
Der Wert, den <tt>flags</tt> liefert, muss mit den <tt>SMD_FLAG_...</tt> Konstanten
maskiert werden um die einzelnen Flag-Einstellungen zu ermitteln, wie zum Beispiel in
<pre>
if (smd.flags &amp; SMD_FLAG_STOP) {
   ...
   }
</pre>
Falls Ihr ULP lediglich die Objekte darstellen soll, brauchen Sie sich nicht
explizit um diese Flags zu k&uuml;mmern. Die <tt>dx[]</tt> und <tt>dy[]</tt>
Members liefern die richtigen Daten; ist zum Beispiel <tt>SMD_FLAG_STOP</tt>
gesetzt, so liefert <tt>dx[LAYER_TSTOP]</tt> den Wert <tt>0</tt>, was
zur Folge haben sollte, dass in diesem Layer nichts gezeichnet wird.
Das <tt>flags</tt> Member ist haupts&auml;chlich f&uuml;r ULPs gedacht, die Script-Dateien
erzeugen mit denen Bibliotheksobjekte kreiert werden.
<h2>Beispiel</h2>
<pre>
library(L) {
  L.packages(PAC) {
    PAC.contacts(C) {
      if (C.smd)
         printf("Smd: '%s', (%f %f), dx=%f, dy=%f\n",
                 C.name, u2mm(C.smd.x), u2mm(C.smd.y), u2mm(C.smd.dx), u2mm(C.smd.dy));
      }
    }
  }
</pre>


<a name=218>
<h1>UL_SYMBOL</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#179>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>library</tt>      </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#174>string</a> (<tt>SYMBOL_NAME_LENGTH</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#183>UL_CIRCLE</a></td></tr>
<tr><td><tt>dimensions()</tt> </td><td width=20><td><a href=#189>UL_DIMENSION</a></td></tr>
<tr><td><tt>frames()</tt>     </td><td width=20><td><a href=#192>UL_FRAME</a></td></tr>
<tr><td><tt>rectangles()</tt> </td><td width=20><td><a href=#212>UL_RECTANGLE</a></td></tr>
<tr><td><tt>pins()</tt>       </td><td width=20><td><a href=#207>UL_PIN</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#209>UL_POLYGON</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#219>UL_TEXT</a> (siehe Anmerkung)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#193>UL_GATE</a>,
<a href=#200>UL_LIBRARY</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SYMBOL_NAME_LENGTH</tt>   </td><td width=20><td>max. empfohlene L&auml;nge eines Symbol-Namens (wird nur f&uuml;r formatierte Ausgaben benutzt)</td></tr>
</table>
<h2>Anmerkung</h2>
Stammt das UL_SYMBOL aus einem UL_INSTANCE-Kontext, so durchl&auml;uft das <tt>texts()</tt>-Member
nur die nicht losgel&ouml;sten Texte dieser Instance.
<h2>Beispiel</h2>
<pre>
library(L) {
  L.symbols(S) printf("Sym: %s\n", S.name);
  }
</pre>


<a name=219>
<h1>UL_TEXT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>align</tt>        </td><td width=20><td><a href=#172>int</a> (<tt>ALIGN_...</tt>)</td></tr>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#173>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>font</tt>         </td><td width=20><td><a href=#172>int</a> (<tt>FONT_...</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>linedistance</tt> </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>ratio</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>size</tt>         </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>spin</tt>         </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Aufh&auml;ngepunkt)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a> (siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#204>UL_PACKAGE</a>,
<a href=#215>UL_SHEET</a>,
<a href=#218>UL_SYMBOL</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>FONT_VECTOR</tt>   </td><td width=20><td>Vector-Font</td></tr>
<tr><td><tt>FONT_PROPORTIONAL</tt>       </td><td width=20><td>Proportional-Font</td></tr>
<tr><td><tt>FONT_FIXED</tt>              </td><td width=20><td>Fixed-Font</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ALIGN_BOTTOM_LEFT</tt>   </td><td width=20><td>unten/links ausgerichtet</td></tr>
<tr><td><tt>ALIGN_BOTTOM_CENTER</tt> </td><td width=20><td>unten/mittig ausgerichtet</td></tr>
<tr><td><tt>ALIGN_BOTTOM_RIGHT</tt>  </td><td width=20><td>unten/rechts ausgerichtet</td></tr>
<tr><td><tt>ALIGN_CENTER_LEFT</tt>   </td><td width=20><td>mittig/links ausgerichtet</td></tr>
<tr><td><tt>ALIGN_CENTER</tt>        </td><td width=20><td>zentriert</td></tr>
<tr><td><tt>ALIGN_CENTER_RIGHT</tt>  </td><td width=20><td>mittig/rechts ausgerichtet</td></tr>
<tr><td><tt>ALIGN_TOP_LEFT</tt>      </td><td width=20><td>oben/links ausgerichtet</td></tr>
<tr><td><tt>ALIGN_TOP_CENTER</tt>    </td><td width=20><td>oben/mittig ausgerichtet</td></tr>
<tr><td><tt>ALIGN_TOP_RIGHT</tt>     </td><td width=20><td>oben/rechts ausgerichtet</td></tr>
</table>
<h2>Anmerkung</h2>
Das Loop-Member <tt>wires()</tt> greift immer auf die individuellen Wires, aus denen der Text
im Vektor-Font zusammengesetzt wird, zu. Auch dann, wenn der aktuelle Font nicht
<tt>FONT_VECTOR</tt> ist.
<p>
Wurde der UL_TEXT aus einem UL_ELEMENT- oder UL_INSTANCE-Kontext angesprochen, so liefern
die Members die tats&auml;chlichen Werte, so wie sie in der Board- oder Schaltplan-Zeichnung zu
finden sind.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.texts(T) {
    printf("Text: %s\n", T.value);
    }
  }
</pre>


<a name=220>
<h1>UL_VARIANTDEF</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>name</tt>        </td><td width=20><td><a href=#174>string</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#221>UL_VARIANT</a>,
<a href=#213>UL_SCHEMATIC</a>,
<a href=#181>UL_BOARD</a>
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.variantdefs(VD) {
    printf("Variant: '%s'\n", VD.name);
    }
  }
</pre>


<a name=221>
<h1>UL_VARIANT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>populate</tt>     </td><td width=20><td><a href=#172>int</a> (0=do not populate, 1=populate)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>technology</tt>   </td><td width=20><td><a href=#174>string</a></td></tr>
<tr><td><tt>variantdef</tt>   </td><td width=20><td><a href=#220>UL_VARIANTDEF</a></td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#220>UL_VARIANTDEF</a>,
<a href=#206>UL_PART</a>
<h2>Beispiel</h2>
<pre>
schematic(SCH) {
  SCH.parts(P) {
    P.variants(V) {
      printf("%s: %spopulate\n", V.variantdef.name, V.populate ? "" : "do not ");
      }
    }
  }
</pre>


<a name=222>
<h1>UL_VIA</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>diameter[layer]</tt>     </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>drill</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>drillsymbol</tt>  </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>end</tt>          </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>flags</tt>        </td><td width=20><td><a href=#172>int</a> (<tt>VIA_FLAG_...</tt>)</td></tr>
<tr><td><tt>shape[layer]</tt> </td><td width=20><td><a href=#172>int</a> (<tt>VIA_SHAPE_...</tt>)</td></tr>
<tr><td><tt>start</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#172>int</a> (Mittelpunkt)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#216>UL_SIGNAL</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>VIA_FLAG_STOP</tt>   </td><td width=20><td>L&ouml;tstopmaske immer generieren</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>VIA_SHAPE_SQUARE</tt>   </td><td width=20><td>square</td></tr>
<tr><td><tt>VIA_SHAPE_ROUND</tt>    </td><td width=20><td>round</td></tr>
<tr><td><tt>VIA_SHAPE_OCTAGON</tt>  </td><td width=20><td>octagon</td></tr>
</table>
<h2>Anmerkung</h2>
Der Durchmesser und die Form des Vias h&auml;ngen davon ab f&uuml;r welchen Layer es gezeichnet
werden soll, denn es k&ouml;nnen in den <a href=#139>Design Rules</a> unterschiedliche
Werte definiert werden.
Gibt man einen der <a href=#199>Layer</a> LAYER_TOP...LAYER_BOTTOM, LAYER_TSTOP oder LAYER_BSTOP
als Index f&uuml;r diameter oder shape an, wird das Via entsprechend den Vorgaben aus den Design Rules
berechnet. Wird LAYER_VIAS angegeben, wird der urspr&uuml;ngliche Wert mit dem das Via definiert wurde,
verwendet.
<p>
Beachten Sie bitte, dass <tt>diameter</tt> und <tt>shape</tt> auf jeden Fall den
Durchmesser bzw. die Form zur&uuml;ckliefern, welche ein Via in dem gegebenen Layer h&auml;tte,
selbst wenn das konkrete Via diesen Layer gar nicht &uuml;berdeckt (oder wenn dieser Layer
im Layer-Setup &uuml;berhaupt nicht benutzt wird).
<p>
<tt>start</tt> und <tt>end</tt> liefern den Layer, in dem dieses Via beginnt bzw. endet.
Der Wert von <tt>start</tt> ist dabei immer kleiner als der von <tt>end</tt>.
<p>
<tt>drillsymbol</tt> liefert die Nummer des Bohrsymbols, welches diesem Bohrdurchmesser
zugeordnet worden ist (siehe die Liste der definierten Bohrsymbole im Handbuch).
Ein Wert von <tt>0</tt> bedeutet, dass diesem Bohrdurchmesser kein Bohrsymbol zugeordnet ist.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.signals(S) {
    S.vias(V) {
      printf("Via: (%f %f)\n", u2mm(V.x), u2mm(V.y));
      }
    }
  }
</pre>


<a name=223>
<h1>UL_WIRE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>arc</tt>  </td><td width=20><td><a href=#178>UL_ARC</a></td></tr>
<tr><td><tt>cap</tt>          </td><td width=20><td><a href=#172>int</a> (<tt>CAP_...</tt>)</td></tr>
<tr><td><tt>curve</tt>        </td><td width=20><td><a href=#173>real</a></td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>style</tt>        </td><td width=20><td><a href=#172>int</a> (<tt>WIRE_STYLE_...</tt>)</td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#172>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#172>int</a> (Anfangspunkt)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#172>int</a> (Endpunkt)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>pieces()</tt>      </td><td width=20><td><a href=#223>UL_WIRE</a> (siehe Anmerkung)</td></tr>
</table>
</dl>
<b>Siehe auch</b> <a href=#181>UL_BOARD</a>,
<a href=#204>UL_PACKAGE</a>,
<a href=#214>UL_SEGMENT</a>,
<a href=#215>UL_SHEET</a>,
<a href=#216>UL_SIGNAL</a>,
<a href=#218>UL_SYMBOL</a>,
<a href=#178>UL_ARC</a>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CAP_FLAT</tt>  </td><td width=20><td>flache Kreisbogen-Enden</td></tr>
<tr><td><tt>CAP_ROUND</tt>   </td><td width=20><td>runde Kreisbogen-Enden</td></tr>
<tr><td><tt>WIRE_STYLE_CONTINUOUS</tt>   </td><td width=20><td>durchgezogen</td></tr>
<tr><td><tt>WIRE_STYLE_LONGDASH</tt>    </td><td width=20><td>lang gestrichelt</td></tr>
<tr><td><tt>WIRE_STYLE_SHORTDASH</tt>   </td><td width=20><td>kurz gestrichelt</td></tr>
<tr><td><tt>WIRE_STYLE_DASHDOT</tt>     </td><td width=20><td>Strich-Punkt-Linie</td></tr>
</table>
<h2>Wire Style</h2>
Bei einem UL_WIRE mit anderem <i>style</i> als <tt>WIRE_STYLE_CONTINUOUS</tt>, kann
&uuml;ber das Loop-Member <tt>pieces()</tt> auf die individuellen Teile, die z. B. eine gestrichelte
Linie darstellen, zugegriffen werden. Wenn <tt>pieces()</tt> f&uuml;r UL_WIRE mit
<tt>WIRE_STYLE_CONTINUOUS</tt> aufgerufen wird, erh&auml;lt man ein Segment, das
genau dem original UL_WIRE entspricht. Das Loop-Member <tt>pieces()</tt> kann nicht
von UL_WIRE aus aufgerufen werden, wenn dieser selbst schon &uuml;ber <tt>pieces()</tt>
aufgerufen wurde (das w&uuml;rde eine unendliche Schleife verursachen).
<h2>Kreisb&ouml;gen auf Wire-Ebene</h2>
Kreisb&ouml;gen sind zun&auml;chst einfach nur Wires, mit einigen zus&auml;tzlichen Eigenschaften.
In erster N&auml;herung werden Kreisb&ouml;gen genauso behandelt wie Wires, das heisst sie haben
einen Anfangs- und Endpunkt, eine Breite und einen Linientyp. Hinzu kommen auf
Wire-Ebene die Parameter <i>cap</i> und <i>curve</i>. <i>cap</i> gibt an ob die Kreisbogen-Enden
rund oder flach sind, und <i>curve</i> bestimmt die "Kr&uuml;mmung" des Kreisbogens.
Der g&uuml;ltige Bereich f&uuml;r <i>curve</i> ist <tt>-360</tt>..<tt>+360</tt>, wobei der Wert
angibt aus welchem Anteil eines Vollkreises der Kreisbogen besteht. Ein Wert von <tt>90</tt>
beispielsweise steht f&uuml;r einen Viertelkreis, w&auml;hrend <tt>180</tt> einen Halbkreis
ergibt. Der maximale Wert von <tt>360</tt> kann nur theoretisch erreicht werden, da dies
bedeuten w&uuml;rde, dass der Kreisbogen aus einem vollen Kreis besteht, der, weil Anfangs- und
Endpunkt auf dem Kreis liegen m&uuml;ssen, einen unendlich gro&szlig;en Durchmesser haben m&uuml;sste.
Positive Werte f&uuml;r <i>curve</i> bedeuten, dass der Kreisbogen im mathematisch positiven Sinne
(also gegen den Uhrzeigersinn) gezeichnet wird. Falls <i>curve</i> gleich <tt>0</tt>
ist, handelt es sich um eine gerade Linie ("keine Kr&uuml;mmung"), was letztlich einem
Wire entspricht.
<p>
Der <i>cap</i> Parameter ist nur f&uuml;r echte Kreisb&ouml;gen von Bedeutung und liefert f&uuml;r gerade
Wires immer <tt>CAP_ROUND</tt>.
<p>
Ob ein UL_WIRE ein Kreisbogen ist oder nicht kann durch Abfragen des booleschen R&uuml;ckgabewertes
des <tt>arc</tt> Data Members herausgefunden werden. Falls dieses <tt>0</tt> liefert,
liegt ein gerader Wire vor, ansonsten ein Kreisbogen. Liefert <tt>arc</tt> nicht <tt>0</tt>
so darf es weiter dereferenziert werden um die f&uuml;r einen <a href=#178>UL_ARC</a>
spezifischen Parameter Start- und Endwinkel, Radius und Mittelpunkt zu erfragen.
Diese zus&auml;tzlichen Parameter sind normalerweise nur von Bedeutung wenn der Kreisbogen
gezeichnet oder anderweitig verarbeitet werden soll, und dabei die tats&auml;chliche Form
eine Rolle spielt.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.wires(W) {
    printf("Wire: (%f %f) (%f %f)\n",
           u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2));
    }
  }
</pre>


<a name=224>
<h1>Definitionen</h1>
Konstanten, Variablen und Funktionen m&uuml;ssen definiert werden,
bevor sie in einem User-Language-Programm verwendet werden k&ouml;nnen.
<p>
Es gibt drei Arten von Definitionen:
<ul>
<li><a href=#225>Konstanten-Definitionen</a>
<li><a href=#226>Variablen-Definitionen</a>
<li><a href=#227>Funktions-Definitionen</a>
</ul>
Der G&uuml;ltigkeitsbereich einer <i>Konstanten-</i> oder
<i>Variablen</i>-Definition reicht von der Zeile, in der sie definiert
wurde, bis zum Ende des gegenw&auml;rtigen
<a href=#243>Blocks</a>, oder bis zum Ende des
User-Language-Programms, wenn die Definition ausserhalb aller Bl&ouml;cke steht.
<p>
Der G&uuml;ltigkeitsbereich einer <i>Funktions</i>-Definition reicht
von der schlie&szlig;enden geschweiften Klammer
(<tt>}</tt>) des Funktionsrumpfes bis zum Ende des User-Language-Programms.


<a name=225>
<h1>Konstanten-Definitionen</h1>
<i>Konstanten</i> werden mit Hilfe des Schl&uuml;sselworts
<tt>enum</tt> definiert, wie in
<pre>
enum { a, b, c };
</pre>
womit man den drei Konstanten <tt>a</tt>, <tt>b</tt> und <tt>c</tt>
die Werte <tt>0</tt>, <tt>1</tt> und <tt>2</tt> zuweisen w&uuml;rde.
<p>
Konstanten kann man auch mit bestimmten Werten initialisieren, wie in
<pre>
enum { a, b = 5, c };
</pre>
wo <tt>a</tt> den Wert <tt>0</tt>, <tt>b</tt> den Wert <tt>5</tt> und
<tt>c</tt> den Wert <tt>6</tt> erh&auml;lt.


<a name=226>
<h1>Variablen-Definitionen</h1>
Die allgemeine Syntax einer <i>Variablen-Definition</i> ist
<pre>
[numeric] type identifier [= initializer][, ...];
</pre>
wobei <tt>type</tt> ein
<a href=#170>Daten-</a> oder
<a href=#177>Objekt-Typ</a> ist,
<tt>identifier</tt> ist der Name der Variablen, und <tt>initializer</tt>
ist ein optionaler Initialisierungswert.
<p>
Mehrfach-Variablen-Definitionen desselben <tt>Typs</tt> werden durch
Kommas (<tt>,</tt>) getrennt.
<p>
Wenn auf <tt>identifier</tt> ein Paar
<a href=#163>eckiger Klammern</a> (<tt>[]</tt>) folgt,
wird ein Array von Variablen des gegebenen <tt>Typs</tt> definiert.
Die Gr&ouml;&szlig;e des Arrays wird zur Laufzeit automatisch bestimmt.
<p>
Das optionale Schl&uuml;sselwort <tt>numeric</tt> kann mit
<a href=#174>String</a>-Arrays verwendet werden,
um sie alphanumerisch mit der Funktion
<a href=#282>sort()</a> sortieren zu lassen.
<p>
Standardm&auml;&szlig;ig (wenn kein <tt>Initializer</tt> vorhanden ist),
werden
<a href=#170>Daten-Variablen</a> auf <tt>0</tt> gesetzt
(oder <tt>""</tt>, falls es sich um einen String handelt), und
<a href=#177>Objekt -Variablen</a> werden mit
"invalid" initialisiert.
<h2>Beispiele</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>int i;</tt>   </td><td width=20><td>definiert eine <a href=#172>int</a>-Variable mit dem Namen <tt>i</tt></td></tr>
<tr><td><tt>string s = "Hello";</tt> </td><td width=20><td>definiert eine <a href=#174>string</a>-Variable mit dem Namen <tt>s</tt> und initialisiert sie mit <tt>"Hello"</tt></td></tr>
<tr><td><tt>real a, b = 1.0, c;</tt> </td><td width=20><td>definiert drei <a href=#173>real</a>-Variablen mit den Namen <tt>a</tt>, <tt>b</tt> und <tt>c</tt> und initialisiert <tt>b</tt> mit dem Wert <tt>1.0</tt></td></tr>
<tr><td><tt>int n[] = { 1, 2, 3 };</tt> </td><td width=20><td>definiert ein Array of <a href=#172>int</a> und initialisiert die ersten drei Elemente mit <tt>1</tt>, <tt>2</tt> und <tt>3</tt></td></tr>
<tr><td><tt>numeric string names[];</tt> </td><td width=20><td>definiert ein <a href=#174>string</a>-Array das alphanumerisch sortiert werden kann</td></tr>
<tr><td><tt>UL_WIRE w;</tt> </td><td width=20><td>definiert ein <a href=#223>UL_WIRE</a>-Objekt mit dem Namen <tt>w</tt></td></tr>
</table>
Die Members von Elementen eines Arrays von <a href=#177>Objekt-Typen</a> k&ouml;nnen nicht direkt angesprochen werden:
<pre>
UL_SIGNAL signals[];
...
UL_SIGNAL s = signals[0];
printf("%s", s.name);
</pre>


<a name=227>
<h1>Funktions-Definitionen</h1>
Sie k&ouml;nnen Ihre eigenen User-Language-Funktionen schreiben und sie genau so
aufrufen wie
<a href=#257>Builtin-Functions</a>.
<p>
Die allgemeine Syntax einer <i>Funktions-Definition</i> lautet
<pre>
type identifier(parameters)
{
  statements
}
</pre>
wobei <tt>type</tt> ein
<a href=#170>Daten-</a> oder
<a href=#177>Objekt-Typ</a> ist,
<tt>identifier</tt> der Name einer Funktion,
<tt>parameters</tt> eine durch Kommas getrennte Liste
von Parameter-Definitionen und
<tt>statements</tt> eine Reihe von <a href=#242>Statements</a>.
<p>
Funktionen die keinen Wert zur&uuml;ckgeben, haben den Typ <tt>void</tt>.
<p>
Eine Funktion muss definiert werden, <b>bevor</b> sie aufgerufen werden kann,
und Funktionsaufrufe k&ouml;nnen nicht rekursiv sein (eine Funktion kann sich nicht
selbst aufrufen).
<p>
Die Statements im Funktionsrumpf k&ouml;nnen die Werte der Parameter &auml;ndern,
das hat aber keinen Einfluss auf die Argumente des
<a href=#241>Funktionsaufrufs</a>.
<p>
Die Ausf&uuml;hrung einer Funktion kann mit dem
<tt><a href=#251>return</a></tt>-Statement beendet werden.
Ohne <tt>return</tt>-Statement wird der Funktionsrumpf bis zu seiner
schlie&szlig;enden geschweiften Klammer
(<tt>}</tt>) ausgef&uuml;hrt.
<p>
Ein Aufruf der <tt><a href=#276>exit()</a></tt>-Funktion beendet
das gesamte User-Language-Programm.
<h2>Die spezielle Funktion <tt>main()</tt></h2>
Wenn Ihr User-Language-Programm  eine Funktion namens
<tt>main()</tt> enth&auml;lt, wird diese Funktion explizit als Hauptfunktion
aufgerufen. Ihr R&uuml;ckgabewert ist der
<a href=#146>R&uuml;ckgabewert</a> des Programms.
<p>
Kommandozeilen-Argumente sind f&uuml;r das Programm &uuml;ber die globalen
<a href=#256>Builtin-Variablen</a> <tt>argc</tt> und <tt>argv</tt>
verf&uuml;gbar.
<h2>Beispiel</h2>
<pre>
int CountDots(string s)
{
  int dots = 0;
  for (int i = 0; s[i]; ++i)
      if (s[i] == '.')
         ++dots;
  return dots;
}
string dotted = "This.has.dots...";
output("test") {
  printf("Number of dots: %d\n",
                 CountDots(dotted));
  }
</pre>


<a name=228>
<h1>Operatoren</h1>
Die folgende Tabelle listet alle User-Language-Operatoren in der Reihenfolge
ihrer Priorit&auml;t auf (<i>Unary</i> hat die h&ouml;chste Priorit&auml;t,
<i>Comma</i> die niedrigste):
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Unary           </td><td width=20><td><tt><a href=#230>!</a> <a href=#229>~</a> <a href=#233>+ - ++ --</a></tt></td></tr>
<tr><td>Multiplicative  </td><td width=20><td><tt><a href=#233>* / %</a></tt></td></tr>
<tr><td>Additive        </td><td width=20><td><tt><a href=#233>+ -</a></tt></td></tr>
<tr><td>Shift           </td><td width=20><td><tt><a href=#229>&lt;&lt; &gt;&gt;</a></tt></td></tr>
<tr><td>Relational      </td><td width=20><td><tt><a href=#231>&lt; &lt;= &gt; &gt;=</a></tt></td></tr>
<tr><td>Equality        </td><td width=20><td><tt><a href=#231>== !=</a></tt></td></tr>
<tr><td>Bitwise AND     </td><td width=20><td><tt><a href=#229>&amp;</a></tt></td></tr>
<tr><td>Bitwise XOR     </td><td width=20><td><tt><a href=#229>^</a></tt></td></tr>
<tr><td>Bitwise OR      </td><td width=20><td><tt><a href=#229>|</a></tt></td></tr>
<tr><td>Logical AND     </td><td width=20><td><tt><a href=#230>&amp;&amp;</a></tt></td></tr>
<tr><td>Logical OR      </td><td width=20><td><tt><a href=#230>||</a></tt></td></tr>
<tr><td>Conditional     </td><td width=20><td><tt><a href=#232>?:</a></tt></td></tr>
<tr><td>Assignment      </td><td width=20><td><tt><a href=#233>= *= /= %= += -=</a> <a href=#229>&amp;= ^= |= &lt;&lt;= &gt;&gt;=</a></tt></td></tr>
<tr><td>Comma           </td><td width=20><td><tt><a href=#232>,</a></tt></td></tr>
</table>
<p>
Die Assoziativit&auml;t ist <b>links nach rechts</b> f&uuml;r alle Operatoren
ausser f&uuml;r
<i>Unary</i>, <i>Conditional</i> und <i>Assignment</i>,
die <b>rechts-nach-links</b>-assoziativ sind.
<p>
Die normale Operator-Priorit&auml;t kann durch den Gebrauch von
<a href=#164>runden Klammern</a> ge&auml;ndert werden.


<a name=229>
<h1>Bitweise Operatoren</h1>
Bitweise Operatoren kann man nur auf die Datentypen
<tt><a href=#171>char</a></tt> und
<tt><a href=#172>int</a></tt> anwenden.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Unary</b>   </td><td width=20><td></td></tr>
<tr><td><tt>~</tt>          </td><td width=20><td>Bitwise (1's) complement</td></tr>
<tr><td><b>Binary</b>  </td><td width=20><td></td></tr>
<tr><td><tt>&lt;&lt;</tt>         </td><td width=20><td>Shift left</td></tr>
<tr><td><tt>&gt;&gt;</tt>         </td><td width=20><td>Shift right</td></tr>
<tr><td><tt>&amp;</tt>          </td><td width=20><td>Bitwise AND</td></tr>
<tr><td><tt>^</tt>          </td><td width=20><td>Bitwise XOR</td></tr>
<tr><td><tt>|</tt>          </td><td width=20><td>Bitwise OR</td></tr>
<tr><td><b>Assignment</b>  </td><td width=20><td></td></tr>
<tr><td><tt>&amp;=</tt>         </td><td width=20><td>Assign bitwise AND</td></tr>
<tr><td><tt>^=</tt>         </td><td width=20><td>Assign bitwise XOR</td></tr>
<tr><td><tt>|=</tt>         </td><td width=20><td>Assign bitwise OR</td></tr>
<tr><td><tt>&lt;&lt;=</tt>        </td><td width=20><td>Assign left shift</td></tr>
<tr><td><tt>&gt;&gt;=</tt>        </td><td width=20><td>Assign right shift</td></tr>
</table>


<a name=230>
<h1>Logische Operatoren</h1>
Logische Operatoren arbeiten mit
<a href=#235>Ausdr&uuml;cken</a>
von jedem Datentyp.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Unary</b>   </td><td width=20><td></td></tr>
<tr><td><tt>!</tt>          </td><td width=20><td>Logical NOT</td></tr>
<tr><td><b>Binary</b>  </td><td width=20><td></td></tr>
<tr><td><tt>&amp;&amp;</tt>         </td><td width=20><td>Logical AND</td></tr>
<tr><td><tt>||</tt>         </td><td width=20><td>Logical OR</td></tr>
</table>
<p>
Die Verwendung eines
<tt><a href=#174>String</a></tt>-Ausdrucks mit einem
logischen Operator pr&uuml;ft, ob ein String leer ist.
<p>
Die Verwendung eines
<a href=#177>Objekt-Typs</a> mit einem logischen Operator
pr&uuml;ft, ob dieses Objekt g&uuml;ltige Daten enth&auml;lt.


<a name=231>
<h1>Vergleichs-Operatoren</h1>
Vergleichs-Operatoren k&ouml;nnen mit
<a href=#235>Ausdr&uuml;cken</a> von jedem Datentyp angewendet
werden, ausgenommen
<a href=#177>Objekt-Typen</a>.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>&lt;</tt>          </td><td width=20><td>Kleiner als</td></tr>
<tr><td><tt>&lt;=</tt>         </td><td width=20><td>Kleiner gleich</td></tr>
<tr><td><tt>&gt;</tt>          </td><td width=20><td>Gr&ouml;&szlig;er als</td></tr>
<tr><td><tt>&gt;=</tt>         </td><td width=20><td>Gr&ouml;&szlig;er gleich</td></tr>
<tr><td><tt>==</tt>         </td><td width=20><td>Gleich</td></tr>
<tr><td><tt>!=</tt>         </td><td width=20><td>Ungleich</td></tr>
</table>


<a name=232>
<h1>Evaluation-Operatoren</h1>
Evaluation-Operatoren werden verwendet, um
<a href=#235>Ausdr&uuml;cke</a> auszuwerten, die auf einer
Bedingung basieren, oder um eine Sequenz von Ausdr&uuml;cken zu gruppieren
und sie als einen Ausdruck auszuwerten.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>?:</tt>         </td><td width=20><td>Conditional</td></tr>
<tr><td><tt>,</tt>          </td><td width=20><td>Komma</td></tr>
</table>
<p>
Der <i>Conditional</i>-Operator wird verwendet, um eine Entscheidung
innerhalb eines Ausdrucks zu treffen, wie in
<pre>
int a;
// ...code that calculates 'a'
string s = a ? "True" : "False";
</pre>
was folgender Konstruktion entspricht
<pre>
int a;
string s;
// ...code that calculates 'a'
if (a)
   s = "True";
else
   s = "False";
</pre>
aber der Vorteil des Conditional-Operators ist, dass er innerhalb des
Ausdrucks verwendet werden kann.
<p>
Der <i>Komma</i>-Operator wird verwendet, um eine Sequenz von
Ausdr&uuml;cken von links nach rechts auszuwerten; Typ und Wert des rechten
Operanden werden als Ergebnis verwendet.
<p>
Beachten Sie, dass Argumente in einem Funktionsaufruf und
Mehrfach-Variablen-Deklarationen ebenfalls Kommas als Trennzeichen verwenden.
Dabei handelt es sich aber <b>nicht</b> um den Komma-Operator!


<a name=233>
<h1>Arithmetische Operatoren</h1>
Arithmetische Operatoren lassen sich auf die Datentypen
<tt><a href=#171>char</a></tt>,
<tt><a href=#172>int</a></tt> und
<tt><a href=#173>real</a></tt>
anwenden (ausser <tt>++</tt>, <tt>--</tt>, <tt>%</tt> und <tt>%=</tt>).
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Unary</b>   </td><td width=20><td></td></tr>
<tr><td><tt>+</tt>          </td><td width=20><td>Unary plus</td></tr>
<tr><td><tt>-</tt>          </td><td width=20><td>Unary minus</td></tr>
<tr><td><tt>++</tt>         </td><td width=20><td>Pre- oder postincrement</td></tr>
<tr><td><tt>--</tt>         </td><td width=20><td>Pre- oder postdecrement</td></tr>
<tr><td><b>Binary</b>  </td><td width=20><td></td></tr>
<tr><td><tt>*</tt>          </td><td width=20><td>Multiply</td></tr>
<tr><td><tt>/</tt>          </td><td width=20><td>Divide</td></tr>
<tr><td><tt>%</tt>          </td><td width=20><td>Remainder (modulus)</td></tr>
<tr><td><tt>+</tt>          </td><td width=20><td>Binary plus</td></tr>
<tr><td><tt>-</tt>          </td><td width=20><td>Binary minus</td></tr>
<tr><td><b>Assignment</b> </td><td width=20><td></td></tr>
<tr><td><tt>=</tt>          </td><td width=20><td>Simple assignment</td></tr>
<tr><td><tt>*=</tt>         </td><td width=20><td>Assign product</td></tr>
<tr><td><tt>/=</tt>         </td><td width=20><td>Assign quotient</td></tr>
<tr><td><tt>%=</tt>         </td><td width=20><td>Assign remainder (modulus)</td></tr>
<tr><td><tt>+=</tt>         </td><td width=20><td>Assign sum</td></tr>
<tr><td><tt>-=</tt>         </td><td width=20><td>Assign difference</td></tr>
</table>
<p>
<b>Siehe auch</b> <a href=#234>String-Operatoren</a>


<a name=234>
<h1>String-Operatoren</h1>
String-Operatoren lassen sich mit den Datentypen
<tt><a href=#171>char</a></tt>,
<tt><a href=#172>int</a></tt> und
<tt><a href=#174>string</a></tt> anwenden.
Der linke Operand muss immer vom Typ
<tt><a href=#174>string</a></tt> sein.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Binary</b>  </td><td width=20><td></td></tr>
<tr><td><tt>+</tt>          </td><td width=20><td>Concatenation</td></tr>
<tr><td><b>Assignment</b>  </td><td width=20><td></td></tr>
<tr><td><tt>=</tt>          </td><td width=20><td>Simple assignment</td></tr>
<tr><td><tt>+=</tt>         </td><td width=20><td>Append to string</td></tr>
</table>
<p>
Der <tt>+</tt>-Operator fasst zwei Strings zusammen oder
f&uuml;gt ein Zeichen am Ende eines Strings hinzu und
gibt den resultierenden String zur&uuml;ck.
<p>
Der <tt>+=</tt>-Operator f&uuml;gt einen String oder eine Zeichen an das Ende
eines gegebenen Stings an.
<p>
<b>Siehe auch</b> <a href=#233>Arithmetische Operatoren</a>


<a name=235>
<h1>Ausdr&uuml;cke</h1>
Es gibt folgende <i>Ausdr&uuml;cke:</i>
<ul>
<li><a href=#236>Arithmetischer Ausdruck</a>
<li><a href=#237>Zuweisungs-Ausdruck</a>
<li><a href=#238>String-Ausdruck</a>
<li><a href=#239>Komma-Ausdruck</a>
<li><a href=#240>Bedingter Ausdruck</a>
<li><a href=#241>Funktionsaufruf</a>
</ul>
Ausdr&uuml;cke k&ouml;nnen mit Hilfe von
<a href=#164>runden Klammern</a> gruppiert werden
und d&uuml;rfen rekursiv aufgerufen werden, was bedeutet, dass
ein Ausdruck aus Unterausdr&uuml;cken bestehen darf.


<a name=236>
<h1>Arithmetischer Ausdruck</h1>
Ein <i>arithmetischer Ausdruck</i> ist jede Kombination von
numerischen Operanden und
<a href=#233>arithmetischem Operator</a> oder
<a href=#229>bitweisem Operator</a>.
<h2>Beispiele</h2>
<pre>
a + b
c++
m &lt;&lt; 1
</pre>


<a name=237>
<h1>Zuweisungs-Ausdruck</h1>
Ein <i>Zuweisungs-Ausdruck</i> besteht aus einer Variablen auf der
linken Seite eines <a href=#233>Zuweisungsoperators</a> und
einem Ausdruck auf der rechten Seite.
<h2>Beispiele</h2>
<pre>
a = x + 42
b += c
s = "Hello"
</pre>


<a name=238>
<h1>String-Ausdruck</h1>
Ein <i>String-Ausdruck</i> ist jede Kombination von
<a href=#174>string-</a> und <a href=#171>char-</a>
Operanden und einem <a href=#234>String-Operator</a>.
<h2>Beispiele</h2>
<pre>
s + ".brd"
t + 'x'
</pre>


<a name=239>
<h1>Komma-Ausdruck</h1>
Ein <i>Komma-Ausdruck</i> ist eine Sequenz von Ausdr&uuml;cken, die mit dem
<a href=#232>Komma-Operator</a> abgegrenzt werden.
<p>
Komma-Ausdr&uuml;cke werden von links nach rechts ausgewertet, und
das Ergebnis eines Komma-Ausdrucks ist der Typ und der Wert des
am weitesten rechts stehenden Ausdrucks.
<h2>Beispiel</h2>
<pre>
i++, j++, k++
</pre>


<a name=240>
<h1>Bedingter Ausdruck</h1>
Ein <i>bedingter Ausdruck</i> verwendet den
<a href=#232>Conditional-Operator</a>, um eine Entscheidung
innerhalb eines Ausdrucks zu treffen.
<h2>Beispiel</h2>
<pre>
int a;
// ...code that calculates 'a'
string s = a ? "True" : "False";
</pre>


<a name=241>
<h1>Funktionsaufruf</h1>
Ein <i>Funktionsaufruf</i> transferiert den Programmfluss zu einer
<a href=#227>benutzerdefinierten Funktion</a> oder einer
<a href=#257>Builtin-Function</a>.
Die formalen Parameter, die in der
<a href=#227>Funktions-Definition</a> definiert sind,
werden ersetzt durch die Werte der Ausdr&uuml;cke, die als aktuelle Argumente
des Funktionsaufrufs dienen.
<h2>Beispiel</h2>
<pre>
int p = strchr(s, 'b');
</pre>


<a name=242>
<h1>Statements</h1>
Ein <i>Statement</i> kann folgendes sein:
<ul>
<li><a href=#243>Compound-Statement (Verbundanweisung)</a>
<li><a href=#245>Control-Statement (Steueranweisung)</a>
<li><a href=#244>Expression-Statement (Ausdrucksanweisung)</a>
<li><a href=#322>Builtin-Statement</a>
<li><a href=#225>Konstanten-Definition</a>
<li><a href=#226>Variablen-Definition</a>
</ul>
Statements spezifizieren die Programmausf&uuml;hrung. Wenn keine Control-Statements
vorhanden sind, werden Statements der Reihe nach in der Reihenfolge
ihres Auftretens in der ULP-Datei ausgef&uuml;hrt.


<a name=243>
<h1>Compound-Statement (Verbundanweisung)</h1>
Ein <i>Compound-Statement</i> (auch bekannt als <i>Block</i>)
ist eine Liste (kann auch leer sein) von Statements in geschweiften
Klammern (<tt>{}</tt>).
Syntaktisch kann ein Block als einzelnes Statement angesehen werden,
aber er steuert auch den G&uuml;ltigkeitsbereich von Identifiern.
Ein
<a href=#155>Identifier</a>, der innerhalb eines Blocks
deklariert wird, gilt ab der Stelle, an der er definiert wurde, bis
zur schlie&szlig;enden geschweiften Klammer.
<p>
Compound-Statements k&ouml;nnen beliebig verschachtelt werden.


<a name=244>
<h1>Expression-Statement (Ausdrucksanweisung)</h1>
Ein <i>Expression-Statement</i> ist jeder beliebige
<a href=#235>Ausdruck</a>, gefolgt von einem
<a href=#167>Semikolon</a>.
<p>
Ein Expression-Statement wird ausgef&uuml;hrt, indem der Ausdruck ausgewertet
wird. Alle Nebeneffekte dieser Auswertung sind vollst&auml;ndig abgearbeitet, bevor
das n&auml;chste
<a href=#242>Statement</a> ausgef&uuml;hrt wird.
Die meisten Expression-Statements sind
<a href=#237>Zuweisungen</a> oder
<a href=#241>Funktionsaufrufe</a>.
<p>
Ein Spezialfall ist das <i>leere Statement</i>, das nur aus einem
<a href=#167>Semikolon</a> besteht.
Ein leeres Statement tut nichts, aber es ist n&uuml;tzlich in den F&auml;llen,
in denen die ULP-Syntax ein Statement erwartet, aber Ihr Programm
keines ben&ouml;tigt.


<a name=245>
<h1>Control-Statements (Steueranweisungen)</h1>
<i>Control-Statements</i> werden verwendet, um den Programmfluss
zu steuern.
<p>
Iteration-Statements sind
<pre>
<a href=#248>do...while</a>
<a href=#249>for</a>
<a href=#253>while</a>
</pre>
Selection-Statements sind
<pre>
<a href=#250>if...else</a>
<a href=#252>switch</a>
</pre>
Jump-Statements sind
<pre>
<a href=#246>break</a>
<a href=#247>continue</a>
<a href=#251>return</a>
</pre>


<a name=246>
<h1>break</h1>
Das <i>break</i>-Statement hat die allgemeine Syntax
<pre>
break;
</pre>
und bricht sofort das <b>n&auml;chste</b> einschlie&szlig;ende
<a href=#248>do...while-</a>,
<a href=#249>for-</a>,
<a href=#252>switch-</a> oder
<a href=#253>while-</a>Statement ab.
Dies gilt ebenso f&uuml;r <i>loop members</i> von <a href=#177>Objekt-Typen</a>.
<p>
Da all diese Statements gemischt und verschachtelt werden k&ouml;nnen,
stellen Sie bitte sicher, dass <tt>break</tt> vom korrekten Statement
aus ausgef&uuml;hrt wird.


<a name=247>
<h1>continue</h1>
Das <i>continue</i>-Statement hat die allgemeine Syntax
<pre>
continue;
</pre>
und transferiert die Steuerung direkt zur Testbedingung des
<b>n&auml;chsten</b> einschlie&szlig;enden
<a href=#248>do...while-</a>,
<a href=#253>while-</a>, oder
<a href=#249>for-</a>Statements oder zum Increment-Ausdruck
des <b>n&auml;chsten</b> einschlie&szlig;enden
<a href=#253>for</a>-Statements.
<p>
Da all diese Statements gemischt und verschachtelt werden k&ouml;nnen,
stellen Sie bitte sicher, dass <tt>continue</tt> das richtige Statement
betrifft.


<a name=248>
<h1>do...while</h1>
Das <i>do...while</i>-Statement hat die allgemeine Syntax
<pre>
do statement while (condition);
</pre>
und f&uuml;hrt das <tt>statement</tt> aus, bis der <tt>condition</tt>-Ausdruck
null wird.
<p>
<tt>condition</tt> wird <b>nach</b> der ersten Ausf&uuml;hrung von
<tt>statement</tt> getestet, was bedeutet, dass das Statement
wenigstens einmal ausgef&uuml;hrt wird.
<p>
Wenn kein
<tt><a href=#246>break</a></tt> oder
<tt><a href=#251>return</a></tt>
im <tt>statement</tt> vorkommt, muss das <tt>statement</tt>
den Wert der <tt>condition</tt> ver&auml;ndern, oder <tt>condition</tt> selbst
muss sich w&auml;hrend der Auswertung &auml;ndern, um eine Endlosschleife zu
vermeiden.
<h2>Beispiel</h2>
<pre>
string s = "Trust no one!";
int i = -1;
do {
   ++i;
   } while (s[i]);
</pre>


<a name=249>
<h1>for</h1>
Das <i>for</i>-Statement hat die allgemeine Syntax
<pre>
for ([init]; [test]; [inc])-Statement
</pre>
und f&uuml;hrt folgende Schritte aus:
<ol>
<li>Wenn es einen Initialisierungs-Ausdruck <tt>init</tt> gibt, wird er ausgef&uuml;hrt.
<li>Wenn es einen <tt>test</tt>-Ausdruck gibt, wird er ausgef&uuml;hrt. Wenn das Ergebnis
ungleich null ist (oder wenn es keinen <tt>test</tt>-Ausdruck gibt), wird das
<tt>statement</tt> ausgef&uuml;hrt.
<li>Wenn es einen <tt>inc</tt>-Ausdruck gibt, wird er ausgef&uuml;hrt.
<li>Schlie&szlig;lich wird die Programmsteuerung wieder an Schritt 2 &uuml;bergeben.
</ol>
Wenn es kein
<tt><a href=#246>break</a></tt> oder
<tt><a href=#251>return</a></tt>
im <tt>statement</tt> gibt, muss der <tt>inc</tt>-Ausdruck (oder das
<tt>statement</tt>) den Wert des <tt>test</tt>-Ausdrucks beeinflussen,
oder <tt>test</tt> selbst muss sich w&auml;hrend der Auswertung &auml;ndern, um
eine Endlosschleife zu vermeiden.
<p>
Der Initialisierungs-Ausdruck <tt>init</tt> initialsiert normalerweise
einen oder mehrere Schleifenz&auml;hler. Er kann auch eine neue Variable
als Schleifenz&auml;hler definieren. Eine solche Variable ist bis zum
Ende des aktiven Blocks g&uuml;ltig.
<h2>Beispiel</h2>
<pre>
string s = "Trust no one!";
int sum = 0;
for (int i = 0; s[i]; ++i)
    sum += s[i]; // sums up the characters in s
</pre>


<a name=250>
<h1>if...else</h1>
Das <i>if...else</i>-Statement hat die allgemeine Syntax
<pre>
if (expression)
   t_statement
[else
   f_statement]
</pre>
Der bedingte <tt>Ausdruck</tt> wird ausgewertet und, wenn der Wert ungleich
null ist, wird <tt>t_statement</tt> ausgef&uuml;hrt.
Andernfalls wird <tt>f_statement</tt> ausgef&uuml;hrt, sofern der
<tt>else</tt>-Teil vorhanden ist.
<p>
Der <tt>else</tt>-Teil bezieht sich immer auf das letzte <tt>if</tt>
ohne <tt>else</tt>.
Wenn Sie etwas anderes wollen, m&uuml;ssen Sie
<a href=#165>geschweifte Klammern</a> verwenden, um
die Statements zu gruppieren, wie in
<pre>
if (a == 1) {
   if (b == 1)
      printf("a == 1 and b == 1\n");
   }
else
   printf("a != 1\n");
</pre>


<a name=251>
<h1>return</h1>
Eine <a href=#227>Funktion</a> mit einem Return-Typ
ungleich <tt>void</tt> muss mindestens ein <i>return</i>-Statement
mit der Syntax
<pre>
return expression;
</pre>
enthalten, wobei
die Auswertung von <tt>expression</tt> einen Wert ergeben muss,
der kompatibel ist mit dem Return-Typ der Funktion.
<p>
Wenn die Funktion vom Typ <tt>void</tt> ist, kann ein <tt>return</tt>-Statement
ohne <tt>expression</tt> verwendet werden, um vom Funktionsaufruf zur&uuml;ckzukehren.


<a name=252>
<h1>switch</h1>
Das <i>switch</i>-Statement hat die allgemeine Syntax
<pre>
switch (sw_exp) {
  case case_exp: case_statement
  ...
  [default: def_statement]
  }
</pre>
und erlaubt die &Uuml;bergabe der Steuerung an eines von mehreren
<tt>case</tt>-Statements (mit "case" als Label), abh&auml;ngig vom Wert des Ausdrucks
<tt>sw_exp</tt> (der vom Integral-Typ sein muss).
<p>
Jedes <tt>case_statement</tt> kann mit einem oder mehreren <tt>case</tt>-Labels
versehen sein.
Die Auswertung des Ausdrucks <tt>case_exp</tt> jedes <tt>case</tt>-Labels muss
einen konstanten Integer-Wert ergeben, der innerhalb des umschlie&szlig;enden
<tt>switch</tt>-Statements nur einmal vorkommt.
<p>
Es darf h&ouml;chstens ein <tt>default</tt>-Label vorkommen.
<p>
Nach der Auswertung von <tt>sw_exp</tt> werden die <tt>case_exp</tt>-Ausdr&uuml;cke
auf &Uuml;bereinstimmung gepr&uuml;ft. Wenn eine &Uuml;bereinstimmung gefunden wurde,
wird die Steuerung zum <tt>case_statement</tt> mit dem entsprechenden
<tt>case</tt>-Label transferiert.
<p>
Wird keine &Uuml;bereinstimmung gefunden und gibt es ein <tt>default</tt>-Label,
dann erh&auml;lt <tt>def_statement</tt> die Steuerung.
Andernfalls wird kein Statement innerhalb der
<tt>switch</tt>-Anweisung ausgef&uuml;hrt.
<p>
Die Programmausf&uuml;hrung wird nicht beeinflusst, wenn <tt>case-</tt> und
<tt>default</tt>-Labels auftauchen. Die Steuerung wird einfach an das
folgende Statement &uuml;bergeben.
<p>
Um die Programmausf&uuml;hrung am Ende einer Gruppe von Statements f&uuml;r
ein bestimmtes
<tt>case</tt> zu stoppen, verwenden Sie das <a href=#246>break</a>-Statement.
<h2>Beispiel</h2>
<pre>
string s = "Hello World";
int vowels = 0, others = 0;
for (int i = 0; s[i]; ++i)
    switch (toupper(s[i])) {
      case 'A':
      case 'E':
      case 'I':
      case 'O':
      case 'U': ++vowels;
                break;
      default: ++others;
      }
printf("There are %d vowels in '%s'\n", vowels, s);
</pre>


<a name=253>
<h1>while</h1>
Das <i>while</i>-Statement hat die allgemeine Syntax
<pre>
while (condition) statement
</pre>
und f&uuml;hrt <tt>statement</tt> so lange aus, wie der <tt>condition</tt>-Ausdruck
ungleich null ist.
<p>
<tt>condition</tt> wird <b>vor</b> der erstm&ouml;glichen Ausf&uuml;hrung
von <tt>statement</tt> getestet, was bedeutet, dass das Statement
&uuml;berhaupt nicht ausgef&uuml;hrt wird, wenn <tt>condition</tt> von Anfang an
null ist.
<p>
Wenn kein
<tt><a href=#246>break</a></tt> oder
<tt><a href=#251>return</a></tt>
im <tt>statement</tt> vorkommt, muss das <tt>statement</tt>
den Wert der <tt>condition</tt> ver&auml;ndern, oder <tt>condition</tt> selbst
muss sich w&auml;hrend der Auswertung &auml;ndern, um eine Endlosschleife zu
vermeiden.
<h2>Beispiel</h2>
<pre>
string s = "Trust no one!";
int i = 0;
while (s[i])
      ++i;
</pre>


<a name=254>
<h1>Builtins</h1>
Builtins sind <i>Konstanten</i>, <i>Variablen</i>, <i>Funktionen</i> und
<i>Statements</i>, die zus&auml;tzliche Informationen liefern
und die Manipulation der Daten erlauben.
<ul>
<li><a href=#255>Builtin-Constants</a>
<li><a href=#256>Builtin Variables</a>
<li><a href=#257>Builtin-Functions</a>
<li><a href=#322>Builtin-Statements</a>
</ul>


<a name=255>
<h1>Builtin-Constants</h1>
<i>Builtin-Constants</i> liefern Informationen &uuml;ber
Objekt-Parameter, wie die maximale empfohlene Namensl&auml;nge, Flags und so weiter.
<p>
Viele <a href=#177>Objekt-Typen</a> haben ihren
eigenen <b>Konstanten</b>-Bereich, in dem die Builtin-Constants
f&uuml;r das betreffende Objekt aufgelistet sind (siehe
z.B. <a href=#207>UL_PIN</a>).
<p>
Die folgenden Builtin-Constants sind zus&auml;tzlich zu denen definiert,
die f&uuml;r die einzelnen Objekt-Typen aufgef&uuml;hrt sind:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>EAGLE_VERSION</tt> </td><td width=20><td>EAGLE-Programm-Versionsnummer (<a href=#172>int</a>)</td></tr>
<tr><td><tt>EAGLE_RELEASE</tt> </td><td width=20><td>EAGLE-Programm-Release-Nummer (<a href=#172>int</a>)</td></tr>
<tr><td><tt>EAGLE_SIGNATURE</tt> </td><td width=20><td>ein <a href=#174>string</a>, der EAGLE-Programmnamen, -Version und -Copyright-Information enth&auml;lt</td></tr>
<tr><td><tt>EAGLE_PATH</tt> </td><td width=20><td>ein <a href=#174>string</a>, der den vollst&auml;ndigen Pfad der ausf&uuml;hrbaren EAGLE-Programmdatei enth&auml;lt</td></tr>
<tr><td><tt>EAGLE_DIR</tt> </td><td width=20><td>ein <a href=#174>string</a>, der das Verzeichnis der EAGLE Installation enth&auml;lt (<tt>$EAGLEDIR</tt>)</td></tr>
<tr><td><tt>EAGLE_HOME</tt> </td><td width=20><td>ein <a href=#174>string</a>, der das Home-Verzeichnis des Benutzers beim Start von EAGLE enth&auml;lt (<tt>$HOME</tt>)</td></tr>
<tr><td><tt>OS_SIGNATURE</tt> </td><td width=20><td>ein <a href=#174>string</a>, der eine Signatur des Betriebssystems enth&auml;lt (z.B.: Mac..., Windows... oder Linux)</td></tr>
<tr><td><tt>REAL_EPSILON</tt> </td><td width=20><td>die minimale positive <a href=#173>real</a> Zahl, so dass <tt>1.0 + REAL_EPSILON != 1.0</tt></td></tr>
<tr><td><tt>REAL_MAX</tt> </td><td width=20><td>der gr&ouml;&szlig;te m&ouml;gliche <a href=#173>real</a> Wert</td></tr>
<tr><td><tt>REAL_MIN</tt> </td><td width=20><td>der kleinste m&ouml;gliche (positive!) <a href=#173>real</a> Wert<br>die kleinste darstellbare Zahl ist <tt>-REAL_MAX</tt></td></tr>
<tr><td><tt>INT_MAX</tt> </td><td width=20><td>der gr&ouml;&szlig;te m&ouml;gliche <a href=#172>int</a> Wert</td></tr>
<tr><td><tt>INT_MIN</tt> </td><td width=20><td>der kleinste m&ouml;gliche <a href=#172>int</a> Wert</td></tr>
<tr><td><tt>PI</tt> </td><td width=20><td>der Wert von "pi" (3.14..., <a href=#173>real</a>)</td></tr>
<tr><td><tt>usage</tt> </td><td width=20><td>ein <a href=#174>string</a>, der den Text der <tt><a href=#153>#usage</a></tt>-Direktive enth&auml;lt</td></tr>
</table>
<p>
Diese Builtin-Constants enthalten die Directory-Pfade, die im
<a href=#15>Directories-Dialog</a> definiert wurden, wobei etwaige spezielle
Variablen (<tt>$HOME</tt> und <tt>$EAGLEDIR</tt>) durch ihre aktuellen Werte ersetzt wurden.
Da jeder Pfad aus mehreren Directories bestehen kann, sind diese Konstanten <a href=#174>string</a>-Arrays
mit jeweils einem einzelnen Directory in jedem Eintrag. Der erste leere Eintrag bedeutet das Ende
des Pfades:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>path_lbr[]</tt> </td><td width=20><td>Libraries</td></tr>
<tr><td><tt>path_dru[]</tt> </td><td width=20><td>Design Rules</td></tr>
<tr><td><tt>path_ulp[]</tt> </td><td width=20><td>User Language Programs</td></tr>
<tr><td><tt>path_scr[]</tt> </td><td width=20><td>Scripts</td></tr>
<tr><td><tt>path_cam[]</tt> </td><td width=20><td>CAM Jobs</td></tr>
<tr><td><tt>path_epf[]</tt> </td><td width=20><td>Projects</td></tr>
</table>
<p>
Wenn Sie diese Konstanten dazu verwenden, einen vollst&auml;ndigen Dateinamen zu bilden, so
m&uuml;ssen Sie ein Directory-Trennzeichen benutzen, wie etwa in
<pre>
string s = path_lbr[0] + '/' + "mylib.lbr";
</pre>
<p>
Die im Moment durch den <a href=#107>USE</a>-Befehl benutzten Bibliotheken:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>used_libraries[]</tt> </td><td width=20><td></td></tr>
</table>


<a name=256>
<h1>Builtin Variablen</h1>
<i>Builtin-Variablen</i> werden verwendet, um zur Laufzeit Informationen zu erhalten.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>int argc</tt> </td><td width=20><td>Anzahl der Argumente, die an den <a href=#95>RUN</a> Befehl &uuml;bergeben wurden</td></tr>
<tr><td><tt>string argv[]</tt>      </td><td width=20><td>Argumente, die an den RUN-Befehl &uuml;bergeben wurden (<tt>argv[0]</tt> ist der volle ULP-Datei-Name)</td></tr>
</table>


<a name=257>
<h1>Builtin-Functions</h1>
<i>Builtin-Functions</i> werden f&uuml;r spezielle Aufgaben ben&ouml;tigt,
z.B. formatierte Strings drucken, Daten-Arrays sortieren o.&auml;.
<p>
Sie k&ouml;nnen auch eigene <a href=#227>Funktionen</a>
definieren und sie dazu verwenden, um Ihre User-Language-Programme zu
strukturieren.
<p>
Builtin-Functions sind in folgende Kategorien eingeteilt:
<ul>
<li><a href=#258>Character-Funktionen</a>
<li><a href=#261>Datei-Funktionen</a>
<li><a href=#268>Mathematische Funktionen</a>
<li><a href=#273>Verschiedene Funktionen</a>
<li><a href=#286>Netzwerk-Funktionen</a>
<li><a href=#290>Printing-Funktionen</a>
<li><a href=#293>String-Funktionen</a>
<li><a href=#307>Zeit-Funktionen</a>
<li><a href=#311>Objekt-Funktionen</a>
<li><a href=#317>XML-Funktionen</a>
</ul>
Alphabetische Auflistung aller Builtin-Functions:
<ul>
<li><a href=#269>abs()</a>
<li><a href=#271>acos()</a>
<li><a href=#271>asin()</a>
<li><a href=#271>atan()</a>
<li><a href=#270>ceil()</a>
<li><a href=#274>cfgget()</a>
<li><a href=#274>cfgset()</a>
<li><a href=#312>clrgroup()</a>
<li><a href=#275>country()</a>
<li><a href=#271>cos()</a>
<li><a href=#276>exit()</a>
<li><a href=#272>exp()</a>
<li><a href=#277>fdlsignature()</a>
<li><a href=#264>filedir()</a>
<li><a href=#262>fileerror()</a>
<li><a href=#264>fileext()</a>
<li><a href=#263>fileglob()</a>
<li><a href=#264>filename()</a>
<li><a href=#267>fileread()</a>
<li><a href=#264>filesetext()</a>
<li><a href=#265>filesize()</a>
<li><a href=#265>filetime()</a>
<li><a href=#270>floor()</a>
<li><a href=#270>frac()</a>
<li><a href=#285>inch2u()</a>
<li><a href=#313>ingroup()</a>
<li><a href=#259>isalnum()</a>
<li><a href=#259>isalpha()</a>
<li><a href=#259>iscntrl()</a>
<li><a href=#259>isdigit()</a>
<li><a href=#259>isgraph()</a>
<li><a href=#259>islower()</a>
<li><a href=#259>isprint()</a>
<li><a href=#259>ispunct()</a>
<li><a href=#259>isspace()</a>
<li><a href=#259>isupper()</a>
<li><a href=#259>isxdigit()</a>
<li><a href=#278>language()</a>
<li><a href=#272>log()</a>
<li><a href=#272>log10()</a>
<li><a href=#279>lookup()</a>
<li><a href=#269>max()</a>
<li><a href=#285>mic2u()</a>
<li><a href=#285>mil2u()</a>
<li><a href=#269>min()</a>
<li><a href=#285>mm2u()</a>
<li><a href=#287>neterror()</a>
<li><a href=#288>netget()</a>
<li><a href=#289>netpost()</a>
<li><a href=#280>palette()</a>
<li><a href=#272>pow()</a>
<li><a href=#291>printf()</a>
<li><a href=#270>round()</a>
<li><a href=#314>setgroup()</a>
<li><a href=#315>setvariant()</a>
<li><a href=#271>sin()</a>
<li><a href=#281>sleep()</a>
<li><a href=#282>sort()</a>
<li><a href=#292>sprintf()</a>
<li><a href=#272>sqrt()</a>
<li><a href=#283>status()</a>
<li><a href=#294>strchr()</a>
<li><a href=#295>strjoin()</a>
<li><a href=#296>strlen()</a>
<li><a href=#297>strlwr()</a>
<li><a href=#298>strrchr()</a>
<li><a href=#299>strrstr()</a>
<li><a href=#300>strsplit()</a>
<li><a href=#301>strstr()</a>
<li><a href=#302>strsub()</a>
<li><a href=#303>strtod()</a>
<li><a href=#304>strtol()</a>
<li><a href=#305>strupr()</a>
<li><a href=#306>strxstr()</a>
<li><a href=#284>system()</a>
<li><a href=#310>t2day()</a>
<li><a href=#310>t2dayofweek()</a>
<li><a href=#310>t2hour()</a>
<li><a href=#310>t2minute()</a>
<li><a href=#310>t2month()</a>
<li><a href=#310>t2second()</a>
<li><a href=#310>t2string()</a>
<li><a href=#310>t2year()</a>
<li><a href=#271>tan()</a>
<li><a href=#308>time()</a>
<li><a href=#260>tolower()</a>
<li><a href=#260>toupper()</a>
<li><a href=#270>trunc()</a>
<li><a href=#285>u2inch()</a>
<li><a href=#285>u2mic()</a>
<li><a href=#285>u2mil()</a>
<li><a href=#285>u2mm()</a>
<li><a href=#316>variant()</a>
<li><a href=#318>xmlattribute()</a>
<li><a href=#318>xmlattributes()</a>
<li><a href=#319>xmlelement()</a>
<li><a href=#319>xmlelements()</a>
<li><a href=#320>xmltags()</a>
<li><a href=#321>xmltext()</a>
</ul>


<a name=258>
<h1>Character-Funktionen</h1>
Mit <i>Character-Funktionen</i> manipuliert man einzelne Zeichen.
<p>
Die folgenden Character-Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#259>isalnum()</a>
<li><a href=#259>isalpha()</a>
<li><a href=#259>iscntrl()</a>
<li><a href=#259>isdigit()</a>
<li><a href=#259>isgraph()</a>
<li><a href=#259>islower()</a>
<li><a href=#259>isprint()</a>
<li><a href=#259>ispunct()</a>
<li><a href=#259>isspace()</a>
<li><a href=#259>isupper()</a>
<li><a href=#259>isxdigit()</a>
<li><a href=#260>tolower()</a>
<li><a href=#260>toupper()</a>
</ul>


<a name=259>
<h1>is...()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Pr&uuml;fen, ob ein Zeichen in eine bestimmte Kategorie f&auml;llt.
<dt>
<b>Syntax</b>
<dd>
<tt>int isalnum(char c);</tt><br>
<tt>int isalpha(char c);</tt><br>
<tt>int iscntrl(char c);</tt><br>
<tt>int isdigit(char c);</tt><br>
<tt>int isgraph(char c);</tt><br>
<tt>int islower(char c);</tt><br>
<tt>int isprint(char c);</tt><br>
<tt>int ispunct(char c);</tt><br>
<tt>int isspace(char c);</tt><br>
<tt>int isupper(char c);</tt><br>
<tt>int isxdigit(char c);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>is...</tt>-Funktionen liefern einen Wert ungleich null, wenn das
Zeichen in die Kategorie f&auml;llt, sonst null.
</dl>
<h2>Character-Kategorien</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>isalnum </tt> </td><td width=20><td>Buchstaben (<tt>A</tt> bis <tt>Z</tt> oder <tt>a</tt> bis <tt>z</tt>) oder Digits (<tt>0</tt> bis <tt>9</tt>)</td></tr>
<tr><td><tt>isalpha </tt> </td><td width=20><td>Buchstaben (<tt>A</tt> bis <tt>Z</tt> oder <tt>a</tt> bis <tt>z</tt>)</td></tr>
<tr><td><tt>iscntrl </tt> </td><td width=20><td>Delete-Zeichen oder normale Steuerzeichen (<tt>0x7F</tt> oder <tt>0x00</tt> bis <tt>0x1F</tt>)</td></tr>
<tr><td><tt>isdigit </tt> </td><td width=20><td>Digits (<tt>0</tt> bis <tt>9</tt>)</td></tr>
<tr><td><tt>isgraph </tt> </td><td width=20><td>Druckbare Zeichen (ausser Leerzeichen)</td></tr>
<tr><td><tt>islower </tt> </td><td width=20><td>Kleinbuchstaben (<tt>a</tt> bis <tt>z</tt>)</td></tr>
<tr><td><tt>isprint </tt> </td><td width=20><td>Druckbare Zeichen (<tt>0x20</tt> bis <tt>0x7E</tt>)</td></tr>
<tr><td><tt>ispunct </tt> </td><td width=20><td>Punctuation-Zeichen (<tt>iscntrl</tt> oder <tt>isspace</tt>)</td></tr>
<tr><td><tt>isspace </tt> </td><td width=20><td>Space, Tab, Carriage Return, New Line, Vertical Tab oder Formfeed (<tt>0x09</tt> bis <tt>0x0D</tt>, <tt>0x20</tt>)</td></tr>
<tr><td><tt>isupper </tt> </td><td width=20><td>Gro&szlig;buchstaben (<tt>A</tt> bis <tt>Z</tt>)</td></tr>
<tr><td><tt>isxdigit</tt> </td><td width=20><td>Hex-Digits (<tt>0</tt> bis <tt>9</tt>, <tt>A</tt> bis <tt>F</tt>, <tt>a</tt> bis <tt>f</tt>)</td></tr>
</table>
<h2>Beispiel</h2>
<pre>
char c = 'A';
if (isxdigit(c))
   printf("%c is hex\n", c);
else
   printf("%c is not hex\n", c);
</pre>


<a name=260>
<h1>to...()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Buchstaben in Gro&szlig;- oder Kleinbuchstaben umwandeln.
<dt>
<b>Syntax</b>
<dd>
<tt>char tolower(char c);</tt><br>
<tt>char toupper(char c);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>tolower</tt>-Funktion gibt den konvertierten Buchstaben zur&uuml;ck,
wenn <tt>c</tt> ein Gro&szlig;buchstabe ist. Alle anderen Zeichen werden
unver&auml;ndert zur&uuml;ckgegeben.<br>
Die <tt>toupper</tt>-Funktion gibt den konvertierten Buchstaben zur&uuml;ck,
wenn <tt>c</tt> ein Kleinbuchstabe ist. Alle anderen Zeichen werden
unver&auml;ndert zur&uuml;ckgegeben.
</dl>
<b>Siehe auch</b> <a href=#305>strupr</a>,
<a href=#297>strlwr</a>


<a name=261>
<h1>Datei-Funktionen</h1>
<i>Datei-Funktionen</i> behandeln Datei-Namen, -Gr&ouml;&szlig;en
und -Zeitstempel.
<p>
Folgende Datei-Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#262>fileerror()</a>
<li><a href=#263>fileglob()</a>
<li><a href=#264>filedir()</a>
<li><a href=#264>fileext()</a>
<li><a href=#264>filename()</a>
<li><a href=#267>fileread()</a>
<li><a href=#264>filesetext()</a>
<li><a href=#265>filesize()</a>
<li><a href=#265>filetime()</a>
</ul>
Weitere Informationen &uuml;ber Ausgaben in eine Datei, finden Sie unter <a href=#327>output()</a>.


<a name=262>
<h1>fileerror()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeigt den Status von I/O-Operationen.
<dt>
<b>Syntax</b>
<dd>
<tt>int fileerror();</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Gibt die <tt>fileerror</tt>-Funktion <tt>0</tt> zur&uuml;ck, ist alles in Ordnung.
</dl>
<b>Siehe auch</b> <a href=#327>output</a>,
<a href=#291>printf</a>,
<a href=#267>fileread</a>
<p>
<tt>fileerror</tt> pr&uuml;ft den Status beliebiger I/O-Operation, die seit
dem letzten Aufruf dieser Funktion ausgef&uuml;hrt wurden und gibt <tt>0</tt> zur&uuml;ck,
wenn alles in Ordnung war. Verursachte eine der I/O-Operationen einen Fehler,
wird ein Wert ungleich <tt>0</tt> ausgegeben.
<p>
Vor der Ausf&uuml;hrung von I/O-Operationen sollten Sie mit <tt>fileerror</tt> den
Fehlerstatus zur&uuml;cksetzten. Nach der Ausf&uuml;hrung der I/O-Operationen rufen Sie
<tt>fileerror</tt>erneut auf, um zu pr&uuml;fen ob alles in Ordnung war.
<p>
Wenn <tt>fileerror</tt> einen Wert ungleich <tt>0</tt> ausgibt (und so einen Fehler anzeigt),
wird dem Benutzer eine Fehlermeldung angezeigt.
<h2>Beispiel</h2>
<pre>
fileerror();
output("file.txt", "wt") {
  printf("Test\n");
  }
if (fileerror())
   exit(1);
</pre>


<a name=263>
<h1>fileglob()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Sucht in einem Verzeichnis.
<dt>
<b>Syntax</b>
<dd>
<tt>int fileglob(string &amp;array[], string pattern);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die Funktion <tt>fileglob</tt> liefert die Anzahl der Eintr&auml;ge, die in <tt>array</tt> kopiert wurden.
</dl>
<b>Siehe auch </b> <a href=#335>dlgFileOpen()</a>,
<a href=#335>dlgFileSave()</a>
<p>
<tt>fileglob</tt> sucht in einem Verzeichnis nach <tt>pattern</tt>.
<p>
<tt>pattern</tt> kann <tt>'*'</tt> und <tt>'?'</tt> als Platzhalter enthalten.
Endet <tt>pattern</tt> mit einem <tt>'/'</tt>, wird der Inhalt des angegebenen Verzeichnis zur&uuml;ckgegeben.
<p>
Namen die im resultierenden <tt>array</tt> mit einem <tt>'/'</tt> enden, sind Verzeichnisnamen.
<p>
Das <tt>array</tt> ist alphabetisch sortiert, die Verzeichnisse kommen zuerst.
<p>
Die Sondereintr&auml;ge <tt>'.'</tt> und <tt>'..'</tt> (f&uuml;r das aktuelle und das &uuml;bergeordnete Verzeichnis)
werden nie in <tt>array</tt> geschrieben.
<p>
Wenn <tt>pattern</tt> nicht gefunden wird, oder wenn Sie kein Recht haben, das angegebene Verzeichnis
zu durchsuchen, ist das <tt>array</tt> leer.
<h2>Hinweis f&uuml;r Windows-Anwender</h2>
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
Das Pfad-Trennzeichen in <tt>array</tt> ist immer ein <b>Forward-Slash</b> (Schr&auml;gstrich).
So ist sichergestellt, dass User-Language-Progamme betriebssystemunabh&auml;ngig arbeiten.
In <tt>pattern</tt> wird der <b>backslash</b> (<tt>'\'</tt>) auch als Pfad-Trennzeichen behandelt.
<p>
Die Sortierreihenfolge unter Windows unterscheidet nicht zwischen Gro&szlig;- und Kleinschreibung.
</td></tr></table>
<h2>Beispiel</h2>
<pre>
string a[];
int n = fileglob(a, "*.brd");
</pre>


<a name=264>
<h1>Dateinamens-Funktionen</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Datei-Namen in seine Einzelteile aufspalten.
<dt>
<b>Syntax</b>
<dd>
<tt>string filedir(string file);</tt><br>
<tt>string fileext(string file);</tt><br>
<tt>string filename(string file);</tt><br>
<tt>string filesetext(string file, string newext);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>filedir   </tt> liefert das Directory von <tt>file</tt> (einschlie&szlig;lich Laufwerksbuchstaben unter Windows).<br>
<tt>fileext   </tt> liefert die Extension von <tt>file</tt>.<br>
<tt>filename  </tt> liefert den File-Namen von <tt>file</tt> (einschlie&szlig;lich Extension).<br>
<tt>filesetext</tt> liefert <tt>file</tt> mit Extension auf <tt>newext</tt> gesetzt.
</dl>
<b>Siehe auch</b> <a href=#265>Datei-Daten-Funktionen</a>
<h2>Beispiel</h2>
<pre>
if (board) board(B) {
  output(filesetext(B.name, ".out")) {
    ...
    }
  }
</pre>


<a name=265>
<h1>Datei-Daten-Funktionen</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Holt den Timestamp und die Gr&ouml;&szlig;e einer Datei.
<dt>
<b>Syntax</b>
<dd>
<tt>int filesize(string filename);</tt><br>
<tt>int filetime(string filename);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>filesize</tt> liefert die Gr&ouml;&szlig;e (in Byte) der Datei.<br>
<tt>filetime</tt> liefert den Timestamp der Datei in einem Format, das mit den <a href=#307>Zeit-Funktionen</a> benutzt wird.
</dl>
<b>Siehe auch</b> <a href=#308>time</a>,
<a href=#264>Dateinamens-Funktionen</a>
<h2>Beispiel</h2>
<pre>
board(B)
  printf("Board: %s\nSize: %d\nTime: %s\n",
         B.name, filesize(B.name),
         t2string(filetime(B.name)));
</pre>


<a name=266>
<h1>Datei-Einlese-Funktionen</h1>
<i>Datei-Einlese-Funktionen</i> werden verwendet um Daten von Dateien einzulesen.
<p>
Folgendes Datei-Einlesen ist m&ouml;glich:
<ul>
<li><a href=#267>fileread()</a>
</ul>
Siehe <a href=#327>output()</a> f&uuml;r Informationen zum Thema 'In eine Datei schreiben'.


<a name=267>
<h1>fileread()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Liest Daten aus einer Datei aus.
<dt>
<b>Syntax</b>
<dd>
<tt>int fileread(<i>dest</i>, string file);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>fileread</tt> liefert die Anzahl der Objekte, die aus einer Datei ausgelesen wurden.<br>
Die tats&auml;chliche Bedeutung des R&uuml;ckgabewerts h&auml;ngt vom <tt>dest</tt>-Typ ab.
</dl>
<b>Siehe auch</b> <a href=#279>lookup</a>,
<a href=#300>strsplit</a>,
<a href=#262>fileerror</a>
<p>
Wenn <tt>dest</tt> ein Character-Array ist, werden Bin&auml;r-Daten aus der Datei ausgelesen.
Der R&uuml;ckgabewert entspricht dann der Anzahl der Bytes, die in das Character-Array
eingelesen wurden (das entspricht der Dateigr&ouml;&szlig;e).
<p>
Wenn <tt>dest</tt> ein String-Array ist, wird die Datei als Textdatei gelesen (eine Zeile
pro Array-Member). Der R&uuml;ckgabewert zeigt die Anzahl der Zeilen, die in das Array
eingelesen wurden. Newline-Zeichen werden entfernt.
<p>
Wenn <tt>dest</tt> ein String ist, wird die ganze Datei in diesen String eingelesen. Der
R&uuml;ckgabewert ist die L&auml;nge des Strings (die nicht unbedingt der Dateigr&ouml;&szlig;e entsprechen
muss, wenn das Betriebssystem Textdateien mit "cr/lf" anstatt "newline" am Zeilenende
speichert).
<h2>Beispiel</h2>
<pre>
char b[];
int nBytes = fileread(b, "data.bin");
string lines[];
int nLines = fileread(lines, "data.txt");
string text;
int nChars = fileread(text, "data.txt");
</pre>


<a name=268>
<h1>Mathematische Funktionen</h1>
<i>Mathematische Funktionen</i> werden dazu verwendet, matematische
Operationen auszuf&uuml;hren.
<p>
Die folgenden mathematischen Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#269>abs()</a>
<li><a href=#271>acos()</a>
<li><a href=#271>asin()</a>
<li><a href=#271>atan()</a>
<li><a href=#270>ceil()</a>
<li><a href=#271>cos()</a>
<li><a href=#272>exp()</a>
<li><a href=#270>floor()</a>
<li><a href=#270>frac()</a>
<li><a href=#272>log()</a>
<li><a href=#272>log10()</a>
<li><a href=#269>max()</a>
<li><a href=#269>min()</a>
<li><a href=#272>pow()</a>
<li><a href=#270>round()</a>
<li><a href=#271>sin()</a>
<li><a href=#272>sqrt()</a>
<li><a href=#270>trunc()</a>
<li><a href=#271>tan()</a>
</ul>
<h2>Fehlermeldungen</h2>
Wenn die Argumente eines mathematischen Funktionsaufrufs zu einem Fehler f&uuml;hren,
zeigen die Fehlermeldungen die aktuellen Werte der Argumente. Deshalb
f&uuml;hren die Statements
<pre>
real x = -1.0;
real r = sqrt(2 * x);
</pre>
zur Fehlermeldung
<pre>
Invalid argument in call to 'sqrt(-2)'
</pre>


<a name=269>
<h1>Absolutwert-, Maximum- und Minimum-Funktion</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Absolutwert-, Maximum- und Minimum-Funktion.
<dt>
<b>Syntax</b>
<dd>
<tt>type abs(type x);</tt><br>
<tt>type max(type x, type y);</tt><br>
<tt>type min(type x, type y);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>abs</tt> liefert den absoluten Wert von <tt>x</tt>.<br>
<tt>max</tt> liefert das Maximum von <tt>x</tt> und <tt>y</tt>.<br>
<tt>min</tt> liefert das Minimum von <tt>x</tt> und <tt>y</tt>.
<p>
Der Return-Typ dieser Funktionen ist identisch mit dem gr&ouml;&szlig;eren Typ der Argumente.
<tt>type</tt> muss
<tt><a href=#171>char</a></tt>,
<tt><a href=#172>int</a></tt> oder
<tt><a href=#173>real</a></tt> sein.
</dl>
<h2>Beispiel</h2>
<pre>
real x = 2.567, y = 3.14;
printf("The maximum is %f\n", max(x, y));
</pre>


<a name=270>
<h1>Rundungs-Funktionen</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Rundungs-Funktionen.
<dt>
<b>Syntax</b>
<dd>
<tt>real ceil(real x);</tt><br>
<tt>real floor(real x);</tt><br>
<tt>real frac(real x);</tt><br>
<tt>real round(real x);</tt><br>
<tt>real trunc(real x);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>ceil </tt> liefert den kleinsten Integer-Wert nicht kleiner als <tt>x</tt>.<br>
<tt>floor</tt> liefert den gr&ouml;&szlig;ten Integer-Wert nicht gr&ouml;&szlig;er als <tt>x</tt>.<br>
<tt>frac </tt> liefert den Dezimalbruch von <tt>x</tt>.<br>
<tt>round</tt> liefert <tt>x</tt> gerundet auf den n&auml;chsten Integer-Wert.<br>
<tt>trunc</tt> liefert den ganzzahligen Teil von <tt>x</tt>.
</dl>
<h2>Beispiel</h2>
<pre>
real x = 2.567;
printf("The rounded value of %f is %f\n", x, round(x));
</pre>


<a name=271>
<h1>Trigonometrische Funktionen</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Trigonometrische Funktionen.
<dt>
<b>Syntax</b>
<dd>
<tt>real acos(real x);</tt><br>
<tt>real asin(real x);</tt><br>
<tt>real atan(real x);</tt><br>
<tt>real cos(real x);</tt><br>
<tt>real sin(real x);</tt><br>
<tt>real tan(real x);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>acos</tt> liefert den arc-cosinus von <tt>x</tt>.<br>
<tt>asin</tt> liefert den arc-sinus von <tt>x</tt>.<br>
<tt>atan</tt> liefert den arc-tangens von <tt>x</tt>.<br>
<tt>cos </tt> liefert den cosinus von <tt>x</tt>.<br>
<tt>sin </tt> liefert den sinus von <tt>x</tt>.<br>
<tt>tan </tt> liefert den tangens von <tt>x</tt>.
</dl>
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PI</tt> </td><td width=20><td>der Wert von "pi" (3.14...)</td></tr>
</table>
<h2>Anmerkung</h2>
Winkelangaben erfolgen in rad (Bogenma&szlig;).
<h2>Beispiel</h2>
<pre>
real x = PI / 2;
printf("The sine of %f is %f\n", x, sin(x));
</pre>


<a name=272>
<h1>Exponential-Funktionen</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Exponential-Funktionen.
<dt>
<b>Syntax</b>
<dd>
<tt>real exp(real x);</tt><br>
<tt>real log(real x);</tt><br>
<tt>real log10(real x);</tt><br>
<tt>real pow(real x, real y);</tt><br>
<tt>real sqrt(real x);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>exp  </tt> liefert <i>e</i> hoch <tt>x</tt>.<br>
<tt>log  </tt> liefert den nat&uuml;rlichen Logarithmus von <tt>x</tt>.<br>
<tt>log10</tt> liefert den Zehnerlogarithmus von <tt>x</tt>.<br>
<tt>pow  </tt> liefert den Wert von <tt>x</tt> hoch <tt>y</tt>.<br>
<tt>sqrt </tt> liefert die Quadratwurzel von <tt>x</tt>.
</dl>
<h2>Beispiel</h2>
<pre>
real x = 2.1;
printf("The square root of %f is %f\n", x, sqrt(x));
printf("The 3rd root of %f is %f\n", x, pow(x, 1.0/3));
</pre>


<a name=273>
<h1>Sonstige Funktionen</h1>
<i>Sonstige Funktionen</i> werden f&uuml;r weitere Aufgaben ben&ouml;tigt.
<p>
Die folgenden sonstigen Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#275>country()</a>
<li><a href=#276>exit()</a>
<li><a href=#277>fdlsignature()</a>
<li><a href=#278>language()</a>
<li><a href=#279>lookup()</a>
<li><a href=#280>palette()</a>
<li><a href=#282>sort()</a>
<li><a href=#283>status()</a>
<li><a href=#284>system()</a>
<li><a href=#274>Konfigurations-Parameter</a>
<li><a href=#285>Einheiten-Konvertierung</a>
</ul>


<a name=274>
<h1>Konfigurations-Parameter</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Konfigurations-Parameter abspeichern und laden.
<dt>
<b>Syntax</b>
<dd>
<tt>string cfgget(string name[, string default]);</tt><br>
<tt>void cfgset(string name, string value);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>cfgget</tt> liefert den Wert des Parameters, der unter dem Namen <tt>name</tt>
gespeichert ist. Wurde kein solcher Parameter gespeichert, so wird der optionale
Standardwert <tt>default</tt> geliefert (bzw. ein leerer String, falls kein
<tt>default</tt> angegeben wurde).
</dl>
Die <tt>cfgget</tt>-Funktion liefert den Wert, der mit einem vorangegangenen
Aufruf von <tt>cfgset()</tt> gespeichert wurde.
<p>
Die <tt>cfgset</tt>-Funktion setzt den Parameter mit dem Namen <tt>name</tt> auf
den Wert <tt>value</tt>.
<p>
G&uuml;ltige Zeichen f&uuml;r <tt>name</tt> sind
<tt>'A'</tt>-<tt>'Z'</tt>,
<tt>'a'</tt>-<tt>'z'</tt>,
<tt>'0'</tt>-<tt>'9'</tt>,
<tt>'.'</tt> and
<tt>'_'</tt>.<br>
Parameternamen unterscheiden Gro&szlig;-/Kleinschreibung.
<p>
Die Parameter werden in der eaglerc-Datei des Benutzers gespeichert.
Um sicherzustellen, dass verschiedene User Language Programme sich nicht
gegenseitig die Parameter &uuml;berscheiben, falls sie die gleichen Parameternamen
verwenden, wird empfohlen, dem Parameternamen den Namen des ULPs voranzustellen.
Beispielsweise k&ouml;nnte ein ULP namens <tt>mytool.ulp</tt>, welches einen Parameter
namens <tt>MyParam</tt> verwendet, diesen unter dem Namen
<pre>
mytool.MyParam
</pre>
speichern.
<p>
Da die Konfigurations-Parameter in der eaglerc-Datei gespeichert werden, welche
auch alle anderen benutzerspezifischen EAGLE-Parameter enth&auml;lt, k&ouml;nnen auch die
EAGLE-Parameter mit <tt>cfgget()</tt> und <tt>cfgset()</tt> angesprochen werden.
Um sicherzustellen, dass keine ULP-Parameter mit etwaigen EAGLE-Parametern
kollidieren, mu&szlig; den EAGLE-Parametern <tt>"EAGLE:"</tt> vorangestellt werden, wie in
<pre>
EAGLE:Option.XrefLabelFormat
</pre>
Beachten Sie bitte, dass es keine Dokumentation aller internen EAGLE-Parameter
und deren Speicherung in der eaglerc-Datei gibt. Seien Sie auch besonders
vorsichtig, wenn Sie solche Parameter ver&auml;ndern! Wie bei der eaglerc-Datei selbst
gilt auch hier, dass Sie diese Parameter nur manipulieren sollten, wenn Sie sich
dar&uuml;ber im Klaren sind, was Sie tun! Bei einigen EAGLE-Parametern kann ein
Neustart von EAGLE erforderlich sein, damit &Auml;nderungen wirksam werden.
<p>
Die User Language Parameter werden in der eaglerc-Datei mit einem vorangestellten
<tt>"ULP:"</tt> gespeichert. Daher darf dieser Pr&auml;fix optional auch den User Language
Parameternamen vorangestellt werden, wie in
<pre>
ULP:mytool.MyParam
</pre>
<h2>Beispiel</h2>
<pre>
string MyParam = cfgget("mytool.MyParam", "SomeDefault");
MyParam = "OtherValue";
cfgset("mytool.MyParam", MyParam);
</pre>


<a name=275>
<h1>country()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Liefert den L&auml;ndercode des verwendeten Systems.
<dt>
<b>Syntax</b>
<dd>
<tt>string country();</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>country</tt> liefert einen String bestehend aus zwei Gro&szlig;buchstaben,
der das auf dem aktuellen System eingestellte Land angibt.
Falls sich diese Einstellung nicht ermitteln l&auml;sst, wird der Standardwert "US"
zur&uuml;ckgegeben.
</dl>
<b>Siehe auch</b> <a href=#278>language</a>
<h2>Example</h2>
<pre>
dlgMessageBox("Your country code is: " + country());
</pre>


<a name=276>
<h1>exit()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Beendet ein User-Language-Programm.
<dt>
<b>Syntax</b>
<dd>
<tt>void exit(int result);</tt><br>
<tt>void exit(string command);</tt>
</dl>
<b>Siehe auch</b> <a href=#95>RUN</a>
<p>
Die <tt>exit</tt>-Funktion beendet die Ausf&uuml;hrung des User-Language-Programms.<br>
Wird <tt>result</tt> (integer) angegeben, wird es als <a href=#146>R&uuml;ckgabewert</a>
des Programms benutzt.<br>
Wird ein <tt>command</tt>-String angegeben, wird dieser Befehl genauso ausgef&uuml;hrt, als
w&auml;re &uuml;ber die Kommandozeile direkt nach dem RUN-Befehl eingegeben worden. In diesem
Fall wird der R&uuml;ckgabewert des ULPs auf <tt>EXIT_SUCCESS</tt> gesetzt.
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>EXIT_SUCCESS</tt>   </td><td width=20><td>R&uuml;ckgabewert f&uuml;r erfolgreiche Programmausf&uuml;hrung (Wert <tt>0</tt>)</td></tr>
<tr><td><tt>EXIT_FAILURE</tt>   </td><td width=20><td>R&uuml;ckgabewert f&uuml;r fehlerhafte Programmausf&uuml;hrung (Wert <tt>-1</tt>)</td></tr>
</table>


<a name=277>
<h1>fdlsignature()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Berechnet eine digitale Signatur f&uuml;r Premier Farnells <i>Design Link</i>.
<dt>
<b>Syntax</b>
<dd>
<tt>string fdlsignature(string s, string key);</tt>
</dl>
Die <tt>fdlsignature</tt>-Funktion wird benutzt f&uuml;r die Berechnung einer digitalen
Signatur bei der Verwendung von Premier Farnells <i>Design Link</i> Interface.


<a name=278>
<h1>language()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Liefert den Sprachcode des verwendeten Systems.
<dt>
<b>Syntax</b>
<dd>
<tt>string language();</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>language</tt> liefert einen String bestehend aus zwei Kleinbuchstaben,
der die auf dem aktuellen System verwendete Sprache angibt.
Falls sich diese Einstellung nicht ermitteln l&auml;sst, wird der Standardwert "en"
zur&uuml;ckgegeben.
</dl>
<b>See also</b> <a href=#275>country</a>
<p>
Die <tt>language</tt>-Funktion kann dazu benutzt werden, in einem ULP unterschiedliche
Texte zu verwenden, je nachdem welche Sprache das aktuelle System verwendet.
<p>
In dem folgenden Beispiel sind alle im ULP verwendeten Strings im Array <tt>I18N[]</tt>
aufgelistet, beginnend mit einem String der die verschiedenen Sprachcodes enth&auml;lt
die dieses ULP unterst&uuml;tzt. Beachten Sie die <tt>vtab</tt>-Zeichen, die dazu
benutzt werden, die einzelnen Teile jedes Strings zu trennen (diese sind wichtig
f&uuml;r die <tt>lookup</tt>-Funktion) und die Benutzung der Kommas um die Strings
zu trennen. Die eigentliche Arbeit wird in der Funktion <tt>tr()</tt> gemacht,
welche die &uuml;bersetzte Version des &uuml;bergebenen Strings zur&uuml;ckliefert.
Sollte der urspr&uuml;ngliche String im <tt>I18N</tt>-Array nicht gefunden werden,
oder es keine &Uuml;bersetzung f&uuml;r die aktuelle Sprache geben, so wird der urspr&uuml;ngliche
String un&uuml;bersetzt verwendet.
<p>
Die erste im <tt>I18N</tt>-Array definierte Sprache muss diejenige sein, in der
die im restlichen ULP verwendeten Strings geschrieben sind, und sollte generell
Englisch sein um das Programm einer m&ouml;glichst gro&szlig;en Zahl von Benutzern
zug&auml;nglich zu machen.
<h2>Beispiel</h2>
<pre>
string I18N[] = {
  "en\v"
  "de\v"
  "it\v"
  ,
  "I18N Demo\v"
  "Beispiel f&uuml;r Internationalisierung\v"
  "Esempio per internazionalizzazione\v"
  ,
  "Hello world!\v"
  "Hallo Welt!\v"
  "Ciao mondo!\v"
  ,
  "+Ok\v"
  "+Ok\v"
  "+Approvazione\v"
  ,
  "-Cancel\v"
  "-Abbrechen\v"
  "-Annullamento\v"
  };
int Language = strstr(I18N[0], language()) / 3;
string tr(string s)
{
  string t = lookup(I18N, s, Language, '\v');
  return t ? t : s;
}
dlgDialog(tr("I18N Demo")) {
  dlgHBoxLayout dlgSpacing(350);
  dlgLabel(tr("Hello world!"));
  dlgHBoxLayout {
    dlgPushButton(tr("+Ok")) dlgAccept();
    dlgPushButton(tr("-Cancel")) dlgReject();
    }
  };
</pre>


<a name=279>
<h1>lookup()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Sucht Daten in einem String-Array.
<dt>
<b>Syntax</b>
<dd>
<tt>string lookup(string array[], string key, int field_index[, char separator]);</tt><br>
<tt>string lookup(string array[], string key, string field_name[, char separator]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>lookup</tt> liefert den Wert des Feldes, das durch <tt>field_index</tt>
oder <tt>field_name</tt> markiert wird.<br>
Existiert dieses Feld nicht oder wird kein passender String f&uuml;r <tt>key</tt> gefunden,
kommt ein leerer String zur&uuml;ck.
</dl>
<b>Siehe auch</b> <a href=#267>fileread</a>,
<a href=#300>strsplit</a>
<p>
Ein <tt>array</tt> das mit <tt>lookup()</tt> benutzt werden kann, besteht aus Text-Strings,
wobei jeder String einen Daten-Record darstellt.
<p>
Jeder Daten-Record enth&auml;lt eine beliebige Anzahl von Feldern, die durch das Zeichen
<tt>separator</tt> (default ist <tt>'\t'</tt>, der Tabulator) getrennt sind.
Das erste Feld in einem Record wird als <tt>key</tt> benutzt und hat die Nummer <tt>0</tt>.
<p>
Alle Records m&uuml;ssen eindeutige <tt>key</tt>-Felder haben. Keines der <tt>key</tt>-Felder
darf leer sein - ansonsten ist nicht definiert welcher Record gefunden wird.
<p>
Enth&auml;lt der erste String in <tt>array</tt> einen "Header"-Record (der Record, in dem der
Inhalt der Felder beschrieben wird), bestimmt <tt>lookup</tt> mit einem String
<tt>field_name</tt> automatisch den Index des Feldes. Das erlaubt es, die <tt>lookup</tt>-Funktion
zu benutzen, ohne genau zu wissen, welcher Feld-Index die gew&uuml;nschten Daten enth&auml;lt.<br>
Es bleibt dem Benutzer &uuml;berlassen, sicherzustellen, dass der erste Record tats&auml;chlich
Header-Informationen enth&auml;lt.
<p>
Ist der <tt>key</tt>-Parameter beim Aufruf von <tt>lookup()</tt> ein leerer String,
wird der erste String von <tt>array</tt> verwendet. Das erlaubt dem Programm zu
bestimmen, ob ein Header-Record mit den gew&uuml;nschten Feld-Namen existiert.
<p>
Enth&auml;lt ein Feld das <tt>separator</tt>-Zeichen, muss es in Anf&uuml;hrungszeichen
eingeschlossen werden (wie in <tt>"abc;def"</tt>, wobei hier das Semikolon (<tt>';'</tt>)
das Trennzeichen ist). Das gilt auch f&uuml;r Felder, die Anf&uuml;hrungszeichen
(<tt>"</tt>) enthalten, wobei die Anf&uuml;hrungszeichen im Feld verdoppelt werden m&uuml;ssen
(wie hier: <tt>"abc;""def"";ghi"</tt> ergibt also <tt>abc;"def";ghi</tt>).<br>
<b>Es wird empfohlen den "tab"-Separator (default) zu verwenden, der diese Probleme nicht
kennt (kein Feld kann einen Tabulator enthalten).</b>
<p>
Hier folgt eine Beispiel-Daten-Datei (zur besseren Lesbarkeit wurde der Separator <tt>';'</tt> verwendet):
<pre>
Name;Manufacturer;Code;Price
7400;Intel;I-01-234-97;$0.10
68HC12;Motorola;M68HC1201234;$3.50
</pre>
<h2>Beispiel</h2>
<pre>
string OrderCodes[];
if (fileread(OrderCodes, "ordercodes") &gt; 0) {
   if (lookup(OrderCodes, "", "Code", ';')) {
      schematic(SCH) {
        SCH.parts(P) {
          string OrderCode;
          // both following statements do exactly the same:
          OrderCode = lookup(OrderCodes, P.device.name, "Code", ';');
          OrderCode = lookup(OrderCodes, P.device.name, 2, ';');
          }
        }
      }
   else
      dlgMessageBox("Missing 'Code' field in file 'ordercodes');
   }
</pre>


<a name=280>
<h1>palette()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Liefert Farbpaletten-Information.
<dt>
<b>Syntax</b>
<dd>
<tt>int palette(int index[, int type]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>palette</tt>-Funktion liefert einen ARGB-Wert als Integer-Zahl der Form 0xaarrggbb,
oder den Typ der momentan verwendeten Palette (abh&auml;ngig vom Wert von <tt>index</tt>).
</dl>
Die <tt>palette</tt>-Funktion liefert den ARGB-Wert der Farbe mit dem gegebenen
<tt>index</tt> (welcher im Bereich 0..PALETTE_ENTRIES-1 liegen kann). Falls <tt>type</tt>
nicht angegeben ist (oder den Wert <tt>-1</tt> hat) wird die Palette verwendet, die dem
aktuellen Editor-Fenster zugewiesen ist. Ansonsten gibt <tt>type</tt> an, welche
Palette verwendet werden soll (PALETTE_BLACK, PALETTE_WHITE oder PALETTE_COLORED).
<p>
Der spezielle Wert <tt>-1</tt> f&uuml;r <tt>index</tt> bewirkt, dass die Funktion den
Typ der momentan vom Editor-Fenster verwendeten Palette liefert.
<p>
Falls <tt>index</tt> oder <tt>type</tt> ausserhalb des g&uuml;ltigen Wertebereichs liegen
wird eine Fehlermeldung ausgegeben und das ULP abgebrochen.
<h2>Konstanten</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PALETTE_TYPES</tt>   </td><td width=20><td>die Anzahl der Palette-Typen (3)</td></tr>
<tr><td><tt>PALETTE_BLACK</tt>  </td><td width=20><td>die Palette f&uuml;r schwarzen Hintergrund (0)</td></tr>
<tr><td><tt>PALETTE_WHITE</tt>  </td><td width=20><td>die Palette f&uuml;r wei&szlig;en Hintergrund (1)</td></tr>
<tr><td><tt>PALETTE_COLORED</tt>  </td><td width=20><td>die Palette f&uuml;r farbigen Hintergrund (2)</td></tr>
<tr><td><tt>PALETTE_ENTRIES</tt>  </td><td width=20><td>die Anzahl der Farben pro Palette (64)</td></tr>
</table>


<a name=281>
<h1>sleep()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Pause im User-Language-Programm einlegen.
<dt>
<b>Syntax</b>
<dd>
<tt>void sleep(int seconds);</tt><br>
</dl>
<b>Siehe auch</b> <a href=#308>time()</a>
<p>
Die <tt>sleep</tt>-Funktion macht f&uuml;r <tt>seconds</tt> Sekunden eine Pause im
User-Language-Programm.
</dl>


<a name=282>
<h1>sort()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Sortiert ein Array oder einen Satz von Arrays.
<dt>
<b>Syntax</b>
<dd>
<tt>void sort(int number, array1[, array2,...]);</tt>
</dl>
Die <tt>sort</tt>-Funktion sortiert entweder direkt ein <tt>array1</tt>,
oder sie sortiert einen Satz von Arrays (beginnend mit <tt>array2</tt>),
wobei <tt>array1</tt> ein <b>int</b>-Array ist, das als Pointer-Array
verwendet wird.
<p>
In jedem Fall definiert das Argument <tt>number</tt> die Zahl der
Eintr&auml;ge im Array oder in den Arrays.
<h2>Einzelnes Array sortieren</h2>
Wenn die <tt>sort</tt>-Funktion mit einem einzelnen Arrray aufgerufen wird,
wird dieses Array direkt sortiert, wie im folgenden Beispiel:
<pre>
string A[];
int n = 0;
A[n++] = "World";
A[n++] = "Hello";
A[n++] = "The truth is out there...";
sort(n, A);
for (int i = 0; i &lt; n; ++i)
    printf(A[i]);
</pre>
<h2>Einen Satz von Arrays sortieren</h2>
Wenn die <tt>sort</tt>-Funktion mit mehr als einem Array aufgerufen wird,
muss das erste Array ein <b>int</b>-Array sein, w&auml;hrend alle anderen
Arrays von jedem Typ sein k&ouml;nnen. Sie enthalten die zu sortierenden Daten.
Das folgende Beispiel zeigt, wie das erste Array als Pointer verwendet
wird:
<pre>
numeric string Nets[], Parts[], Instances[], Pins[];
int n = 0;
int index[];
schematic(S) {
  S.nets(N) N.pinrefs(P) {
    Nets[n] = N.name;
    Parts[n] = P.part.name;
    Instances[n] = P.instance.name;
    Pins[n] = P.pin.name;
    ++n;
    }
  sort(n, index, Nets, Parts, Instances, Pins);
  for (int i = 0; i &lt; n; ++i)
      printf("%-8s %-8s %-8s %-8s\n",
             Nets[index[i]], Parts[index[i]],
             Instances[index[i]], Pins[index[i]]);
  }
</pre>
Die Idee dahinter ist, dass an ein Netz mehrere Pins angeschlossen sein k&ouml;nnen.
In einer Netzliste wollen Sie unter Umst&auml;nden die Netznamen sortieren und
innerhalb eines Netzes die Bauteilnamen, und so weiter.
<p>
Beachten Sie die Verwendung des Schl&uuml;sselworts <tt>numeric</tt> in den
String-Arrays. Das f&uuml;hrt dazu, dass die String-Sortierung einen numerischen
Teil am Ende des Namens ber&uuml;cksichtigt (IC1, IC2,... IC9, IC10 anstelle von
IC1, IC10, IC2,...IC9).
<p>
Wenn man einen Satz von Arrays sortiert, muss das erste (Index-)Array
vom Typ <tt><a href=#172>int</a></tt> sein und braucht nicht
initialisiert zu werden. Jeder vor dem Aufruf der <tt>sort</tt>-Funktion
vorhandene Inhalt wird mit den resultierenden Indexwerten &uuml;berschrieben.


<a name=283>
<h1>status()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeigt eine Statusmeldung in der Statuszeile an.
<dt>
<b>Syntax</b>
<dd>
<tt>void status(string message);</tt><br>
</dl>
<b>Siehe auch</b> <a href=#336>dlgMessageBox()</a>
<p>
Die <tt>status</tt>-Funktion zeigt die angegebene <tt>message</tt> in der Statuszeile
des Editor-Fensters an, in dem das ULP l&auml;uft.


<a name=284>
<h1>system()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
F&uuml;hrt ein externes Programm aus.
<dt>
<b>Syntax</b>
<dd>
<tt>int system(string command);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>system</tt>-Funktion liefert den "Exit Status" des Befehls zur&uuml;ck. Dieser
ist normalerweise <tt>0</tt> wenn alles gut gegangen ist, und ungleich <tt>0</tt>
wenn ein Fehler aufgetreten ist.
</dl>
Die <tt>system</tt>-Funktion f&uuml;hrt das im <tt>command</tt> angegebene externe
Programm aus und wartet, bis dieses beendet ist.
<h2>Ein-/Ausgabe-Umleitung</h2>
Soll ein externes Programm seine Eingaben von einer bestimmten Datei lesen
(bzw. seine Ausgaben in eine bestimmte Datei schreiben), so muss die Ein- bzw.
Ausgabe umgeleitet werden.
<p>
<table><tr><td valign="top"><img src="platforms-lin.png"><br><img src="platforms-mac.png"></td><td valign="middle">
Unter <b>Linux</b> und <b>Mac OS X</b> geschieht dies einfach durch Anh&auml;ngen von <tt>'&lt;'</tt>
bzw. <tt>'&gt;'</tt> an die Befehlszeile, jeweils gefolgt von der gew&uuml;nschten Datei,
wie in
<pre>
system("program &lt; infile &gt; outfile");
</pre>
womit <tt>program</tt> gestartet wird und es von <tt>infile</tt> liest und
nach <tt>outfile</tt> schreibt.
</td></tr></table>
<p>
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
Unter <b>Windows</b> muss explizit ein Kommando-Prozessor gestartet werden um dies zu
erm&ouml;glichen, wie in
<pre>
system("cmd.exe /c program &lt; infile &gt; outfile");
</pre>
(auf DOS-basierten Windows-Systemen verwenden Sie <tt>command.com</tt> anstatt <tt>cmd.exe</tt>).
</td></tr></table>
<h2>Ausf&uuml;hrung im Hintergrund</h2>
Die <tt>system</tt>-Funktion wartet bis das angegebene Programm beendet ist.
Dies ist sinnvoll f&uuml;r Programme, die nur wenige Sekunden laufen, oder die
Aufmerksamkeit des Benutzers komplett an sich ziehen.
<p>
<table><tr><td valign="top"><img src="platforms-lin.png"><br><img src="platforms-mac.png"></td><td valign="middle">
L&auml;uft ein externes Programm l&auml;ngere Zeit, und Sie wollen, dass der <tt>system()</tt>-Aufruf
sofort zur&uuml;ckkehrt, ohne zu warten, bis das Programm beendet ist, so k&ouml;nnen Sie
unter Linux und Mac OS X einfach ein <tt>'&amp;'</tt> an die Befehlszeile anf&uuml;gen,
wie in
<pre>
system("program &amp;");
</pre>
</td></tr></table>
<p>
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
Unter Windows muss explizit ein Kommando-Prozessor gestartet werden um dies zu
erm&ouml;glichen, wie in
<pre>
system("cmd.exe /c start program");
</pre>
(auf DOS-basierten Windows-Systemen verwenden Sie <tt>command.com</tt> anstatt <tt>cmd.exe</tt>).
</td></tr></table>
<h2>Beispiel</h2>
<pre>
int result = system("simulate -f filename");
</pre>
Hiermit w&uuml;rde ein Simulationsprogramm aufgerufen und diesem eine Datei &uuml;bergeben
werden, die das ULP gerade erzeugt hat.
Beachten Sie bitte, dass <tt>simulate</tt> hier nur ein Beispiel und nicht Bestandteil
des EAGLE-Paketes ist!
<p>
Falls Sie Kontrolle dar&uuml;ber haben wollen, welche externen Programme tats&auml;chlich
ausgef&uuml;hrt werden, k&ouml;nnen Sie sich eine Hilfsfunktion schreiben, welche den
Benutzer vor der Ausf&uuml;hrung des externen Programms um Best&auml;tigung bittet, wie etwa
<pre>
int MySystem(string command)
{
  if (dlgMessageBox("!Ok to execute the following command?&lt;p&gt;&lt;tt&gt;" + command + "&lt;/tt&gt;", "&amp;Yes", "&amp;No") == 0)
     return system(command);
  return -1;
}
int result = MySystem("simulate -f filename");
</pre>


<a name=285>
<h1>Einheiten-Konvertierung</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Konvertiert interne Einheiten.
<dt>
<b>Syntax</b>
<dd>
<tt>real u2inch(int n);</tt><br>
<tt>real u2mic(int n);</tt><br>
<tt>real u2mil(int n);</tt><br>
<tt>real u2mm(int n);</tt><br>
<tt>int inch2u(real n);</tt><br>
<tt>int mic2u(real n);</tt><br>
<tt>int mil2u(real n);</tt><br>
<tt>int mm2u(real n);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>u2inch</tt> liefert den Wert von <tt>n</tt> in <i>Inch</i>.<br>
<tt>u2mic</tt>  liefert den Wert von <tt>n</tt> in <i>Micron</i> (1/1000mm).<br>
<tt>u2mil</tt>  liefert den Wert von <tt>n</tt> in <i>Mil</i> (1/1000inch).<br>
<tt>u2mm</tt>   liefert den Wert von <tt>n</tt> in <i>Millimeter</i>.<br>
<tt>inch2u</tt> liefert den Wert von <tt>n</tt> (der in <i>Inch</i> vorliegt) als interne Einheiten.<br>
<tt>mic2u</tt>  liefert den Wert von <tt>n</tt> (der in <i>Micron</i> vorliegt) als interne Einheiten.<br>
<tt>mil2u</tt>  liefert den Wert von <tt>n</tt> (der in <i>Mil</i> vorliegt) als interne Einheiten.<br>
<tt>mm2u</tt>   liefert den Wert von <tt>n</tt> (der in <i>Millimeter</i> vorliegt) als interne Einheiten.
</dl>
<b>Siehe auch</b> <a href=#194>UL_GRID</a>
<p>
EAGLE speichert alle Koordinaten und Gr&ouml;&szlig;en als
<tt><a href=#172>int</a></tt>-Werte mit einer Aufl&ouml;sung von 1/320000mm
(0.003125&micro;). Die oben angegebenen Einheiten-Konvertier-Funktionen k&ouml;nnen dazu
verwendet werden, die internen Einheiten in die gew&uuml;nschten Ma&szlig;einheiten
umzuwandeln und umgekehrt.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.elements(E) {
    printf("%s at (%f, %f)\n", E.name,
           u2mm(E.x), u2mm(E.y));
    }
  }
</pre>


<a name=286>
<h1>Netzwerk-Funktionen</h1>
<i>Netzwerk-Funktionen</i> dienen der Kommunikation mit entfernten Rechnern im Internet.
<p>
Die folgenden Netzwerk-Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#287>neterror()</a>
<li><a href=#288>netget()</a>
<li><a href=#289>netpost()</a>
</ul>


<a name=287>
<h1>neterror()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Liefert die Fehlermeldung der zuletzt ausgef&uuml;hrten Netzwerk-Funktion.
<dt>
<b>Syntax</b>
<dd>
<tt>string neterror(void);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>neterror</tt> liefert eine textuelle Meldung, die den Fehler beschreibt,
der bei der zuletzt verwendeten Netzwerk-Funktion aufgetreten ist.
Falls kein Fehler aufgetreten ist, wird ein leerer String zur&uuml;ckgegeben.
</dl>
<b>Siehe auch</b> <a href=#288>netget</a>,
<a href=#289>netpost</a>
<p>
Die <tt>neterror</tt>-Funktion sollte nach jeder Verwendung einer der anderen
Netzwerk-Funktionen aufgerufen werden, deren R&uuml;ckgabewert negativ war und
somit einen Fehler angezeigt hat. Der R&uuml;ckgabewert von <tt>neterror</tt>
ist ein textueller String, der dem Benutzer pr&auml;sentiert werden kann.
<p>
Bei Fehlern im Zusammenhang mit SSL-Verbindungen (HTTPS) beachten Sie auch den Hinweis
in <a href=#288>netget</a>.
<h2>Beispiel</h2>
<pre>
string Result;
if (netget(Result, "http://www.cadsoft.de/cgi-bin/http-test?see=me&amp;hear=them") &gt;= 0) {
   // process Result
   }
else
   dlgMessageBox(neterror());
</pre>


<a name=288>
<h1>netget()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
F&uuml;hrt eine GET-Anforderung auf dem Netzwerk aus.
<dt>
<b>Syntax</b>
<dd>
<tt>int netget(<i>dest</i>, string url[, int timeout]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>netget</tt> liefert die Anzahl der Objekte, die vom Netzwerk gelesen wurden.
Die tats&auml;chliche Bedeutung des R&uuml;ckgabewerts h&auml;ngt vom <tt>dest</tt>-Typ ab.<br>
Im Fehlerfall wird ein negativer Wert zur&uuml;ckgegeben und
<a href=#287>neterror()</a>
kann aufgerufen werden, um dem Benutzer eine Fehlermeldung anzuzeigen.
</dl>
<b>Siehe auch</b> <a href=#289>netpost</a>,
<a href=#287>neterror</a>,
<a href=#267>fileread</a>
<p>
Die <tt>netget</tt>-Funktion schickt den angegebenen <tt>url</tt> an das Netzwerk und
speichert das Ergebnis in der Variablen <tt>dest</tt>.
Falls <tt>timeout</tt> Sekunden lang keine Netzwerkaktivit&auml;t erfolgt, wird die
Verbindung abgebrochen. Der Standardwert hierf&uuml;r ist 20 Sekunden.<br>
Der <tt>url</tt> mu&szlig; das zu verwendende Protokoll enthalten (HTTP, HTTPS oder FTP) und kann
Parameter der Form Name=Wert enthalten, wie in
<pre>
http://www.cadsoft.de/cgi-bin/http-test?see=me&amp;hear=them
ftp://ftp.cadsoft.de/eagle/userfiles/README
</pre>
Falls f&uuml;r den Zugriff auf den fernen Rechner eine Benutzerkennung und ein Passwort
notwendig ist, kann dieses in folgender Form angegeben werden:
<pre>
https://userid:password@www.secret-site.com/...
</pre>
Wenn <tt>dest</tt> ein Character-Array ist, wird das Ergebnis als rohe Bin&auml;rdaten
behandelt und der R&uuml;ckgabewert entspricht der Anzahl der Bytes, die in dem Character-Array
gespeichert wurden.
<p>
Wenn <tt>dest</tt> ein String-Array ist, wird das Ergebnis als Text behandelt (eine Zeile
pro Array-Member) und der R&uuml;ckgabewert entspricht der Anzahl der Zeilen, die in
dem Array gespeichert wurden. Newline-Zeichen werden entfernt.
<p>
Wenn <tt>dest</tt> ein String ist, wird das gesamte Ergebnis in diesem String gespeichert
und der R&uuml;ckgabewert entspricht der L&auml;nge des Strings. Beachten Sie, dass im Falle
von bin&auml;ren Daten das Ergebnis beim ersten Auftreten eines Bytes mit dem Wert 0x00
abgeschnitten wird.
<p>
Falls Sie einen Proxy benutzen m&uuml;ssen, um das Internet mit HTTP bzw. HTTPS anzusprechen,
so k&ouml;nnen Sie diesen im "Konfigurieren"-Dialog unter "Hilfe/Auf Update pr&uuml;fen"
im Control Panel konfigurieren.
<h2>SSL-Verbindungen</h2>
F&uuml;r SSL-Verbindungen (Anfrage per HTTPS) sind Zertifikate erforderlich, die auf manchen
Systemen fehlen k&ouml;nnen oder deren G&uuml;ltigkeit abgelaufen sein kann. Die Verbindung scheitert
dann mit entsprechender Fehlermeldung, die Sie mit <tt>neterror()</tt> abfragen k&ouml;nnen.<br>
Anhand der Fehlermeldung sollte es m&ouml;glich zu sein, fehlende Zertifikate nachzuinstallieren
oder zu aktualisieren und die Verbindung so zum Laufen zu bringen.
Wie dies durchzuf&uuml;hren ist, h&auml;ngt von Ihrem System ab (In Windows z.B. unter
Systemsteuerung/Internetoptionen usw.).
<h2>Beispiel</h2>
<pre>
string Result;
if (netget(Result, "http://www.cadsoft.de/cgi-bin/http-test?see=me&amp;hear=them") &gt;= 0) {
   // process Result
   }
else
   dlgMessageBox(neterror());
</pre>


<a name=289>
<h1>netpost()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
F&uuml;hrt eine POST-Anforderung auf dem Netzwerk aus.
<dt>
<b>Syntax</b>
<dd>
<tt>int netpost(<i>dest</i>, string url, string data[, int timeout[, string content_type] ]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>netpost</tt> liefert die Anzahl der Objekte, die vom Netzwerk gelesen wurden.
Die tats&auml;chliche Bedeutung des R&uuml;ckgabewerts h&auml;ngt vom <tt>dest</tt>-Typ ab.<br>
Im Fehlerfall wird ein negativer Wert zur&uuml;ckgegeben und
<a href=#287>neterror()</a>
kann aufgerufen werden, um dem Benutzer eine Fehlermeldung anzuzeigen.
</dl>
<b>Siehe auch</b> <a href=#288>netget</a>,
<a href=#287>neterror</a>,
<a href=#267>fileread</a>
<p>
Die <tt>netpost</tt>-Funktion schickt die in <tt>data</tt> angegebenen Daten an den
angegebenen <tt>url</tt> im Netzwerk und speichert das Ergebnis in der Variablen <tt>dest</tt>.
Falls <tt>timeout</tt> Sekunden lang keine Netzwerkaktivit&auml;t erfolgt, wird die
Verbindung abgebrochen. Der Standardwert hierf&uuml;r ist 20 Sekunden.<br>
Wird <tt>content_type</tt> angegeben, so &uuml;berschreibt das den Standardwert von
of <tt>"text/html; charset=utf-8"</tt>.<br>
Der <tt>url</tt> mu&szlig; das zu verwendende Protokoll enthalten (HTTP oder HTTPS).
<p>
Falls f&uuml;r den Zugriff auf den fernen Rechner eine Benutzerkennung und ein Passwort
notwendig ist, kann dieses in folgender Form angegeben werden:
<pre>
https://userid:password@www.secret-site.com/...
</pre>
Wenn <tt>dest</tt> ein Character-Array ist, wird das Ergebnis als rohe Bin&auml;rdaten
behandelt und der R&uuml;ckgabewert entspricht der Anzahl der Bytes, die in dem Character-Array
gespeichert wurden.
<p>
Wenn <tt>dest</tt> ein String-Array ist, wird das Ergebnis als Text behandelt (eine Zeile
pro Array-Member) und der R&uuml;ckgabewert entspricht der Anzahl der Zeilen, die in
dem Array gespeichert wurden. Newline-Zeichen werden entfernt.
<p>
Wenn <tt>dest</tt> ein String ist, wird das gesamte Ergebnis in diesem String gespeichert
und der R&uuml;ckgabewert entspricht der L&auml;nge des Strings. Beachten Sie, dass im Falle
von bin&auml;ren Daten das Ergebnis beim ersten Auftreten eines Bytes mit dem Wert 0x00
abgeschnitten wird.
<p>
Falls Sie einen Proxy benutzen m&uuml;ssen, um das Internet mit HTTP bzw. HTTPS anzusprechen,
so k&ouml;nnen Sie diesen im "Konfigurieren"-Dialog unter "Hilfe/Auf Update pr&uuml;fen"
im Control Panel konfigurieren.
<p>
Falls Sie mit SSL-Verbindungen (HTTPS) auf Probleme sto&szlig;en sollten, beachten Sie den Hinweis
in <a href=#288>netget</a>
<h2>Beispiel</h2>
<pre>
string Data = "see=me\nhear=them";
string Result;
if (netpost(Result, "http://www.cadsoft.de/cgi-bin/http-test", Data) &gt;= 0) {
   // process Result
   }
else
   dlgMessageBox(neterror());
</pre>


<a name=290>
<h1>Print-Funktionen</h1>
<i>Print-Funktionen</i> dienen zur Ausgabe formatierter Strings.
<p>
Die folgenden Print-Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#291>printf()</a>
<li><a href=#292>sprintf()</a>
</ul>


<a name=291>
<h1>printf()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Schreibt formatiere Ausgaben in eine Datei.
<dt>
<b>Syntax</b>
<dd>
<tt>int printf(string format[, argument, ...]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>printf</tt>-Funktion liefert die Zahl der Zeichen, die in die
vom letzten <a href=#327>output</a>-Statement ge&ouml;ffnete Datei
geschrieben wurden.
<p>
Wenn ein Fehler auftritt, liefert <tt>printf</tt> <tt>-1</tt>.
</dl>
<b>Siehe auch</b> <a href=#292>sprintf</a>,
<a href=#327>output</a>,
<a href=#262>fileerror</a>
<h2>Format-String</h2>
Der Format-String steuert, wie die Argumente konvertiert, formatiert
und ausgegeben werden. Es m&uuml;ssen genau so viele Argumente vorhanden
sein, wie f&uuml;r das Format erforderlich sind. Die Zahl und der Typ
der Argumente werden f&uuml;r jedes Format gepr&uuml;ft, und wenn sie nicht
den Anforderungen entsprechen, wird eine Fehlermeldung ausgegeben.
<p>
Der Format-String enth&auml;lt zwei Objekt-Typen - <i>einfache Zeichen</i>
und <i>Format-Specifier</i>:
<ul>
<li>Einfache Zeichen werden direkt ausgegeben
<li>Format-Specifier holen Argumente von der Argument-Liste
und formatieren sie
</ul>
<h2>Format-Specifier</h2>
Ein Format-Specifier hat folgende Form:
<p>
<tt>% [flags] [width] [.prec] type</tt>
<p>
Jede Format-Spezifizierung beginnt mit dem Prozentzeichen (<tt>%</tt>).
Nach dem <tt>%</tt> kommt folgendes, in dieser Reihenfolge:
<ul>
<li>optional eine Folge von Flag-Zeichen, <tt>[flags]</tt>
<li>optional ein Breiten-Specifier, <tt>[width]</tt>
<li>optional ein Pr&auml;zisions-Specifier, <tt>[.prec]</tt>
<li>das Konvertiertyp-Zeichen, <tt>type</tt>
</ul>
<h2>Konvertiertyp-Zeichen</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>d</tt>   </td><td width=20><td><b>signed</b> decimal <b>int</b></td></tr>
<tr><td><tt>o</tt>   </td><td width=20><td><b>unsigned</b> octal <b>int</b></td></tr>
<tr><td><tt>u</tt>   </td><td width=20><td><b>unsigned</b> decimal <b>int</b></td></tr>
<tr><td><tt>x</tt>   </td><td width=20><td><b>unsigned</b> hexadecimal <b>int</b> (with <b>a</b>, <b>b</b>,...)</td></tr>
<tr><td><tt>X</tt>   </td><td width=20><td><b>unsigned</b> hexadecimal <b>int</b> (with <b>A</b>, <b>B</b>,...)</td></tr>
<tr><td><tt>f</tt>   </td><td width=20><td><b>signed real</b> value von der Form <tt>[-]dddd.dddd</tt></td></tr>
<tr><td><tt>e</tt>   </td><td width=20><td><b>signed real</b> value von der Form <tt>[-]d.dddd</tt>e<tt>[&plusmn;]ddd</tt></td></tr>
<tr><td><tt>E</tt>   </td><td width=20><td>wie <tt>e</tt>, aber mit <b>E</b> f&uuml;r Exponent</td></tr>
<tr><td><tt>g</tt>   </td><td width=20><td><b>signed real</b> value entweder wie <tt>e</tt> oder <tt>f</tt>, abh&auml;ngig vom gegebenen Wert und Pr&auml;zision</td></tr>
<tr><td><tt>G</tt>   </td><td width=20><td>wie <tt>g</tt>, aber mit <b>E</b> f&uuml;r Exponent, wenn <tt>e</tt>-Format verwendet wird</td></tr>
<tr><td><tt>c</tt>   </td><td width=20><td>einzelnes Zeichen</td></tr>
<tr><td><tt>s</tt>   </td><td width=20><td>Character-String</td></tr>
<tr><td><tt>%</tt>   </td><td width=20><td>das <tt>%</tt>-Zeichen wird ausgegeben</td></tr>
</table>
<h2>Flag-Zeichen</h2>
Die folgenden Flag-Zeichen k&ouml;nnen in jeder Kombination und Reihenfolge
auftreten.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>"-"</tt>   </td><td width=20><td>das formatierte Argument wird innerhalb des Feldes linksb&uuml;ndig ausgegeben; normalerweise ist die Ausgabe rechtsb&uuml;ndig</td></tr>
<tr><td><tt>"+"</tt>   </td><td width=20><td>ein positiver Wert mit Vorzeichen wird mit Pluszeichen (<tt>+</tt>) ausgegeben; normalerweise werden nur negative Werte mit Vorzeichen ausgegeben</td></tr>
<tr><td><tt>" "</tt>   </td><td width=20><td>ein positiver Wert mit Vorzeichen wird mit Leerzeichen am Anfang ausgegeben; wenn <tt>"+"</tt> und <tt>" "</tt> angegeben sind, &uuml;berschreibt <tt>"+"</tt> die Angabe <tt>" "</tt></td></tr>
</table>
<h2>Width-Specifier</h2>
Der Width-Specifier setzt die minimale Feldbreite f&uuml;r einen Ausgabewert.
<p>
Die Breite wird entweder direkt mit einem Dezimalstellen-String oder
indirekt mit einem Stern  (<tt>*</tt>) gesetzt.
Wenn Sie <tt>*</tt> verwenden, legt das Argument, das dem (mit diesem Format formatierten) Argument im Aufruf vorhergeht,
(und vom Typ <tt>int</tt> sein muss) die minimale Feldbreite fest.
<p>
Auf keinen Fall f&uuml;hrt ein nicht existierendes oder zu ein kleines Feld
dazu, dass ein Wert abgeschnitten wird. Wenn das Ergebnis der Konvertierung
breiter ist als das Feld, wird das Feld einfach so vergr&ouml;&szlig;ert, dass
das Ergebnis platz hat.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt><i>n</i></tt>   </td><td width=20><td>Mindestens <i>n</i> Zeichen werden ausgegeben. Wenn der Ausgabewert weniger als <i>n</i> Zeichen hat, wird er mit Leerzeichen aufgef&uuml;llt (rechts wenn das <tt>"-"</tt>-Flag gesetzt ist, sonst links).</td></tr>
<tr><td><tt>0<i>n</i></tt>   </td><td width=20><td>Mindestens <i>n</i> Zeichen werden ausgegeben. Wenn der Ausgabewert weniger als <i>n</i> Zeichen hat, wird links mit Nullen aufgef&uuml;llt.</td></tr>
<tr><td><tt>*</tt>   </td><td width=20><td>Die Argument-Liste liefert den Width-Specifier, der dem eigentlichen (zu formatierenden) Argument vorausgehen muss.</td></tr>
</table>
<h2>Pr&auml;zisions-Specifier</h2>
Ein Pr&auml;zisions-Specifier beginnt immer mit einem Punkt (<tt>.</tt>), um
ihn von einem vorangehenden Width-Specifier zu trennen.
Dann wird, wie bei "Width", die Pr&auml;zision entweder direkt mit einem
Dezimalstellen-String oder indirekt mit einem Stern (<tt>*</tt>) angegeben.
Wenn Sie <tt>*</tt> verwenden, legt das Argument, das dem (mit diesem Format formatierten) Argument im Aufruf vorhergeht,
(und vom Typ <tt>int</tt> sein muss) die Pr&auml;zision fest.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>keiner   </td><td width=20><td>Pr&auml;zision auf Standardwert gesetzt.</td></tr>
<tr><td><tt>.0</tt>   </td><td width=20><td>F&uuml;r <tt>int</tt>-Typen, Pr&auml;zision wird auf Default gesetzt; f&uuml;r <tt>real</tt>-Typen, kein Dezimalpunkt wird ausgegeben.</td></tr>
<tr><td><tt>.<i>n</i></tt>   </td><td width=20><td><i>n</i> Zeichen oder <i>n</i> Dezimalstellen werden ausgegeben. Wenn der Ausgabewert mehr als <i>n</i> Zeichen hat, kann er abgeschnitten oder gerundet werden (abh&auml;ngig vom Typ-Zeichen).</td></tr>
<tr><td><tt>*</tt>   </td><td width=20><td>Die Argument-Liste liefert den Pr&auml;zisions-Specifier, der dem eigentlichen (zu formatierenden) Argument vorausgehen muss.</td></tr>
</table>
<h2>Default-Pr&auml;zisionswerte</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>douxX</tt>   </td><td width=20><td>1</td></tr>
<tr><td><tt>eEf</tt>   </td><td width=20><td>6</td></tr>
<tr><td><tt>gG</tt>   </td><td width=20><td>alle signifikanten Stellen</td></tr>
<tr><td><tt>c</tt>   </td><td width=20><td>keine Auswirkung</td></tr>
<tr><td><tt>s</tt>   </td><td width=20><td>gesamten String ausgeben</td></tr>
</table>
<h2>Wie die Pr&auml;zisionsangabe (<tt>.n</tt>) die Konvertierung beeinflusst</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>douxX</tt>   </td><td width=20><td><i>.n</i> spezifiziert dass mindestens <i>n</i> Zeichen ausgegeben werden. Wenn das Eingangs-Argument weniger als <i>n</i> Stellen hat, wird der Ausgangswert links mit Nullen aufgef&uuml;llt. Wenn das Eingangs-Argument mehr als <i>n</i> Stellen hat, wir die Ausgabe <b>nicht</b> abgeschnitten.</td></tr>
<tr><td><tt>eEf</tt>   </td><td width=20><td><i>.n</i> spezifiziert dass <i>n</i> Zeichen nach dem Dezimalpunkt ausgegeben werden, und die letzte ausgegebene Stelle wird gerundet.</td></tr>
<tr><td><tt>gG</tt>   </td><td width=20><td><i>.n</i> spezifiziert dass h&ouml;chstens <i>n</i> signifikante Stellen ausgegeben werden.</td></tr>
<tr><td><tt>c</tt>   </td><td width=20><td><i>.n</i> hat keinen Einfluss auf die Ausgabe.</td></tr>
<tr><td><tt>s</tt>   </td><td width=20><td><i>.n</i> spezifiziert dass nicht mehr als <i>n</i> Zeichen gedruckt werden.</td></tr>
</table>
<h2>Der bin&auml;re Wert 0</h2>
Im Gegensatz zu <a href=#292>sprintf</a> kann die <tt>printf</tt>-Funktion den
bin&auml;ren Wert 0 (0x00) ausgeben.
<pre>
char c = 0x00;
printf("%c", c);
</pre>
<h2>Beispiel</h2>
<pre>
int i = 42;
real r = 3.14;
char c = 'A';
string s = "Hello";
printf("Integer: %8d\n", i);
printf("Hex:     %8X\n", i);
printf("Real:    %8f\n", r);
printf("Char:    %-8c\n", c);
printf("String:  %-8s\n", s);
</pre>


<a name=292>
<h1>sprintf()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Schreibt eine formatierte Ausgabe in einen String.
<dt>
<b>Syntax</b>
<dd>
<tt>int sprintf(string result, string format[, argument, ...]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>sprintf</tt>-Funktion liefert die Zahl der Zeichen, die in den <tt>result</tt>-String
geschrieben wurden.
<p>
Im Falle eines Fehlers liefert <tt>sprintf</tt> den Wert <tt>-1</tt>.
</dl>
<b>Siehe auch</b> <a href=#291>printf</a>
<h2>Format-String</h2>
Siehe <a href=#291>printf</a>.
<h2>Der bin&auml;re Wert 0</h2>
Bitte beachten Sie, dass <tt>sprintf</tt> den bin&auml;ren Wert 0 (0x00) nicht verarbeiten
kann. Wenn der Ergebnis-String 0x00 enth&auml;lt, werden die folgenden Zeichen ignoriert.
Verwenden Sie <a href=#291>printf</a> um bin&auml;re Daten auszugeben.
<h2>Beispiel</h2>
<pre>
string result;
int number = 42;
sprintf(result, "The number is %d", number);
</pre>


<a name=293>
<h1>String-Funktionen</h1>
<i>String-Funktionen</i> werden dazu verwendet, Character-Strings zu
manipulieren.
<p>
Die folgenden String-Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#294>strchr()</a>
<li><a href=#295>strjoin()</a>
<li><a href=#296>strlen()</a>
<li><a href=#297>strlwr()</a>
<li><a href=#298>strrchr()</a>
<li><a href=#299>strrstr()</a>
<li><a href=#300>strsplit()</a>
<li><a href=#301>strstr()</a>
<li><a href=#302>strsub()</a>
<li><a href=#303>strtod()</a>
<li><a href=#304>strtol()</a>
<li><a href=#305>strupr()</a>
<li><a href=#306>strxstr()</a>
</ul>


<a name=294>
<h1>strchr()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Durchsucht einen String nach dem ersten Vorkommen eines gegebenen Zeichens.
<dt>
<b>Syntax</b>
<dd>
<tt>int strchr(string s, char c[, int index]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strchr</tt>-Funktion liefert den Integer-Offset des Zeichen im String
oder <tt>-1</tt>, wenn das Zeichen nicht vorkommt.
</dl>
<b>Siehe auch</b> <a href=#298>strrchr</a>,
<a href=#301>strstr</a>
<p>
Falls <tt>index</tt> angegeben wird, beginnt die Suche an dieser Position.
Negative Werte werden vom Ende des Strings her gez&auml;hlt.
<h2>Beispiel</h2>
<pre>
string s = "This is a string";
char c = 'a';
int pos = strchr(s, c);
if (pos &gt;= 0)
   printf("The character %c is at position %d\n", c, pos);
else
   printf("The character was not found\n");
</pre>


<a name=295>
<h1>strjoin()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Erzeugt aus einem String-Array einen einzelnen String.
<dt>
<b>Syntax</b>
<dd>
<tt>string strjoin(string array[], char separator);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strjoin</tt>-Funktion liefert die kombinierten Eintr&auml;ge von <tt>array</tt>.
</dl>
<b>Siehe auch</b> <a href=#300>strsplit</a>,
<a href=#279>lookup</a>,
<a href=#267>fileread</a>
<p>
<tt>strjoin</tt> f&uuml;gt alle Eintr&auml;ge aus <tt>array</tt>, getrennt durch den angegebenen
<tt>separator</tt> zusammen, und liefert den Ergebnis-String.
<p>
Wenn <tt>separator</tt> ein Newline-Zeichen (<tt>'\n'</tt>) ist, wird der Ergebnis-String
mit einem Newline-Zeichen abgeschlossen.
So erh&auml;lt man eine Textdatei mit N Zeilen (jede davon ist mit einem Newline-Zeichen abgeschlossen).
Die Datei wird mit den Funktionen <a href=#267>fileread()</a> eingelesen und mit
<a href=#300>split</a> in ein Array mit N Strings aufgeteilt und zu dem urspr&uuml;nglichen
String, der aus der Datei eingelesen wurde, hinzugef&uuml;gt.
<h2>Beispiel</h2>
<pre>
string a[] = { "Field 1", "Field 2", "Field 3" };
string s = strjoin(a, ':');
</pre>


<a name=296>
<h1>strlen()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Berechnet die L&auml;nge eines Strings.
<dt>
<b>Syntax</b>
<dd>
<tt>int strlen(string s);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strlen</tt>-Funktion liefert die Zahl der Zeichen im String.
</dl>
<h2>Beispiel</h2>
<pre>
string s = "This is a string";
int l = strlen(s);
printf("The string is %d characters long\n", l);
</pre>


<a name=297>
<h1>strlwr()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Wandelt Gro&szlig;buchstaben in einem String in Kleinbuchstaben um.
<dt>
<b>Syntax</b>
<dd>
<tt>string strlwr(string s);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strlwr</tt>-Funktion liefert den modifizierten String.
Der Original-String (als Parameter &uuml;bergeben) wird nicht ge&auml;ndert.
</dl>
<b>Siehe auch</b> <a href=#305>strupr</a>,
<a href=#260>tolower</a>
<h2>Beispiel</h2>
<pre>
string s = "This Is A String";
string r = strlwr(s);
printf("Prior to strlwr: %s - after strlwr: %s\n", s, r);
</pre>


<a name=298>
<h1>strrchr()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Durchsucht einen String nach dem letzten Vorkommen eines gegebenen Zeichens.
<dt>
<b>Syntax</b>
<dd>
<tt>int strrchr(string s, char c[, int index]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strrchr</tt>-Funktion liefert den Integer-Offset des Zeichens im String
oder <tt>-1</tt>, wenn das Zeichen nicht vorkommt.
</dl>
<b>Siehe auch</b> <a href=#294>strchr</a>,
<a href=#299>strrstr</a>
<p>
Falls <tt>index</tt> angegeben wird, beginnt die Suche an dieser Position.
Negative Werte werden vom Ende des Strings her gez&auml;hlt.
<h2>Beispiel</h2>
<pre>
string s = "This is a string";
char c = 'a';
int pos = strrchr(s, c);
if (pos &gt;= 0)
   printf("The character %c is at position %d\n", c, pos);
else
   printf("The character was not found\n");
</pre>


<a name=299>
<h1>strrstr()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Durchsucht einen String nach dem letzten Vorkommen eines gegebenen
Substrings.
<dt>
<b>Syntax</b>
<dd>
<tt>int strrstr(string s1, string s2[, int index]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strrstr</tt>-Funktion liefert den Integer-Offset des ersten
Zeichens von s2 in s1, oder <tt>-1</tt>, wenn der Substring nicht
vorkommt.
</dl>
<b>Siehe auch</b> <a href=#301>strstr</a>,
<a href=#298>strrchr</a>
<p>
Falls <tt>index</tt> angegeben wird, beginnt die Suche an dieser Position.
Negative Werte werden vom Ende des Strings her gez&auml;hlt.
<h2>Beispiel</h2>
<pre>
string s1 = "This is a string", s2 = "is a";
int pos = strrstr(s1, s2);
if (pos &gt;= 0)
   printf("The substring starts at %d\n", pos);
else
   printf("The substring was not found\n");
</pre>


<a name=300>
<h1>strsplit()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Teilt einen String in einzelne Felder.
<dt>
<b>Syntax</b>
<dd>
<tt>int strsplit(string &amp;array[], string s, char separator);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strsplit</tt>-Funktion liefert die Anzahl der Eintr&auml;ge die nach <tt>array</tt> kopiert wurden.
</dl>
<b>Siehe auch</b> <a href=#295>strjoin</a>,
<a href=#279>lookup</a>,
<a href=#267>fileread</a>
<p>
<tt>strsplit</tt> teilt den String <tt>s</tt> am angegebenen <tt>separator</tt>
und speichert die so erzeugten Felder in <tt>array</tt>.
<p>
Wenn <tt>separator</tt> ein Newline-Zeichen ist (<tt>'\n'</tt>), wird das letzte Feld
einfach ignoriert, sofern es leer ist.
So erh&auml;lt man eine Textdatei, die aus N Zeilen besteht (jede durch Newline beendet).
Diese wird durch die Funktion <a href=#267>fileread()</a> eingelesen
und in ein Array von N Strings aufgeteilt.
Mit jedem anderen <tt>separator</tt> ist ein leeres Feld am Ende des Strings g&uuml;ltig.
So entstehen aus  <tt>"a:b:c:"</tt> 4 Felder, das letzte davon ist leer.
<h2>Beispiel</h2>
<pre>
string a[];
int n = strsplit(a, "Field 1:Field 2:Field 3", ':');
</pre>


<a name=301>
<h1>strstr()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Durchsucht einen String nach dem ersten Vorkommen eines gegebenen Substrings.
<dt>
<b>Syntax</b>
<dd>
<tt>int strstr(string s1, string s2[, int index]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strstr</tt>-Funktion liefert den Integer-Offset des ersten
Zeichens von s2 in s1, oder <tt>-1</tt>, wenn der Substring nicht
vorkommt.
</dl>
<b>Siehe auch</b> <a href=#299>strrstr</a>,
<a href=#294>strchr</a>,
<a href=#306>strxstr</a>
<p>
Falls <tt>index</tt> angegeben wird, beginnt die Suche an dieser Position.
Negative Werte werden vom Ende des Strings her gez&auml;hlt.
<h2>Beispiel</h2>
<pre>
string s1 = "This is a string", s2 = "is a";
int pos = strstr(s1, s2);
if (pos &gt;= 0)
   printf("The substring starts at %d\n", pos);
else
   printf("The substring was not found\n");
</pre>


<a name=302>
<h1>strsub()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Extrahiert einen Substring aus einem String.
<dt>
<b>Syntax</b>
<dd>
<tt>string strsub(string s, int start[, int length]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strsub</tt>-Funktion liefert den Substring, der durch
<tt>start</tt> und <tt>length</tt> definiert ist.
<p>
Der Wert f&uuml;r <tt>length</tt> muss positiv sein, andernfalls wird ein leerer
String zur&uuml;ckgegeben. Wenn <tt>length</tt> nicht angegeben ist, wird der
Reststring (beginnend bei <tt>start</tt>) zur&uuml;ckgegeben.
<p>
Wenn <tt>start</tt> auf eine Position ausserhalb des Strings deutet, wird
ein leerer String zur&uuml;ckgegeben.
</dl>
<h2>Beispiel</h2>
<pre>
string s = "This is a string";
string t = strsub(s, 4, 7);
printf("The extracted substring is: %s\n", t);
</pre>


<a name=303>
<h1>strtod()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Konvertiert einen String in einen Real-Wert.
<dt>
<b>Syntax</b>
<dd>
<tt>real strtod(string s);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strtod</tt>-Funktion liefert die numerische Repr&auml;sentation
eines gegebenen Strings als <tt>real</tt>-Wert. Die Konvertierung
wird beim ersten Zeichen beendet, das nicht dem Format einer
<a href=#159>Real-Konstanten</a> entspricht.
Wenn ein Fehler w&auml;hrend er Konvertierung auftaucht, wir der Wert
<tt>0.0</tt> zur&uuml;ckgegeben.
</dl>
<b>Siehe auch</b> <a href=#304>strtol</a>
<h2>Beispiel</h2>
<pre>
string s = "3.1415";
real r = strtod(s);
printf("The value is %f\n", r);
</pre>


<a name=304>
<h1>strtol()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Konvertiert einen String in einen Integer-Wert.
<dt>
<b>Syntax</b>
<dd>
<tt>int strtol(string s);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strtol</tt>-Funktion liefert die numerische Representation
eines gegebenen Strings als <tt>int</tt>-Wert. Die Konvertierung
wird beim ersten Zeichen beendet, das nicht dem Format einer
<a href=#158>Integer-Konstanten</a> entspricht.
Wenn ein Fehler w&auml;hrend der Konvertierung auftaucht, wir der Wert
<tt>0</tt> zur&uuml;ckgegeben.
</dl>
<b>Siehe auch</b> <a href=#303>strtod</a>
<h2>Beispiel</h2>
<pre>
string s = "1234";
int i = strtol(s);
printf("The value is %d\n", i);
</pre>


<a name=305>
<h1>strupr()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Konvertiert Kleinbuchstaben in einem String in Gro&szlig;buchstaben.
<dt>
<b>Syntax</b>
<dd>
<tt>string strupr(string s);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strupr</tt>-Funktion liefert den modifizierten String.
Der Original-String (als Parameter &uuml;bergeben) wird nicht ge&auml;ndert.
</dl>
<b>Siehe auch</b> <a href=#297>strlwr</a>,
<a href=#260>toupper</a>
<h2>Beispiel</h2>
<pre>
string s = "This Is A String";
string r = strupr(s);
printf("Prior to strupr: %s - after strupr: %s\n", s, r);
</pre>


<a name=306>
<h1>strxstr()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Durchsucht einen String nach dem ersten Vorkommen eines regul&auml;ren Ausdrucks.
<dt>
<b>Syntax</b>
<dd>
<tt>int strxstr(string s1, string s2[, int index[, int &amp;length]]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>strxstr</tt>-Funktion liefert den Integer-Offset des Teilstrings
in s1, auf den der regul&auml;re Ausdruck in s2 passt, oder <tt>-1</tt>, wenn der
regul&auml;re Ausdruck nicht passt.
</dl>
<b>Siehe auch</b> <a href=#301>strstr</a>,
<a href=#294>strchr</a>,
<a href=#299>strrstr</a>
<p>
Falls <tt>index</tt> angegeben wird, beginnt die Suche an dieser Position.
Negative Werte werden vom Ende des Strings her gez&auml;hlt.
<p>
Falls <tt>length</tt> angegeben wird, wird die aktuelle L&auml;nge des gefundenen
Teilstrings in dieser Variablen zur&uuml;ckgegeben.
<p>
<i>Regul&auml;re Ausdr&uuml;cke</i> erlauben es Ihnen, ein Muster innerhalb eines Text-Strings
zu finden. Zum Beispiel w&uuml;rde der regul&auml;re Ausdruck "i.*a" eine Zeichenfolge finden,
die mit 'i' beginnt, gefolgt von einem beliebigen Zeichen ('.') beliebig oft ('*'),
und mit 'a' endet. Er w&uuml;rde auf "is a", "is this a" oder "ia" passen.<br>
Einzelheiten zu regul&auml;ren Ausdr&uuml;cken finden Sie zum Beispiel in dem Buch
<i>Regul&auml;re Ausdr&uuml;cke</i> von Jeffrey E. F. Friedl.
<h2>Beispiel</h2>
<pre>
string s1 = "This is a string", s2 = "i.*a";
int len = 0;
int pos = strxstr(s1, s2, 0, len);
if (pos &gt;= 0)
   printf("The substring starts at %d and is %d charcaters long\n", pos, len);
else
   printf("The substring was not found\n");
</pre>


<a name=307>
<h1>Zeit-Funktionen</h1>
<i>Zeit-Funktionen</i> werden dazu verwendet, die Zeit- und Datums-
Informationen zu erhalten und weiterzuverarbeiten.
<p>
Die folgenden Zeit-Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#281>sleep()</a>
<li><a href=#310>t2day()</a>
<li><a href=#310>t2dayofweek()</a>
<li><a href=#310>t2hour()</a>
<li><a href=#310>t2minute()</a>
<li><a href=#310>t2month()</a>
<li><a href=#310>t2second()</a>
<li><a href=#310>t2string()</a>
<li><a href=#310>t2year()</a>
<li><a href=#308>time()</a>
<li><a href=#309>timems()</a>
</ul>


<a name=308>
<h1>time()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Holt die gegenw&auml;rtige Systemzeit.
<dt>
<b>Syntax</b>
<dd>
<tt>int time(void);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>time</tt>-Funktion liefert die gegenw&auml;rtige Systemzeit als Zahl von
Sekunden, die seit einem systemabh&auml;ngigen Referenzzeitpunkt vergangen sind.
</dl>
<b>Siehe auch</b> <a href=#310>Zeit-Konvertierungen</a>,
<a href=#265>filetime</a>
<h2>Beispiel</h2>
<pre>
int CurrentTime = time();
</pre>


<a name=309>
<h1>timems()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Liefert die Zeit in Millisekunden seit dem Start des ULPs.
<dt>
<b>Syntax</b>
<dd>
<tt>int timems(void);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>timems</tt>-Funktion liefert die Zeit in Millisekunden seit dem Start des ULPs.
<p>
Nach 86400000 Millisekunden (d.h. alle 24 Stunden) beginnt der Wert wieder bei 0.
</dl>
<b>Siehe auch</b> <a href=#310>Zeit-Konvertierungen</a>,
<a href=#265>filetime</a>,
<a href=#309>timems()</a>
<h2>Beispiel</h2>
<pre>
int elapsed = timems();
</pre>


<a name=310>
<h1>Zeit-Konvertierungen</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeit-Wert in Tag, Monat, Jahr etc. konvertieren.
<dt>
<b>Syntax</b>
<dd>
<tt>int t2day(int t);</tt><br>
<tt>int t2dayofweek(int t);</tt><br>
<tt>int t2hour(int t);</tt><br>
<tt>int t2minute(int t);</tt><br>
<tt>int t2month(int t);</tt><br>
<tt>int t2second(int t);</tt><br>
<tt>int t2year(int t);</tt><br>
<br>
<tt>string t2string(int t[, string format]);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
<tt>t2day      </tt> liefert den Tag des Monats (<tt>1</tt>..<tt>31</tt>)<br>
<tt>t2dayofweek</tt> liefert den Tag der Woche (<tt>0</tt>=sunday..<tt>6</tt>)<br>
<tt>t2hour     </tt> liefert die Stunde (<tt>0</tt>..<tt>23</tt>)<br>
<tt>t2minute   </tt> liefert die Minute (<tt>0</tt>..<tt>59</tt>)<br>
<tt>t2month    </tt> liefert den Monat (<tt>0</tt>..<tt>11</tt>)<br>
<tt>t2second   </tt> liefert die Sekunde (<tt>0</tt>..<tt>59</tt>)<br>
<tt>t2year     </tt> liefert das Jahr (einschlie&szlig;lich Jahrhundert!)<br>
<tt>t2string   </tt> liefert einen formatierten String, der Datum und Zeit enth&auml;lt
</dl>
<b>Siehe auch</b> <a href=#308>time</a>
<p>
Die <tt>t2string</tt>-Funktion ohne den optionalen <tt>format</tt>-Parameter
wandelt die gegebene Zeit <tt>t</tt> in einen landesspezifischen String in Ortszeit um.
<p>
Wird <tt>t2string</tt> mit einem <tt>format</tt>-String aufgerufen, so bestimmt dieses
Format die Darstellung des Ergebnisses.
<p>
Folgende Ausdr&uuml;cke k&ouml;nnen innerhalb des <tt>format</tt>-Strings benutzt werden:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>d</td><td width=20><td>der Tag als Zahl ohne f&uuml;hrende Null (1 bis 31)</td></tr>
<tr><td>dd</td><td width=20><td>der Tag als Zahl mit f&uuml;hrender Null (01 bis 31)</td></tr>
<tr><td>ddd</td><td width=20><td>der abgek&uuml;rzte, landesspezifische Name des Tages (z.B. "Mon" bis "Son")</td></tr>
<tr><td>dddd</td><td width=20><td>der ausgeschriebene, landesspezifische Name des Tages (z.B. "Montag" bis "Sonntag")</td></tr>
<tr><td>M</td><td width=20><td>der Monat als Zahl ohne f&uuml;hrende Null (1-12)</td></tr>
<tr><td>MM</td><td width=20><td>der Monat als Zahl mit f&uuml;hrender Null (01-12)</td></tr>
<tr><td>MMM</td><td width=20><td>der abgek&uuml;rzte, landesspezifische Name des Monats (z.B. "Jan" bis "Dez")</tr>
<tr><td>MMMM</td><td width=20><td>der ausgeschriebene, landesspezifische Name des Monats (z.B. "Januar" bis "Dezember")</td></tr>
<tr><td>yy</td><td width=20><td>das Jahr als zweistellige Zahl (00-99)</td></tr>
<tr><td>yyyy</td><td width=20><td>das Jahr als vierstellige Zahl</td></tr>
<tr><td>h</td><td width=20><td>die Stunde ohne f&uuml;hrende Null (0 bis 23 bzw. 1 bis 12 in AM/PM-Schreibweise)</td></tr>
<tr><td>hh</td><td width=20><td>die Stunde mit f&uuml;hrender Null (00 bis 23 bzw. 01 bis 12 in AM/PM-Schreibweise)</td></tr>
<tr><td>m</td><td width=20><td>die Minute ohne f&uuml;hrende Null (0 bis 59)</td></tr>
<tr><td>mm</td><td width=20><td>die Minute mit f&uuml;hrender Null (00 bis 59)</td></tr>
<tr><td>s</td><td width=20><td>die Sekunde ohne f&uuml;hrende Null (0 bis 59)</td></tr>
<tr><td>ss</td><td width=20><td>die Sekunde mit f&uuml;hrender Null (00 bis 59)</td></tr>
<tr><td>z</td><td width=20><td>die Millisekunden ohne f&uuml;hrende Nullen (immer 0, da die gegebene Zeit nur eine Aufl&ouml;sung von einer Sekunde hat)</td></tr>
<tr><td>zzz</td><td width=20><td>die Millisekunden mit f&uuml;hrenden Nullen (immer 000, da die gegebene Zeit nur eine Aufl&ouml;sung von einer Sekunde hat)</td></tr>
<tr><td>AP</td><td width=20><td>AM/PM-Schreibweise benutzen (<i>AP</i> wird durch "AM" bzw. "PM" ersetzt)</td></tr>
<tr><td>ap</td><td width=20><td>am/pm-Schreibweise benutzen (<i>ap</i> wird durch "am" bzw. "pm" ersetzt)</td></tr>
<tr><td>U</td><td width=20><td>die gegebene Zeit in UTC anzeigen (mu&szlig; das erste Zeichen sein; standardm&auml;&szlig;ig erfolgt die Anzeige in Ortszeit)</td></tr>
</table>
<p>
Alle anderen Zeichen werden unver&auml;ndert &uuml;bernommen.
In einfache Hochkommas eingeschlossene Zeichen werden als Text betrachtet und
nicht als Ausdr&uuml;cke. Zwei aufeinanderfolgende einfache Hochkommas ('') werden
im Ergebnis durch ein einfaches Hochkomma ersetzt.
<h2>Beispiel</h2>
<pre>
int t = time();
printf("It is now %02d:%02d:%02d\n",
       t2hour(t), t2minute(t), t2second(t));
printf("ISO time is %s\n", t2string(t, "Uyyyy-MM-dd hh:mm:ss"));
</pre>


<a name=311>
<h1>Objekt-Funktionen</h1>
<i>Objekt-Funktionen</i> werden dazu verwendet, allgemeine Informationen von
Objekten zu erfragen.
<p>
Die folgenden Objekt-Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#312>clrgroup()</a>
<li><a href=#313>ingroup()</a>
<li><a href=#314>setgroup()</a>
<li><a href=#315>setvariant()</a>
<li><a href=#316>variant()</a>
</ul>


<a name=312>
<h1>clrgroup()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
L&ouml;scht die Gruppen-Flags eines Objekts.
<dt>
<b>Syntax</b>
<dd>
<tt>void clrgroup(object);</tt>
</dl>
<b>Siehe auch</b> <a href=#313>ingroup()</a>,
<a href=#314>setgroup()</a>,
<a href=#56>GROUP-Befehl</a>
<p>
Die <tt>clrgroup()</tt>-Funktion l&ouml;scht die Gruppen-Flags des gegebenen Objekts,
so dass es nicht mehr Bestandteil einer vorher definierten Gruppe ist.
<p>
Wird die Funktion auf ein Objekt angewendet, das andere Objekte enth&auml;lt (wie
etwa ein UL_BOARD oder UL_NET), so werden die Gruppen-Flags aller enthaltenen
Objekte rekursiv gel&ouml;scht, wobei entsprechende Einschr&auml;nkungen gelten wie bei
<a href=#314>setgroup()</a>.
<h2>Beispiel</h2>
<pre>
board(B) {
  B.elements(E)
    clrgroup(E);
  }
</pre>


<a name=313>
<h1>ingroup()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Pr&uuml;ft ob ein Objekt in der Gruppe liegt.
<dt>
<b>Syntax</b>
<dd>
<tt>int ingroup(object);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>ingroup</tt>-Funktion liefert einen Wert ungleich 0 wenn das gegebene Objekt
in der Gruppe liegt.
</dl>
<b>Siehe auch</b> <a href=#312>clrgroup()</a>,
<a href=#314>setgroup()</a>,
<a href=#56>GROUP-Befehl</a>
<p>
Wurde im Editor eine Gruppe definiert, so kann die <tt>ingroup()</tt>-Funktion
benutzt werden um zu pr&uuml;fen, ob ein bestimmtes Objekt Bestandteil der Gruppe ist.
<p>
Objekte mit einem einzelnen Aufh&auml;ngepunkt, die in der aktuellen Zeichnung gezielt
selektiert werden k&ouml;nnen (wie etwa UL_TEXT, UL_VIA, UL_CIRCLE etc.), liefern beim
Aufruf von <tt>ingroup()</tt> einen Wert ungleich 0 wenn dieser Aufh&auml;ngepunkt
innerhalb der Gruppe liegt.
<p>
Ein UL_WIRE liefert 0, 1, 2 oder 3, je nachdem, ob keiner, der erste, der zweite
oder beide Endpunkte in der Gruppe liegen.
<p>
Ein UL_RECTANGLE bzw. UL_FRAME liefert einen Wert ungleich 0 wenn einer oder mehrere seiner
Eckpunkte in der Gruppe liegen.
Der Wert hat Bit 0 gesetzt f&uuml;r die rechte obere Ecke, Bit 1 f&uuml;r die linke obere, Bit 2
f&uuml;r die linke untere und Bit 3 f&uuml;r die rechte untere Ecke.
<p>
&Uuml;bergeordnete Objekte, die ohne Aufh&auml;ngepunkt sind (UL_NET, UL_SEGMENT, UL_SIGNAL, UL_POLYGON)
oder als Zeichnungsobjekt eigentlich nicht vorhanden sind (UL_SHEET, UL_DEVICESET, UL_SYMBOL, UL_PACKAGE),
liefern einen Wert ungleich 0 wenn eines oder mehrere der Objekte, die sie enthalten,
in der Gruppe liegen. Details zu den Objekt-Hierarchien siehe <a href=#177>Objekt-Typen</a>.<br>
UL_CONTACTREF und UL_PINREF liefern einen Wert ungleich 0 wenn der referenzierte UL_CONTACT bzw. UL_PIN
in der Gruppe liegt. <br>
F&uuml;r andere nicht selektierbare Objekte wie UL_GRID, UL_VARIANT oder Wires eines UL_TEXT- oder
UL_FRAME-Objektes ist das Verhalten von <tt>ingroup()</tt> undefiniert und sollte daher nicht
verwendet werden.
<h2>Ermitteln des Kontextmen&uuml;-Objekts</h2>
Wenn das ULP von einem Kontextmen&uuml; aus gestartet wurde, wird aus dem Auswahlobjekt
eine einelementige Gruppe gebildet, so dass es mit <tt>ingroup()</tt> identifiziert werden kann
(siehe auch <a href=#97>SET</a> und <a href=#95>RUN</a>).
<h2>Beispiel</h2>
<pre>
output("group.txt") {
  board(B) {
    B.elements(E) {
      if (ingroup(E))
         printf("Element %s is in the group\n", E.name);
      }
    }
  }
</pre>


<a name=314>
<h1>setgroup()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Setzt die Gruppen-Flags eines Objekts.
<dt>
<b>Syntax</b>
<dd>
<tt>void setgroup(object[, int flags]);</tt>
</dl>
<b>Siehe auch</b> <a href=#312>clrgroup()</a>,
<a href=#313>ingroup()</a>,
<a href=#56>GROUP-Befehl</a>
<p>
Die <tt>setgroup()</tt>-Funktion setzt die Gruppen-Flags des gegebenen Objekts,
so dass es Bestandteil der Gruppe ist.
<p>
Werden keine <tt>flags</tt> angegeben, so wird das Objekt als Ganzes zur Gruppe
hinzugef&uuml;gt (d.h. alle seine Aufh&auml;ngepunkte, falls es mehrere hat).
<p>
Hat <tt>flags</tt> einen Wert ungleich Null, werden nur die Gruppen-Flags der
angegebenen Punkte gesetzt. F&uuml;r einen UL_WIRE bedeutet dies, dass <tt>'1'</tt>
das Gruppen-Flag des ersten Punkts setzt, <tt>'2'</tt> das des zweiten und
<tt>'3'</tt> beide. Etwaige bereits gesetzte Gruppen-Flags werden durch den
Aufruf von <tt>setgroup()</tt> nicht ver&auml;ndert.
<p>
Wird die Funktion auf ein Objekt angewendet, das andere Objekte enth&auml;lt (wie
etwa ein UL_BOARD oder UL_NET), so werden die Gruppen-Flags aller enthaltenen
Objekte rekursiv gesetzt mit folgenden Einschr&auml;nkungen:<br>
Es gilt nicht f&uuml;r UL_LIBRARY und UL_SCHEMATIC. Untergeordnete Objekte, die
nicht oder nicht einzeln selektierbar sind, werden nicht markiert
(z.B. UL_GRID- oder UL_VARIANT-Objekte oder Wires von UL_TEXT- oder UL_FRAME-Objekten).
Details zu den Objekt-Hierarchien siehe <a href=#177>Objekt-Typen</a>.
<p>
<h2>Beispiel</h2>
<pre>
board(B) {
  B.elements(E)
    setgroup(E);
  }
</pre>


<a name=315>
<h1>setvariant()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
W&auml;hlt die aktuelle Best&uuml;ckungsvariante.
<dt>
<b>Syntax</b>
<dd>
<tt>int setvariant(string name);</tt>
</dl>
<b>Siehe auch</b> <a href=#316>variant()</a>,
<a href=#220>UL_VARIANTDEF</a>,
<a href=#109>VARIANT-Befehl</a>
<p>
Die <tt>setvariant()</tt>-Funktion setzt die aktuelle Best&uuml;ckungsvariante auf
die mit <tt>name</tt> angegebene. Dies kann dazu benutzt werden durch alle
Bauteile zu gehen und deren Daten genau so zu "sehen", wie sie in der gegebenen
Variante definiert sind.
<p>
<tt>name</tt> muss eine g&uuml;ltige Best&uuml;ckungsvariante referenzieren, die in der
geladenen Zeichnung enthalten ist.
<p>
Diese Funktion liefert einen Wert ungleich 0 zur&uuml;ck, falls die angegebene
Best&uuml;ckungsvariante existiert, ansonsten 0.
<p>
Die mittels eines Aufrufs von <tt>setvariant()</tt> eingestellte Best&uuml;ckungsvariante
ist nur so lange g&uuml;ltig, bis das User Language Programm endet. Danach ist die
Variante in der Zeichnung wieder die selbe wie vor dem Start des ULPs.
<p>
In einem Board kann das Setzen der Best&uuml;ckungsvariante nur erfolgen,
wenn auch ein konsistenter Schaltplan geladen ist.
<h2>Beispiel</h2>
<pre>
if (setvariant("My variant")) {
   // do something ...
else
   // error: unknown variant
</pre>


<a name=316>
<h1>variant()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Abfrage der aktuellen Best&uuml;ckungsvariante.
<dt>
<b>Syntax</b>
<dd>
<tt>string variant(void);</tt>
</dl>
<b>Siehe auch</b> <a href=#315>setvariant()</a>,
<a href=#220>UL_VARIANTDEF</a>,
<a href=#109>VARIANT-Befehl</a>
<p>
Die <tt>variant()</tt>-Funktion liefert den Namen der aktuellen Best&uuml;ckungsvariante.
Ist momentan keine Variante ausgew&auml;hlt, wird ein leerer String (<tt>''</tt>) geliefert.
<h2>Beispiel</h2>
<pre>
string CurrentVariant = variant();
</pre>


<a name=317>
<h1>XML-Funktionen</h1>
<i>XML-Funktionen</i> werden dazu verwendet, XML-Daten (<i>Extensible Markup Language</i>)
zu verarbeiten.
<p>
Die folgenden XML-Funktionen sind verf&uuml;gbar:
<ul>
<li><a href=#318>xmlattribute()</a>
<li><a href=#318>xmlattributes()</a>
<li><a href=#319>xmlelement()</a>
<li><a href=#319>xmlelements()</a>
<li><a href=#320>xmltags()</a>
<li><a href=#321>xmltext()</a>
</ul>


<a name=318>
<h1>xmlattribute(), xmlattributes()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Attribute eines XML-Tags extrahieren.
<dt>
<b>Syntax</b>
<dd>
<tt>string xmlattribute(string xml, string tag, string attribute);</tt><br>
<tt>int xmlattributes(string &amp;array[], string xml, string tag);</tt>
</dl>
<b>Siehe auch</b> <a href=#319>xmlelement()</a>,
<a href=#320>xmltags()</a>,
<a href=#321>xmltext()</a>
<p>
Die <tt>xmlattribute</tt>-Funktion liefert den Wert des gegebenen Attributs
<tt>attribute</tt> f&uuml;r das gegebene Tag <tt>tag</tt> innerhalb des gegebenen
XML-Codes <tt>xml</tt>.
Kommt ein Attribut mehrfach in einem Tag vor, so wird der Wert des letzten Vorkommens
geliefert.
<p>
Die <tt>xmlattributes</tt>-Funktion speichert die Namen aller Attribute des
gegebenen Tags innerhalb des gegebenen XML-Codes in <tt>array</tt> und liefert
die Anzahl der gefundenen Attribute zur&uuml;ck.
Die Reihenfolge stimmt nicht notwendigerweise mit dem gegebenen  XML-Code &uuml;berein.
Kommt ein Attribut mehrfach in einem Tag vor, so erscheint sein Name nur einmal
im <tt>array</tt>.
<p>
Das <tt>tag</tt> wird in Form eines <i>Pfades</i> angegeben.
<p>
Falls der gegebene <tt>xml</tt>-Code einen Fehler enth&auml;lt, so ist das Ergebnis
jeglicher XML-Funktionen leer, und es wird dem Benutzer eine Warnung angezeigt,
welche Informationen dar&uuml;ber enth&auml;lt, an welcher Stelle im ULP bzw. im XML-Code
der Fehler aufgetreten ist. Beachten Sie dabei, dass die Zeilen- und Spaltennummer
im XML-Code sich auf den an diese Funktion als <tt>xml</tt>-Parameter
&uuml;bergebenen String bezieht.
<h2>Beispiel</h2>
<pre>
// XML contains the following data:
&lt;root&gt;
  &lt;body abc="def" xyz="123"&gt;
    ...
  &lt;/body&gt;
&lt;/root&gt;
//
string s[];
int n = xmlattributes(s, XML, "root/body");
Result: { "abc", "xyz" }
string s = xmlattribute(XML, "root/body", "xyz");
Result: "123"
</pre>


<a name=319>
<h1>xmlelement(), xmlelements()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Element aus einem XML-Code extrahieren.
<dt>
<b>Syntax</b>
<dd>
<tt>string xmlelement(string xml, string tag);</tt><br>
<tt>int xmlelements(string &amp;array[], string xml, string tag);</tt>
</dl>
<b>Siehe auch</b> <a href=#320>xmltags()</a>,
<a href=#318>xmlattribute()</a>,
<a href=#321>xmltext()</a>
<p>
Die <tt>xmlelement</tt>-Funktion liefert das komplette XML-Element des gegebenen
Tags <tt>tag</tt> innerhalb des gegebenen XML-Codes <tt>xml</tt>.
Das Ergebnis beinhaltet das &auml;u&szlig;ere XML-Tag des Elements, und kann daher mit den
anderen XML-Funktionen weiterverarbeitet werden.
Leerzeichen, Tabulatoren und Zeilenumbr&uuml;che innerhalb des reinen Textes bleiben erhalten.
Die generelle Formatierung der XML-Tags innerhalb des Elements sowie die Reihenfolge von
Element-Attributen k&ouml;nnen sich jedoch von der im urspr&uuml;nglichen <tt>xml</tt> -Code unterscheiden.<br>
Falls <tt>tag</tt> mehrfach in <tt>xml</tt> vorkommt, wird das erste davon geliefert.
Benutzen Sie <tt>xmlelements</tt> um alle Instanzen zu bekommen.
<p>
Die <tt>xmlelements</tt>-Funktion arbeitet genau wie <tt>xmlelement</tt>, liefert
aber alle Instanzen von Elementen mit dem gegebenen <tt>tag</tt>. Der R&uuml;ckgabewert
ist die Anzahl der Element, die in <tt>array</tt> gespeichert wurden.
<p>
Das <tt>tag</tt> wird in Form eines <i>Pfades</i> angegeben.
<p>
Falls der gegebene <tt>xml</tt>-Code einen Fehler enth&auml;lt, so ist das Ergebnis
jeglicher XML-Funktionen leer, und es wird dem Benutzer eine Warnung angezeigt,
welche Informationen dar&uuml;ber enth&auml;lt, an welcher Stelle im ULP bzw. im XML-Code
der Fehler aufgetreten ist. Beachten Sie dabei, dass die Zeilen- und Spaltennummer
im XML-Code sich auf den an diese Funktion als <tt>xml</tt>-Parameter
&uuml;bergebenen String bezieht.
<h2>Beispiel</h2>
<pre>
// XML contains the following data:
&lt;root&gt;
  &lt;body&gt;
    &lt;contents&gt;
      &lt;string&gt;Some text 1&lt;/string&gt;
      &lt;any&gt;anything 1&lt;/any&gt;
    &lt;/contents&gt;
    &lt;contents&gt;
      &lt;string&gt;Some text 2&lt;/string&gt;
      &lt;any&gt;anything 2&lt;/any&gt;
    &lt;/contents&gt;
    &lt;appendix&gt;
      &lt;string&gt;Some text 3&lt;/string&gt;
    &lt;/appendix&gt;
  &lt;/body&gt;
&lt;/root&gt;
//
string s = xmlelement(XML, "root/body/appendix");
Result: " &lt;appendix&gt;\n  &lt;string&gt;Some text 3&lt;/string&gt;\n &lt;/appendix&gt;\n"
string s[];
int n = xmlelements(s, XML, "root/body/contents");
Result: { " &lt;contents&gt;\n  &lt;string&gt;Some text 1&lt;/string&gt;\n  &lt;any&gt;anything 1&lt;/any&gt;\n &lt;/contents&gt;\n",
          " &lt;contents&gt;\n  &lt;string&gt;Some text 2&lt;/string&gt;\n  &lt;any&gt;anything 2&lt;/any&gt;\n &lt;/contents&gt;\n"
        }
</pre>


<a name=320>
<h1>xmltags()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Liste der Tag-Namen aus einem XML-Code extrahieren.
<dt>
<b>Syntax</b>
<dd>
<tt>int xmltags(string &amp;array[], string xml, string tag);</tt>
</dl>
<b>Siehe auch</b> <a href=#319>xmlelement()</a>,
<a href=#318>xmlattribute()</a>,
<a href=#321>xmltext()</a>
<p>
Die <tt>xmltags</tt>-Funktion liefert die Namen aller Tags auf der obersten Ebene des
gegebenen Tags <tt>tag</tt> innerhalb des gegebenen XML-Codes <tt>xml</tt>.
Der R&uuml;ckgabewert ist die Anzahl der in <tt>array</tt> gespeicherten Tag-Namen.
<p>
Jeder Tag-Name wird nur einmal geliefert, auch wenn er mehrfach im XML-Code vorkommt.
<p>
Das <tt>tag</tt> wird in Form eines <i>Pfades</i> angegeben.
<p>
Falls der gegebene <tt>xml</tt>-Code einen Fehler enth&auml;lt, so ist das Ergebnis
jeglicher XML-Funktionen leer, und es wird dem Benutzer eine Warnung angezeigt,
welche Informationen dar&uuml;ber enth&auml;lt, an welcher Stelle im ULP bzw. im XML-Code
der Fehler aufgetreten ist. Beachten Sie dabei, dass die Zeilen- und Spaltennummer
im XML-Code sich auf den an diese Funktion als <tt>xml</tt>-Parameter
&uuml;bergebenen String bezieht.
<h2>Beispiel</h2>
<pre>
// XML contains the following data:
&lt;root&gt;
  &lt;body&gt;
    &lt;contents&gt;
      &lt;string&gt;Some text 1&lt;/string&gt;
      &lt;any&gt;anything 1&lt;/any&gt;
    &lt;/contents&gt;
    &lt;contents&gt;
      &lt;string&gt;Some text 2&lt;/string&gt;
      &lt;any&gt;anything 2&lt;/any&gt;
    &lt;/contents&gt;
    &lt;appendix&gt;
      &lt;string&gt;Some text 3&lt;/string&gt;
    &lt;/appendix&gt;
  &lt;/body&gt;
&lt;/root&gt;
//
string s[];
int n = xmltags(s, XML, "root/body");
Result: { "contents", "appendix" }
int n = xmltags(s, XML, "");
Result: "root"
</pre>


<a name=321>
<h1>xmltext()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Text aus einem XML-Element extrahieren.
<dt>
<b>Syntax</b>
<dd>
<tt>string xmltext(string xml, string tag);</tt>
</dl>
<b>Siehe auch</b> <a href=#319>xmlelement()</a>,
<a href=#318>xmlattribute()</a>,
<a href=#320>xmltags()</a>
<p>
Die <tt>xmltext</tt>-Funktion liefert den Text des gegebenen Tags <tt>tag</tt>
innerhalb des XML-Codes <tt>xml</tt>.
<p>
Alle Tags innerhalb des Textes werden entfernt, Leerzeichen, Tabulatoren
und Zeilenumbr&uuml;che bleiben erhalten.
<p>
Das <tt>tag</tt> wird in Form eines <i>Pfades</i> angegeben.
<p>
Falls der gegebene <tt>xml</tt>-Code einen Fehler enth&auml;lt, so ist das Ergebnis
jeglicher XML-Funktionen leer, und es wird dem Benutzer eine Warnung angezeigt,
welche Informationen dar&uuml;ber enth&auml;lt, an welcher Stelle im ULP bzw. im XML-Code
der Fehler aufgetreten ist. Beachten Sie dabei, dass die Zeilen- und Spaltennummer
im XML-Code sich auf den an diese Funktion als <tt>xml</tt>-Parameter
&uuml;bergebenen String bezieht.
<h2>Beispiel</h2>
<pre>
// XML contains the following data:
&lt;root&gt;
  &lt;body&gt;
    Some &lt;b&gt;text&lt;/b&gt;.
  &lt;/body&gt;
&lt;/root&gt;
//
string s = xmltext(XML, "root/body");
Result: "\n    Some text.\n  "
</pre>


<a name=322>
<h1>Builtin-Statements</h1>
<i>Builtin-Statements</i> werden im allgemeinen dazu verwendet,
einen Kontext zu er&ouml;ffnen, der den Zugriff auf Datenstrukturen und Dateien
erlaubt.
<p>
Die allgemeine Syntax von Builtin-Statements ist
<pre>
name(parameters) statement
</pre>
wobei <tt>name</tt> der Name des Builtin-Statement ist, <tt>parameters</tt>
steht f&uuml;r einen oder mehrere Parameter, und <tt>statement</tt> ist der Code,
der innerhalb des vom Builtin-Statement ge&ouml;ffneten Kontexts ausgef&uuml;hrt wird.
<p>
Beachten Sie, dass es sich bei <tt>statement</tt> um eine Compound-Statement
handeln kann, wie in
<pre>
board(B) {
  B.elements(E) printf("Element: %s\n", E.name);
  B.signals(S)  printf("Signal: %s\n", S.name);
  }
</pre>
Die folgenden Builtin-Statements sind verf&uuml;gbar:
<ul>
<li><a href=#323>board()</a>
<li><a href=#324>deviceset()</a>
<li><a href=#325>library()</a>
<li><a href=#326>module()</a>
<li><a href=#327>output()</a>
<li><a href=#328>package()</a>
<li><a href=#329>schematic()</a>
<li><a href=#330>sheet()</a>
<li><a href=#331>symbol()</a>
</ul>


<a name=323>
<h1>board()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Board-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>board(identifier) statement</tt>
</dl>
<b>Siehe auch</b> <a href=#329>schematic</a>,
<a href=#325>library</a>
<p>
Das <tt>board</tt>-Statement &ouml;ffnet einen Board-Kontext wenn das gegenw&auml;rtige
Editor-Fenster ein Board enth&auml;lt. Eine Variable vom Typ
<a href=#181>UL_BOARD</a> wird angelegt und erh&auml;lt den Namen,
den <tt>identifier</tt> angibt.
<p>
Sobald der Board-Kontext erfolgreich ge&ouml;ffnet wurde und eine Board-Variable
angelegt ist, wird <tt>statement</tt> ausgef&uuml;hrt. Innerhalb des
G&uuml;ltigkeitsbereichs von <tt>statement</tt> kann man auf die Board-Variable
zugreifen, um weitere Daten aus dem Board zu erhalten.
<p>
Wenn das gegenw&auml;rtige Editor-Fenster kein Board enth&auml;lt, wird eine
Fehlermeldung ausgegeben, und das ULP wird beendet.
<h2>Pr&uuml;fen, ob ein Board geladen ist</h2>
Mit dem <tt>board</tt>-Statement ohne Angabe eines Arguments k&ouml;nnen
Sie pr&uuml;fen, ob das gegenw&auml;rtige Editor-Fenster ein Board enth&auml;lt.
In diesem Fall verh&auml;lt sich <tt>board</tt> wie eine Integer-Konstante,
die den Wert <tt>1</tt> zur&uuml;ckgibt, sofern ein Board geladen ist.
Andernfalls wird der Wert <tt>0</tt> zur&uuml;ckgegeben.
<h2>Zugriff auf ein Board von einem Schaltplan aus</h2>
Wenn das gegenw&auml;rtige Editor-Fenster einen Schaltplan enth&auml;lt,
k&ouml;nnen Sie trotzdem auf das zugeh&ouml;rige Board zugreifen, indem Sie
dem <tt>board</tt>-Statement den Pr&auml;fix <tt>project</tt> voranstellen,
wie in
<pre>
project.board(B) { ... }
</pre>
Das &ouml;ffnet einen Board-Kontext, unabh&auml;ngig davon, ob das gegenw&auml;rtige
Editor-Fenster ein Board oder einen Schaltplan enth&auml;lt. Allerdings muss
es auf dem Desktop ein Fenster geben, das dieses Board enth&auml;lt!
<h2>Beispiel</h2>
<pre>
if (board)
   board(B) {
     B.elements(E)
       printf("Element: %s\n", E.name);
     }
</pre>


<a name=324>
<h1>deviceset()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Device-Set-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>deviceset(identifier) statement</tt>
</dl>
<b>Siehe auch</b> <a href=#328>package</a>,
<a href=#331>symbol</a>,
<a href=#325>library</a>
<p>
Das <tt>deviceset</tt>-Statement &ouml;ffnet einen Device-Set-Kontext wenn das gegenw&auml;rtige
Editor-Fenster ein Device-Set enth&auml;lt. Eine Variable vom Typ
<a href=#188>UL_DEVICESET</a> wird angelegt und erh&auml;lt den Namen,
den <tt>identifier</tt> angibt.
<p>
Sobald der Device-Set-Kontext erfolgreich ge&ouml;ffnet wurde und eine Device-Set-Variable
angelegt ist, wird <tt>statement</tt> ausgef&uuml;hrt. Innerhalb des
G&uuml;ltigkeitsbereichs von <tt>statement</tt> kann man auf die Device-Set-Variable
zugreifen, um weitere Daten aus dem Device-Set zu erhalten.
<p>
Wenn das gegenw&auml;rtige Editor-Fenster kein Device-Set enth&auml;lt, wird eine
Fehlermeldung ausgegeben, und das ULP wird beendet.
<h2>Pr&uuml;fen, ob ein Device-Set geladen ist</h2>
Mit dem <tt>deviceset</tt>-Statement ohne Angabe eines Arguments k&ouml;nnen
Sie pr&uuml;fen, ob das gegenw&auml;rtige Editor-Fenster ein Device-Set enth&auml;lt.
In diesem Fall verh&auml;lt sich <tt>deviceset</tt> wie eine Integer-Konstante,
die den Wert <tt>1</tt> zur&uuml;ckgibt, sofern ein Device-Set geladen ist.
Andernfalls wird der Wert <tt>0</tt> zur&uuml;ckgegeben.
<h2>Beispiel</h2>
<pre>
if (deviceset)
   deviceset(D) {
     D.gates(G)
       printf("Gate: %s\n", G.name);
     }
</pre>


<a name=325>
<h1>library()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Library-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>library(identifier) statement</tt>
</dl>
<b>Siehe auch</b> <a href=#323>board</a>,
<a href=#329>schematic</a>,
<a href=#324>deviceset</a>,
<a href=#328>package</a>,
<a href=#331>symbol</a>
<p>
Das <tt>library</tt>-Statement &ouml;ffnet einen Library-Kontext wenn das gegenw&auml;rtige
Editor-Fenster eine Library enth&auml;lt. Eine Variable vom Typ
<a href=#200>UL_LIBRARY</a> wird angelegt und erh&auml;lt den Namen,
den <tt>identifier</tt> angibt.
<p>
Sobald der Library-Kontext erfolgreich ge&ouml;ffnet wurde und eine Board-Variable
angelegt ist, wird <tt>statement</tt> ausgef&uuml;hrt. Innerhalb des
G&uuml;ltigkeitsbereichs von <tt>statement</tt> kann man auf die Library-Variable
zugreifen, um weitere Daten aus der Bibliothek zu erhalten.
<p>
Wenn das gegenw&auml;rtige Editor-Fenster keine Bibliothek enth&auml;lt, wird eine
Fehlermeldung ausgegeben, und das ULP wird beendet.
<h2>Pr&uuml;fen, ob eine Bibliothek geladen ist</h2>
Mit dem <tt>library</tt>-Statement ohne Angabe eines Arguments k&ouml;nnen
Sie pr&uuml;fen, ob das gegenw&auml;rtige Editor-Fenster eine Bibliothek enth&auml;lt.
In diesem Fall verh&auml;lt sich <tt>library</tt> wie eine Integer-Konstante,
die den Wert <tt>1</tt> zur&uuml;ckgibt, sofern eine Bibliothek geladen ist.
Andernfalls wird der Wert <tt>0</tt> zur&uuml;ckgegeben.
<h2>Beispiel</h2>
<pre>
if (library)
   library(L) {
     L.devices(D)
       printf("Device: %s\n", D.name);
     }
</pre>


<a name=326>
<h1>module()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Modul-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>module(identifier) statement</tt>
</dl>
<b>Siehe auch</b> <a href=#323>board</a>,
<a href=#325>library</a>,
<a href=#329>schematic</a>,
<a href=#330>sheet</a>
<p>
Das <tt>module</tt>-Statement &ouml;ffnet einen Modul-Kontext, wenn im
Editor-Fenster gerade ein Modul editiert wird. Eine Variable vom Typ
<a href=#201>UL_MODULE</a> wird angelegt und erh&auml;lt den Namen,
den <tt>identifier</tt> angibt.
<p>
Sobald der Modul-Kontext erfolgreich ge&ouml;ffnet wurde und eine UL_MODULE-Variable
angelegt ist, wird <tt>statement</tt> ausgef&uuml;hrt. Innerhalb des
G&uuml;ltigkeitsbereichs von <tt>statement</tt> kann man auf die UL_MODULE-Variable
zugreifen, um weitere Daten aus dem Modul zu erhalten.
<p>
Wenn im Editor-Fenster gerade kein Modul editiert wird, wird eine
Fehlermeldung ausgegeben, und das ULP wird beendet.
<h2>Pr&uuml;fen, ob gerade ein Modul editiert wird</h2>
Mit dem <tt>module</tt>-Statement ohne Angabe eines Arguments k&ouml;nnen
Sie pr&uuml;fen, ob im Editor-Fenster gerade ein Modul editiert wird.
In diesem Fall verh&auml;lt sich <tt>module</tt> wie eine Integer-Konstante,
die den Wert <tt>1</tt> zur&uuml;ckgibt, sofern ein Modul editiert wird.
Andernfalls wird der Wert <tt>0</tt> zur&uuml;ckgegeben.
<h2>Beispiel</h2>
<pre>
if (module)
   module(M) {
     printf("Module: %s\n", M.name);
     }
</pre>


<a name=327>
<h1>output()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet eine Ausgabe-Datei f&uuml;r nachfolgende printf()-Aufrufe.
<dt>
<b>Syntax</b>
<dd>
<tt>output(string filename[, string mode]) statement</tt>
</dl>
<b>Siehe auch</b> <a href=#291>printf</a>,
<a href=#262>fileerror</a>
<p>
Das <tt>output</tt>-Statement &ouml;ffnet eine Datei mit dem Namen <tt>filename</tt>
und dem Parameter <tt>mode</tt> f&uuml;r die Ausgabe mit nachfolgenden
printf()-Aufrufen. Sobald die Datei erfolgreich ge&ouml;ffnet wurde, wird
<tt>statement</tt> ausgef&uuml;hrt, und danach wird die Datei geschlossen.
<p>
Wenn die Datei nicht ge&ouml;ffnet werden kann, wird eine Fehlermeldung ausgegeben,
und das ULP wird beendet.
<p>
Standardm&auml;&szlig;ig wird die erzeugte Datei in das <b>Projekt</b> Verzeichnis
geschrieben.
<h2>Datei-Modi</h2>
Der <tt>mode</tt>-Parameter definiert, wie die Datei ge&ouml;ffnet werden soll.
Wenn kein <tt>mode</tt>-Parameter angegeben ist, gilt der Standardwert <tt>"wt"</tt>.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>a</tt>   </td><td width=20><td>an existierende Datei anh&auml;ngen oder neue Datei anlegen, falls die Datei nicht existiert</td></tr>
<tr><td><tt>w</tt>   </td><td width=20><td>neue Datei anlegen (existierende &uuml;berschreiben)</td></tr>
<tr><td><tt>t</tt>   </td><td width=20><td>Datei im Textmodus &ouml;ffnen</td></tr>
<tr><td><tt>b</tt>   </td><td width=20><td>Datei im Bin&auml;rmodus &ouml;ffnen</td></tr>
<tr><td><tt>D</tt>   </td><td width=20><td>Datei am Ende der EAGLE-Sitzung l&ouml;schen (funktioniert nur zusammen mit <tt>w</tt>)</td></tr>
<tr><td><tt>F</tt>   </td><td width=20><td>diesen Dateinamen erzwingen (normalerweise werden *.brd, *.sch und *.lbr abgewiesen)</td></tr>
</table>
<p>
Mode-Parameter k&ouml;nnen in beliebiger Kombination und Reihenfolge
angegeben werden. Allerdings ist nur der letzte aus <tt>a</tt> und <tt>w</tt>
bzw. <tt>t</tt> und <tt>b</tt> signifikant.
Die Angabe <tt>"abtw"</tt> w&uuml;rde zum Beispiel eine Textdatei &ouml;ffnen (entsprechend <tt>"wt"</tt>).
<h2>Verschachtelte Output-Statements</h2>
<tt>output</tt>-Statements k&ouml;nnen verschachtelt werden,
solange gen&uuml;gend Datei-Handles verf&uuml;gbar sind - vorausgesetzt, es greifen
nicht mehrere aktive <tt>output</tt>-Statements auf dieselbe Datei zu.
<h2>Beispiel</h2>
<pre>
void PrintText(string s)
{
  printf("This also goes into the file: %s\n", s);
}
output("file.txt", "wt") {
  printf("Directly printed\n");
  PrintText("via function call");
  }
</pre>


<a name=328>
<h1>package()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Package-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>package(identifier) statement</tt>
</dl>
<b>Siehe auch</b> <a href=#325>library</a>,
<a href=#324>deviceset</a>,
<a href=#331>symbol</a>
<p>
Das <tt>package</tt>-Statement &ouml;ffnet einen Package-Kontext wenn das gegenw&auml;rtige
Editor-Fenster ein Package enth&auml;lt. Eine Variable vom Typ
<a href=#204>UL_PACKAGE</a> wird angelegt und erh&auml;lt den Namen,
den <tt>identifier</tt> angibt.
<p>
Sobald der Package-Kontext erfolgreich ge&ouml;ffnet wurde und eine Package-Variable
angelegt ist, wird <tt>statement</tt> ausgef&uuml;hrt. Innerhalb des
G&uuml;ltigkeitsbereichs von <tt>statement</tt> kann man auf die Package-Variable
zugreifen, um weitere Daten aus dem Package zu erhalten.
<p>
Wenn das gegenw&auml;rtige Editor-Fenster kein Package enth&auml;lt, wird eine
Fehlermeldung ausgegeben, und das ULP wird beendet.
<h2>Pr&uuml;fen, ob ein Package geladen ist</h2>
Mit dem <tt>package</tt>-Statement ohne Angabe eines Arguments k&ouml;nnen
Sie pr&uuml;fen, ob das gegenw&auml;rtige Editor-Fenster ein Package enth&auml;lt.
In diesem Fall verh&auml;lt sich <tt>package</tt> wie eine Integer-Konstante,
die den Wert <tt>1</tt> zur&uuml;ckgibt, sofern ein Package geladen ist.
Andernfalls wird der Wert <tt>0</tt> zur&uuml;ckgegeben.
<h2>Beispiel</h2>
<pre>
if (package)
   package(P) {
     P.contacts(C)
       printf("Contact: %s\n", C.name);
     }
</pre>


<a name=329>
<h1>schematic()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Schaltplan-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>schematic(identifier) statement</tt>
</dl>
<b>Siehe auch</b> <a href=#323>board</a>,
<a href=#325>library</a>,
<a href=#326>module</a>,
<a href=#330>sheet</a>
<p>
Das <tt>schematic</tt>-Statement &ouml;ffnet einen Schaltplan-Kontext wenn das gegenw&auml;rtige
Editor-Fenster einen Schaltplan enth&auml;lt. Eine Variable vom Typ
<a href=#213>UL_SCHEMATIC</a> wird angelegt und erh&auml;lt den Namen,
den <tt>identifier</tt> angibt.
<p>
Sobald der Schaltplan-Kontext erfolgreich ge&ouml;ffnet wurde und eine UL_SCHEMATIC-Variable
angelegt ist, wird <tt>statement</tt> ausgef&uuml;hrt. Innerhalb des
G&uuml;ltigkeitsbereichs von <tt>statement</tt> kann man auf die UL_SCHEMATIC-Variable
zugreifen, um weitere Daten aus dem Schaltplan zu erhalten.
<p>
Wenn das gegenw&auml;rtige Editor-Fenster keinen Schaltplan enth&auml;lt, wird eine
Fehlermeldung ausgegeben, und das ULP wird beendet.
<h2>Pr&uuml;fen, ob ein Schaltplan geladen ist</h2>
Mit dem <tt>schematic</tt>-Statement ohne Angabe eines Arguments k&ouml;nnen
Sie pr&uuml;fen, ob das gegenw&auml;rtige Editor-Fenster einen Schaltplan enth&auml;lt.
In diesem Fall verh&auml;lt sich <tt>schematic</tt> wie eine Integer-Konstante,
die den Wert <tt>1</tt> zur&uuml;ckgibt, sofern ein Schaltplan geladen ist.
Andernfalls wird der Wert <tt>0</tt> zur&uuml;ckgegeben.
<h2>Zugriff auf einen Schaltplan vom Board aus</h2>
Wenn das gegenw&auml;rtige Editor-Fenster ein Board enth&auml;lt,
k&ouml;nnen Sie trotzdem auf den zugeh&ouml;rigen Schaltplan zugreifen, indem Sie
dem <tt>schematic</tt>-Statement den Pr&auml;fix <tt>project</tt> voranstellen,
wie in
<pre>
project.schematic(S) { ... }
</pre>
Das &ouml;ffnet einen UL_SCHEMATIC-Kontext, unabh&auml;ngig davon, ob das gegenw&auml;rtige
Editor-Fenster ein Board oder einen Schaltplan enth&auml;lt. Allerdings muss
es auf dem Desktop ein Fenster geben, das diesen Schaltplan enth&auml;lt!
<h2>Zugriff auf die gegenw&auml;rtige Seite eines Schaltplans</h2>
Verwenden Sie das <tt><a href=#330>sheet</a></tt>-Statement,
um direkt auf die gegenw&auml;rtig geladene Schaltplanseite zuzugreifen.
<h2>Zugriff auf das gerade editierte Modul</h2>
Verwenden Sie das <tt><a href=#326>module</a></tt>-Statement,
um direkt auf das gerade editierte Modul zuzugreifen.
<h2>Beispiel</h2>
<pre>
if (schematic)
   schematic(S) {
     S.parts(P)
       printf("Part: %s\n", P.name);
     }
</pre>


<a name=330>
<h1>sheet()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen UL_SHEET-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>sheet(identifier) statement</tt>
</dl>
<b>Siehe auch</b> <a href=#329>schematic</a>
<p>
Das <tt>sheet</tt>-Statement &ouml;ffnet einen UL_SHEET-Kontext, wenn das gegenw&auml;rtige
Editor-Fenster eine Schaltplanseite enth&auml;lt. Eine Variable vom Typ
<a href=#215>UL_SHEET</a> wird angelegt und erh&auml;lt den Namen,
den <tt>identifier</tt> angibt.
<p>
Sobald der UL_SHEET-Kontext erfolgreich ge&ouml;ffnet wurde und eine UL_SHEET-Variable
angelegt ist, wird <tt>statement</tt> ausgef&uuml;hrt. Innerhalb des
G&uuml;ltigkeitsbereichs von <tt>statement</tt> kann man auf die UL_SHEET-Variable
zugreifen, um weitere Daten aus der Seite zu erhalten.
<p>
Wenn das gegenw&auml;rtige Editor-Fenster keine Schaltplanseite enth&auml;lt, wird eine
Fehlermeldung ausgegeben, und das ULP wird beendet.
<h2>Pr&uuml;fen, ob eine Schaltplanseite geladen ist</h2>
Mit dem <tt>sheet</tt>-Statement ohne Angabe eines Arguments k&ouml;nnen
Sie pr&uuml;fen, ob das gegenw&auml;rtige Editor-Fenster eine Schaltplanseite enth&auml;lt.
In diesem Fall verh&auml;lt sich <tt>sheet</tt> wie eine Integer-Konstante,
die den Wert <tt>1</tt> zur&uuml;ckgibt, sofern eine Schaltplanseite geladen ist.
Andernfalls wird der Wert <tt>0</tt> zur&uuml;ckgegeben.
<h2>Beispiel</h2>
<pre>
if (sheet)
   sheet(S) {
     S.instances(I)
       printf("Instance: %s\n", I.name);
     }
</pre>


<a name=331>
<h1>symbol()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Symbol-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>symbol(identifier) statement</tt>
</dl>
<b>Siehe auch</b> <a href=#325>library</a>,
<a href=#324>deviceset</a>,
<a href=#328>package</a>
<p>
Das <tt>symbol</tt>-Statement &ouml;ffnet einen Symbol-Kontext wenn das gegenw&auml;rtige
Editor-Fenster ein Symbol enth&auml;lt. Eine Variable vom Typ
<a href=#218>UL_SYMBOL</a> wird angelegt und erh&auml;lt den Namen,
den <tt>identifier</tt> angibt.
<p>
Sobald der Symbol-Kontext erfolgreich ge&ouml;ffnet wurde und eine Symbol-Variable
angelegt ist, wird <tt>statement</tt> ausgef&uuml;hrt. Innerhalb des
G&uuml;ltigkeitsbereichs von <tt>statement</tt> kann man auf die Symbol-Variable
zugreifen, um weitere Daten aus dem Symbol zu erhalten.
<p>
Wenn das gegenw&auml;rtige Editor-Fenster kein Symbol enth&auml;lt, wird eine
Fehlermeldung ausgegeben, und das ULP wird beendet.
<h2>Pr&uuml;fen, ob ein Symbol geladen ist</h2>
Mit dem <tt>symbol</tt>-Statement ohne Angabe eines Arguments k&ouml;nnen
Sie pr&uuml;fen, ob das gegenw&auml;rtige Editor-Fenster ein Symbol enth&auml;lt.
In diesem Fall verh&auml;lt sich <tt>symbol</tt> wie eine Integer-Konstante,
die den Wert <tt>1</tt> zur&uuml;ckgibt, sofern ein Symbol geladen ist.
Andernfalls wird der Wert <tt>0</tt> zur&uuml;ckgegeben.
<h2>Beispiel</h2>
<pre>
if (symbol)
   symbol(S) {
     S.pins(P)
       printf("Pin: %s\n", P.name);
     }
</pre>


<a name=332>
<h1>Dialoge</h1>
User-Language-Dialoge erm&ouml;glichen es, ein eigenes Frontend f&uuml;r ein User-Language-Progamm zu definieren.
<p>
In den folgenden Abschnitten werden die User-Language-Dialoge detailliert beschrieben:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#333>Vordefinierte Dialoge</a>  </td><td width=20><td>beschreibt vordefinierte Standard-Dialoge</td></tr>
<tr><td><a href=#337>Dialog-Objekte</a>  </td><td width=20><td>beschreibt die Objekte aus denen ein Dialog bestehen kann</td></tr>
<tr><td><a href=#361>Layout-Information</a>  </td><td width=20><td>erkl&auml;rt wie man die Position von Objekten in einem Dialog bestimmt</td></tr>
<tr><td><a href=#362>Dialog-Funktionen</a>  </td><td width=20><td>beschreibt besondere Funktionen, die mit Dialogen verwendet werden k&ouml;nnen</td></tr>
<tr><td><a href=#369>Ein vollst&auml;ndiges Beispiel</a>  </td><td width=20><td>zeigt ein vollst&auml;ndiges ULP mit einem Dialog zur Daten-Eingabe</td></tr>
</table>


<a name=333>
<h1>Vordefinierte Dialoge</h1>
<i>Vordefinierte Dialoge</i> sind die typischen Dialoge, die h&auml;ufig zur Dateiauswahl oder
bei Fehlermeldungen verwendet werden.
<p>
Es gibt folgende vordefinierte Dialoge:
<ul>
<li><a href=#334>dlgDirectory()</a>
<li><a href=#335>dlgFileOpen()</a>
<li><a href=#335>dlgFileSave()</a>
<li><a href=#336>dlgMessageBox()</a>
</ul>
Siehe <a href=#337>Dialog-Objekte</a> f&uuml;r Informationen &uuml;ber
das Definieren eigener, komplexer Benutzer-Dialoge.


<a name=334>
<h1>dlgDirectory()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeigt den Verzeichnis-Dialog.
<dt>
<b>Syntax</b>
<dd>
<tt>string dlgDirectory(string Title[, string Start])</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>dlgDirectory</tt>-Funktion liefert den vollen Pfadnamen des gew&auml;hlten Verzeichnisses.<br>
Hat der Benutzer den Dialog abgebrochen, ist das Resultat ein leerer String.
</dl>
<b>Siehe auch</b> <a href=#335>dlgFileOpen</a>
<p>
Die <tt>dlgDirectory</tt>-Funktion zeigt einen Verzeichnis-Dialog in dem der Benutzer ein Verzeichnis
selektieren kann.
<p>
<tt>Title</tt> zeigt den Titel des Dialogs.
<p>
Wenn <tt>Start</tt> nicht leer ist, wird diese Angabe als Startpunkt f&uuml;r <tt>dlgDirectory</tt> verwendet.
<h2>Beispiel</h2>
<pre>
string dirName;
dirName = dlgDirectory("Select a directory", "");
</pre>


<a name=335>
<h1>dlgFileOpen(), dlgFileSave()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeigt einen Datei-Dialog.
<dt>
<b>Syntax</b>
<dd>
<tt>string dlgFileOpen(string Title[, string Start[, string Filter]])</tt><br>
<tt>string dlgFileSave(string Title[, string Start[, string Filter]])</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die Funktionen <tt>dlgFileOpen</tt> und <tt>dlgFileSave</tt> liefern die volle Pfadangabe
der gew&auml;hlten Datei.<br>
Bricht der Benutzer den Dialog ab, ist das Ergebnis ein leerer String.
</dl>
<b>Siehe auch</b> <a href=#334>dlgDirectory</a>
<p>
Die Funktionen <tt>dlgFileOpen</tt> und <tt>dlgFileSave</tt> zeigen einen Datei-Dialog, aus dem
der Benutzer eine Datei selektieren kann.
<p>
<tt>Title</tt> wird als Titel des Dialogs verwendet.
<p>
Ist <tt>Start</tt> nicht leer, wird diese Angabe als Startpunkt f&uuml;r den Dialog verwendet.
Ansonsten wird das aktuelle Verzeichnis verwendet.
<p>
Nur Dateien, die der Angabe von <tt>Filter</tt> entsprechen, werden angezeigt. Wird kein
<tt>Filter</tt> angegeben, werden alle Dateien angezeigt.
<p>
<tt>Filter</tt> kann entweder ein einfacher Pattern sein (wie in <tt>"*.brd"</tt>), eine Liste von
Patterns (wie in <tt>"*.bmp&nbsp;*.jpg"</tt>) oder kann sogar beschreibenden Text enthalten, wie in
<tt>"Bitmap-Dateien&nbsp;(*.bmp)"</tt>. Falls die "Dateityp" Combo-Box des Datei-Dialogs mehrere
Eintr&auml;ge haben soll, m&uuml;ssen diese durch zwei Semikolons voneinander getrennt werden, wie in
<tt>"Bitmap-Dateien&nbsp;(*.bmp);;Andere&nbsp;Bilddateien&nbsp;(*.jpg&nbsp;*.png)"</tt>.
<h2>Beispiel</h2>
<pre>
string fileName;
fileName = dlgFileOpen("Select a file", "", "*.brd");
</pre>


<a name=336>
<h1>dlgMessageBox()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Zeigt eine Message-Box.
<dt>
<b>Syntax</b>
<dd>
<tt>int dlgMessageBox(string Message[, <i>button_list</i>])</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>dlgMessageBox</tt>-Funktion liefert den Index der Schaltfl&auml;che, die der Benutzer selektiert hat.<br>
Die erste Schaltfl&auml;che in <tt>button_list</tt> hat den Index <tt>0</tt>.
</dl>
<b>Siehe auch</b> <a href=#283>status()</a>
<p>
Die <tt>dlgMessageBox</tt>-Funktion zeigt die angegebene <tt>Message</tt> in einem modalen Dialog-Fenster und
wartet darauf, dass der Benutzer eine der Schaltfl&auml;chen, die &uuml;ber
<tt>button_list</tt> definiert wurden, selektiert.
<p>
Falls <tt>Message</tt> HTML-Tags enth&auml;lt, so m&uuml;ssen die Zeichen '&lt;', '&gt;' und '&amp;',
damit sie als solche angezeigt werden, als "&amp;lt;", "&amp;gt;" bzw. "&amp;amp;" angegeben
werden.
<p>
<tt>button_list</tt> ist eine optionale Liste durch Komma getrennter Strings, die einen Satz von
Schaltfl&auml;chen, die unten im Dialog-Fenster angezeigt werden, definiert.<br>
Es k&ouml;nnen maximal drei Schaltfl&auml;chen definiert werden.
Wird keine <tt>button_list</tt> angegeben, erscheint automatisch <tt>"OK"</tt>.
<p>
Die erste Schaltfl&auml;che in <tt>button_list</tt> wird die Default-Schaltfl&auml;che (sie wird gedr&uuml;ckt, wenn
der Benutzer ENTER dr&uuml;ckt), und der letzte Eintrag in der Liste wird der "Cancel-Button", der gew&auml;hlt
wird, wenn der Benutzer Esc dr&uuml;ckt oder das Dialog-Fenster einfach schlie&szlig;t.
Sie k&ouml;nnen eine andere Schaltfl&auml;che als Default-Button definieren, indem Sie den String mit
einem <tt>'+'</tt> beginnen. Wollen Sie eine andere Schaltfl&auml;che als Cancel-Button definieren, stellen
Sie dem String ein <tt>'-'</tt> voran.
Um einen Schaltfl&auml;chen-Text mit einem <tt>'+'</tt> oder <tt>'-'</tt> zu beginnen, muss das Zeichen mit einem
<a href=#368>Escape-Zeichen</a> markiert werden.
<p>
Enth&auml;lt der Text ein <tt>'&amp;'</tt>, wird das folgende Zeichen zum Hotkey. Wenn der Benutzer
die entsprechende Taste dr&uuml;ckt, wird diese Schaltfl&auml;che gew&auml;hlt.
Um das Zeichen <tt>'&amp;'</tt> im Schaltfl&auml;chen-Text zu verwenden, muss es mit einem
<a href=#368>Escape-Zeichen</a> markiert werden.
<p>
Dem Dialog-Fenster kann ein Icon mitgegeben werden, indem das erste Zeichen in <tt>Message</tt> auf<br>
&nbsp;&nbsp;&nbsp;<tt>'<b>;</b>'</tt> - f&uuml;r eine <i>Information</i><br>
&nbsp;&nbsp;&nbsp;<tt>'<b>!</b>'</tt> - f&uuml;r eine <i>Warnung</i><br>
&nbsp;&nbsp;&nbsp;<tt>'<b>:</b>'</tt> - f&uuml;r einen <i>Fehler</i><br>
gesetzt wird.
Soll die <tt>Message</tt> jedoch mit einem dieser Zeichen beginnen, so muss dieses mit einem
<a href=#368>Escape-Zeichen</a> markiert werden.
<p>
<table><tr><td valign="top"><img src="platforms-mac.png"></td><td valign="middle">
Unter <b>Mac OS X</b> f&uuml;hrt nur das Zeichen <tt>'<b>:</b>'</tt> tats&auml;chlich zur
Darstellung eines Icons. Alle anderen werden ignoriert.
</td></tr></table>
<h2>Beispiel</h2>
<pre>
if (dlgMessageBox("Are you sure?", "&amp;Yes", "&amp;No") == 0) {
   // let's do it!
   }
</pre>


<a name=337>
<h1>Dialog-Objekte</h1>
Ein User-Language-Dialog kann aus folgenden <i>Dialog-Objekten</i> bestehen
(die einzelnen Begriffe wurden in diesem Fall nicht ins Deutsche &uuml;bersetzt,
da sonst der Zusammenhang zu den ULP-Objekten verloren ginge):
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#338>dlgCell</a>    </td><td width=20><td>ein Grid-Cell-Kontext</td></tr>
<tr><td><a href=#339>dlgCheckBox</a>      </td><td width=20><td>eine Checkbox</td></tr>
<tr><td><a href=#340>dlgComboBox</a>      </td><td width=20><td>ein Combo-Box-Auswahl-Feld</td></tr>
<tr><td><a href=#341>dlgDialog</a>          </td><td width=20><td>die Grundlage eines jeden Dialogs</td></tr>
<tr><td><a href=#342>dlgGridLayout</a>  </td><td width=20><td>ein Grid-basierter-Layout-Kontext</td></tr>
<tr><td><a href=#343>dlgGroup</a>            </td><td width=20><td>ein Group-Feld</td></tr>
<tr><td><a href=#344>dlgHBoxLayout</a>  </td><td width=20><td>ein Horizontal-Box-Layout-Kontext</td></tr>
<tr><td><a href=#345>dlgIntEdit</a>        </td><td width=20><td>ein Integer-Eingabe-Feld</td></tr>
<tr><td><a href=#346>dlgLabel</a>            </td><td width=20><td>ein Text-Label</td></tr>
<tr><td><a href=#347>dlgListBox</a>        </td><td width=20><td>eine List-Box</td></tr>
<tr><td><a href=#348>dlgListView</a>      </td><td width=20><td>eine List-View</td></tr>
<tr><td><a href=#349>dlgPushButton</a>  </td><td width=20><td>ein Push-Button</td></tr>
<tr><td><a href=#350>dlgRadioButton</a></td><td width=20><td>ein Radio-Button</td></tr>
<tr><td><a href=#351>dlgRealEdit</a>      </td><td width=20><td>ein Real-Eingabe-Feld</td></tr>
<tr><td><a href=#352>dlgSpacing</a>        </td><td width=20><td>ein Layout-Spacing-Objekt</td></tr>
<tr><td><a href=#353>dlgSpinBox</a>        </td><td width=20><td>ein Spin-Box-Auswahl-Feld</td></tr>
<tr><td><a href=#354>dlgStretch</a>        </td><td width=20><td>ein Layout-Stretch-Objekt</td></tr>
<tr><td><a href=#355>dlgStringEdit</a>  </td><td width=20><td>ein String-Eingabe-Feld</td></tr>
<tr><td><a href=#356>dlgTabPage</a>        </td><td width=20><td>eine Tab-Page</td></tr>
<tr><td><a href=#357>dlgTabWidget</a>    </td><td width=20><td>ein Tab-Page-Container</td></tr>
<tr><td><a href=#358>dlgTextEdit</a>      </td><td width=20><td>ein Text-Eingabe-Feld</td></tr>
<tr><td><a href=#359>dlgTextView</a>      </td><td width=20><td>ein Text-Viewer-Feld</td></tr>
<tr><td><a href=#360>dlgVBoxLayout</a>  </td><td width=20><td>ein Vertical-Box-Layout-Kontext</td></tr>
</table>
<p>


<a name=338>
<h1>dlgCell</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert die Position einer Cell (Zelle) in einem Grid-Layout-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgCell(int row, int column[, int row2, int column2]) <i>statement</i></tt>
</dl>
<b>Siehe auch</b> <a href=#342>dlgGridLayout</a>,
<a href=#344>dlgHBoxLayout</a>,
<a href=#360>dlgVBoxLayout</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgCell</tt>-Statement definiert die Lage einer Cell in einem
<a href=#342>Grid-Layout-Kontext</a>.
<p>
Der Index f&uuml;r Reihe (row) und Spalte (column) beginnt mit 0, so das die obere linke Cell den Index &nbsp;(0,&nbsp;0) hat.
<p>
Mit zwei Parametern wird das Dialog-Objekt, das in <tt>statement</tt> angegeben wurde, in einer Cell
an der Stelle <tt>row</tt> und <tt>column</tt> plaziert.
Mit vier Parametern erstreckt sich das Objekt &uuml;ber alle Cells von <tt>row</tt>/<tt>column</tt>
bis zu <tt>row2</tt>/<tt>column2</tt>.
<p>
Standardm&auml;&szlig;ig enth&auml;lt <tt>dlgCell</tt> ein <a href=#344>dlgHBoxLayout</a>.
Enth&auml;lt eine Cell mehr als ein Dialog-Objekt, werden diese nebeneinander horizontal angeordnet.
<h2>Beispiel</h2>
<pre>
string Text;
dlgGridLayout {
  dlgCell(0, 0) dlgLabel("Cell 0,0");
  dlgCell(1, 2, 4, 7) dlgTextEdit(Text);
  }
</pre>


<a name=339>
<h1>dlgCheckBox</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert eine Checkbox.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgCheckBox(string Text, int &amp;Checked) [ <i>statement</i> ]</tt>
</dl>
<b>Siehe auch</b> <a href=#350>dlgRadioButton</a>,
<a href=#343>dlgGroup</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgCheckBox</tt>-Statement definiert eine Checkbox mit dem angegebenen <tt>Text</tt>.
<p>
Wenn <tt>Text</tt> ein <tt>'&amp;'</tt> enth&auml;lt, wird das folgende Zeichen als Hotkey markiert.
Wenn der Benutzer <tt>Alt+hotkey</tt> dr&uuml;ckt, wird die Checkbox selektiert/deselektiert.
Um ein <tt>'&amp;'</tt>-Zeichen im Text zu verwenden, muss er mit einem <a href=#368>Escape-Zeichen</a> markiert werden.
<p>
<tt>dlgCheckBox</tt> wird haupts&auml;chlich in <a href=#343>dlgGroup</a> benutzt,
kann aber auch anders verwendet werden.<br>
Alle Check-Boxen innerhalb eines gemeinsamen Dialogs m&uuml;ssen <b>unterschiedliche</b> <tt>Checked</tt>-Variablen haben!
<p>
Wenn ein Benutzer eine <tt>dlgCheckBox</tt> w&auml;hlt, wird die entsprechende <tt>Checked</tt>-Variable auf
<tt>1</tt> gesetzt, andernfalls ist sie auf <tt>0</tt> gesetzt.
Der urspr&uuml;ngliche Wert von <tt>Checked</tt> definiert, ob eine Checkbox anf&auml;nglich selektiert ist oder nicht.
Wenn <tt>Checked</tt> ungleich <tt>0</tt> ist, ist die Checkbox defaultm&auml;&szlig;ig selektiert.
<p>
Das optionale <tt>statement</tt> wird jedesmal ausgef&uuml;hrt, wenn Sie die <tt>dlgCheckBox</tt> selektieren/deselektieren.
<h2>Beispiel</h2>
<pre>
int mirror = 0;
int rotate = 1;
int flip   = 0;
dlgGroup("Orientation") {
  dlgCheckBox("&amp;Mirror", mirror);
  dlgCheckBox("&amp;Rotate", rotate);
  dlgCheckBox("&amp;Flip", flip);
  }
</pre>


<a name=340>
<h1>dlgComboBox</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein Combo-Box-Auswahl-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgComboBox(string array[], int &amp;Selected) [ <i>statement</i> ]</tt>
</dl>
<b>Siehe auch</b> <a href=#347>dlgListBox</a>,
<a href=#346>dlgLabel</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgComboBox</tt>-Statement definiert ein Combo-Box-Auswahlfeld mit dem Inhalt von <tt>array</tt>.
<p>
<tt>Selected</tt> reflektiert den Index des selektieren Combo-Box-Eintrags. Der erste Eintrag hat den Index <tt>0</tt>.
<p>
Jedes Element von <tt>array</tt> legt den Inhalt eines Eintrags in der Combo-Box fest.
Keiner der Strings in <tt>array</tt> darf leer sein (sollte ein leerer String existieren,
werden alle folgenden, inklusive des leeren, ignoriert).
<p>
Das optionale <tt>statement</tt> wird jedesmal ausgef&uuml;hrt, wenn die Auswahl in der <tt>dlgComboBox</tt> ver&auml;ndert wird.<br>
Bevor <tt>statement</tt> ausgef&uuml;hrt wird, werden alle Variablen , die in den Dialog-Objekten verwendet werden
neu eingelesen und jede Ver&auml;nderung innerhalb von <tt>statement</tt> wird im Dialog angezeigt.
<p>
Ist der Ausgangswert von <tt>Selected</tt> ausserhalb des Bereichs der Indices von <tt>array</tt>,
wird dieser auf <tt>0</tt> gesetzt.
<h2>Beispiel</h2>
<pre>
string Colors[] = { "red", "green", "blue", "yellow" };
int Selected = 2; // initially selects "blue"
dlgComboBox(Colors, Selected) dlgMessageBox("You have selected " + Colors[Selected]);
</pre>


<a name=341>
<h1>dlgDialog</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
F&uuml;hrt einen User-Language-Dialog aus.
<dt>
<b>Syntax</b>
<dd>
<tt>int dlgDialog(string Title) <i>block</i> ;</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>dlgDialog</tt>-Funktion liefert einen Integer-Wert, dem durch den Aufruf der
<tt><a href=#363>dlgAccept()</a></tt>-Funktion eine benutzerspezifische
Bedeutung zugeordnet werden kann.<br>
Wird der Dialog einfach geschlossen, ist der R&uuml;ckgabewert <tt>-1</tt>.
</dl>
<b>Siehe auch</b> <a href=#342>dlgGridLayout</a>,
<a href=#344>dlgHBoxLayout</a>,
<a href=#360>dlgVBoxLayout</a>,
<a href=#363>dlgAccept</a>,
<a href=#365>dlgReset</a>,
<a href=#366>dlgReject</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Die <tt>dlgDialog</tt>-Funktion, die durch <tt><a href=#243>block</a></tt> definiert wird.
Das ist das einzige Dialog-Objekt das tats&auml;chlich eine User-Language-Builtin-Funktion ist.
Sie kann &uuml;berall wo ein Funktionsaufruf erlaubt ist, verwendet werden.
<p>
<tt>block</tt> enth&auml;lt normalerweise andere <a href=#337>Dialog-Objekte</a>.
Man kann aber auch andere User-Language-Statements verwenden, zum Beispiel, um bedingungsabh&auml;ngig
dem Dialog Objekte hinzuzuf&uuml;gen (siehe das zweite der folgenden Beispiele).
<p>
Standardm&auml;&szlig;ig enth&auml;lt <tt>dlgDialog</tt> ein <a href=#360>dlgVBoxLayout</a>,
so dass man sich bei einem einfachen Dialog um das Layout kein Gedanken machen muss.
<p>
Ein <tt>dlgDialog</tt> sollte an einer Stelle den Aufruf der <tt><a href=#363>dlgAccept()</a></tt>
-Funktion enthalten, um dem Benutzer zu erlauben, den Dialog zu schlie&szlig;en und dessen Inhalt zu akzeptieren.
<p>
Wenn Sie nur eine einfache Message-Box oder einen einfachen Dialog brauchen, k&ouml;nnen Sie statt dessen
auch einen der <a href=#333>Vordefinierten Dialoge</a> verwenden.
<h2>Beispiele</h2>
<pre>
int Result = dlgDialog("Hello") {
  dlgLabel("Hello world");
  dlgPushButton("+OK") dlgAccept();
  };
int haveButton = 1;
dlgDialog("Test") {
  dlgLabel("Start");
  if (haveButton)
     dlgPushButton("Here") dlgAccept();
  };
</pre>


<a name=342>
<h1>dlgGridLayout</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Grid-Layout-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgGridLayout <i>statement</i></tt>
</dl>
<b>Siehe auch</b> <a href=#338>dlgCell</a>,
<a href=#344>dlgHBoxLayout</a>,
<a href=#360>dlgVBoxLayout</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgGridLayout</tt>-Statement &ouml;ffnet einen Grid-Layout-Kontext.
<p>
Das einzige Dialog-Objekt, das direkt in <tt>statement</tt> verwendet werden kann, ist
<a href=#338>dlgCell</a>, das die Position eines Dialog-Objekts
im Grid-Layout festlegt.
<p>
Die Indices f&uuml;r row und column beginnen mit 0, so dass die obere linke Cell den
Index&nbsp;(0,&nbsp;0) hat.<br>
Die Anzahl der Reihen und Spalten wird automatisch an die Position von Dialog-Objekten,
die innerhalb des Grid-Layout-Kontexts definiert werden, angepasst. Die Anzahl der
Reihen und Spalten muss nicht explizit definiert werden.
<h2>Beispiel</h2>
<pre>
dlgGridLayout {
  dlgCell(0, 0) dlgLabel("Row 0/Col 0");
  dlgCell(1, 0) dlgLabel("Row 1/Col 0");
  dlgCell(0, 1) dlgLabel("Row 0/Col 1");
  dlgCell(1, 1) dlgLabel("Row 1/Col 1");
  }
</pre>


<a name=343>
<h1>dlgGroup</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein Group-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgGroup(string Title) <i>statement</i></tt>
</dl>
<b>Siehe auch</b> <a href=#339>dlgCheckBox</a>,
<a href=#350>dlgRadioButton</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgGroup</tt>-Statement definiert eine Gruppe mit dem gegebenen <tt>Title</tt>.
<p>
Standardm&auml;&szlig;ig enth&auml;lt <tt>dlgGroup</tt> ein <a href=#360>dlgVBoxLayout</a>,
so braucht man sich bei einer einfachen Group keine Gedanken zum Layout machen.
<p>
<tt>dlgGroup</tt> wird haupts&auml;chlich f&uuml;r einen Satz von <a href=#350>Radio-Buttons</a>
oder <a href=#339>Check-Boxes</a> verwendet, kann aber auch jedes andere beliebige
Objekt in <tt>statement</tt> enthalten.<br>
Radio-Buttons in einer <tt>dlgGroup</tt> werden mit <tt>0</tt> beginnend numeriert.
<h2>Beispiel</h2>
<pre>
int align = 1;
dlgGroup("Alignment") {
  dlgRadioButton("&amp;Top", align);
  dlgRadioButton("&amp;Center", align);
  dlgRadioButton("&amp;Bottom", align);
  }
</pre>


<a name=344>
<h1>dlgHBoxLayout</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Horizontal-Box-Layout-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgHBoxLayout <i>statement</i></tt>
</dl>
<b>Siehe auch</b> <a href=#342>dlgGridLayout</a>,
<a href=#360>dlgVBoxLayout</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndige Beispiel</a>
<p>
Das <tt>dlgHBoxLayout</tt>-Statement &ouml;ffnet einen Horizontal-Box-Layout-Kontext f&uuml;r das
angegebene <tt>statement</tt>.
<h2>Beispiel</h2>
<pre>
dlgHBoxLayout {
  dlgLabel("Box 1");
  dlgLabel("Box 2");
  dlgLabel("Box 3");
  }
</pre>


<a name=345>
<h1>dlgIntEdit</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein Integer-Eingabe-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgIntEdit(int &amp;Value, int Min, int Max)</tt>
</dl>
<b>Siehe auch</b> <a href=#351>dlgRealEdit</a>,
<a href=#355>dlgStringEdit</a>,
<a href=#346>dlgLabel</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgIntEdit</tt>-Statement definiert ein Integer-Eingabe-Feld mit einem in <tt>Value</tt>
angegebenen Wert.
<p>
Ist <tt>Value</tt> urspr&uuml;nglich ausserhalb des Bereichs <tt>Min</tt> und <tt>Max</tt>,
wird er auf diesen Bereich limitiert.
<h2>Beispiel</h2>
<pre>
int Value = 42;
dlgHBoxLayout {
  dlgLabel("Enter a &amp;Number between 0 and 99");
  dlgIntEdit(Value, 0, 99);
  }
</pre>


<a name=346>
<h1>dlgLabel</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein Text-Label.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgLabel(string Text [, int Update])</tt>
</dl>
<b>Siehe auch</b> <a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>,
<a href=#364>dlgRedisplay()</a>
<p>
Das <tt>dlgLabel</tt>-Statement definiert ein Label mit dem angegebenen <tt>Text</tt>.
<p>
<tt>Text</tt> kann entweder ein fester String wie <tt>"Hello"</tt> sein, oder eine String-Variable.
<p>
Falls <tt>Text</tt> HTML-Tags enth&auml;lt, so m&uuml;ssen die Zeichen '&lt;', '&gt;' und '&amp;',
damit sie als solche angezeigt werden, als "&amp;lt;", "&amp;gt;" bzw. "&amp;amp;" angegeben
werden.
<p>
Externe Hyperlinks im <tt>Text</tt> werden mit dem entsprechenden
Anwendungsprogramm ge&ouml;ffnet.
<p>
Wenn der <tt>Update</tt>-Parameter nicht <tt>0</tt> ist und <tt>Text</tt> eine String-Variable,
kann deren Inhalt im <tt>statement</tt> z. B. eines <a href=#349>dlgPushButton</a> modifiziert werden,
wodurch das Label automatisch aktualisiert wird. Das ist nat&uuml;rlich nur sinnvoll wenn <tt>Text</tt> eine
eindeutig bestimmte String-Variable ist (und beispielsweise keine Loop-Variable eines <tt>for</tt>-Statements).
<p>
Enth&auml;lt <tt>Text</tt> ein <tt>'&amp;'</tt>-Zeichen, und kann das Objekt, das auf das Label
folgt, den Keyboard-Fokus bekommen, wird das folgende Zeichen zum Hot-Key.
Dr&uuml;ckt der Benutzer <tt>Alt+hotkey</tt>, wird das Objekt, das direkt nach <tt>dlgLabel</tt> definiert
wurde, aktiv.
Um ein <tt>'&amp;'</tt>-Zeichen direkt im Text zu verwenden, muss man es mit einem
<a href=#368>Escape-Zeichen</a> markieren.
<h2>Beispiel</h2>
<pre>
string OS = "Windows";
dlgHBoxLayout {
  dlgLabel(OS, 1);
  dlgPushButton("&amp;Change OS") { OS = "Linux"; }
  }
</pre>


<a name=347>
<h1>dlgListBox</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein List-Box-Auswahl-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgListBox(string array[], int &amp;Selected) [ <i>statement</i> ]</tt>
</dl>
<b>Siehe auch</b> <a href=#340>dlgComboBox</a>,
<a href=#348>dlgListView</a>,
<a href=#367>dlgSelectionChanged</a>,
<a href=#346>dlgLabel</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgListBox</tt>-Statement definiert ein List-Box-Auswahl-Feld mit dem Inhalt
von <tt>array</tt>.
<p>
<tt>Selected</tt> gibt den Index des selektierten List-Box-Eintrags wieder.
Der erste Eintrag hat den Index <tt>0</tt>.
<p>
Jedes Element von <tt>array</tt> legt den Inhalt einer Zeile in der List-Box fest.
Keiner der Strings in <tt>array</tt> darf leer sein (sollte ein leerer String existieren,
werden alle folgenden, inklusive des leeren, ignoriert).
<p>
Das optionale <tt>statement</tt> wird immer dann ausgef&uuml;hrt, wenn der Benutzer einen Doppelklick
auf einen Eintrag der <tt>dlgListBox</tt> ausf&uuml;hrt (siehe <a href=#367>dlgSelectionChanged</a>
f&uuml;r Hinweise wie das <tt>statement</tt> auch bei einer blo&szlig;en &Auml;nderung der Auswahl in der
Liste aufgerufen werden kann.<br>
Bevor <tt>statement</tt> ausgef&uuml;hrt wird, werden alle Variablen, die von Dialog-Objekten benutzt
werden, aktualisiert. Alle &Auml;nderungen, die in <tt>statement</tt> gemacht wurden, wirken sich auf
den Dialog aus, sobald das Statement zur&uuml;ckgegeben wird.
<p>
Ist der Ausgangswert von <tt>Selected</tt> ausserhalb des Index-Bereichs von <tt>array</tt>,
wird kein Eintrag selektiert.
<h2>Beispiel</h2>
<pre>
string Colors[] = { "red", "green", "blue", "yellow" };
int Selected = 2; // initially selects "blue"
dlgListBox(Colors, Selected) dlgMessageBox("You have selected " + Colors[Selected]);
</pre>


<a name=348>
<h1>dlgListView</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein mehrspaltiges List-View-Auswahl-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgListView(string Headers, string array[], int &amp;Selected[, int &amp;Sort]) [ <i>statement</i> ]</tt>
</dl>
<b>Siehe auch </b> <a href=#347>dlgListBox</a>,
<a href=#367>dlgSelectionChanged</a>,
<a href=#346>dlgLabel</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgListView</tt>-Statement definiert ein mehrspaltiges List-View-Auswahl-Feld mit dem Inhalt,
der in <tt>array</tt> angegeben ist.
<p>
<tt>Headers</tt> definiert die durch Tabulatoren getrennte Liste der Spalten-&Uuml;berschriften.
<p>
<tt>Selected</tt> gibt den Index des selektierten List-View-Eintrags von <tt>array</tt> wieder
(die Reihenfolge in der die Eintr&auml;ge tats&auml;chlich angezeigt werden, kann unterschiedlich sein,
da der Inhalt einer <tt>dlgListView</tt> in den verschiedenen Spalten sortiert werden kann).
Der erste Eintrag hat den Index <tt>0</tt>.<br>
Wenn kein spezieller Eintrag selektiert werden soll, w&auml;hlt man f&uuml;r <tt>Selected</tt> den
Wert <tt>-1</tt>.
Wird der Wert auf <tt>-2</tt> gesetzt, so wird der erste Eintrag
gem&auml;&szlig; der aktuellen Sortierspalte selektiert.
<p>
<tt>Sort</tt> gibt an, nach welcher Spalte der List-View sortiert werden soll. Die linke
Spalte hat die Nummer <tt>1</tt>. Das Vorzeichen dieses Parameters legt die Richtung der
Sortierung fest (positive Werte sortieren in aufsteigender Reihenfolge). Falls <tt>Sort</tt>
den Wert <tt>0</tt> hat, oder au&szlig;erhalb der g&uuml;ltigen Anzahl von Spalten liegt, wird nicht
sortiert. Der R&uuml;ckgabewert von <tt>Sort</tt> spiegelt die vom Benutzer durch Anklicken
der Spalten-Header gew&auml;hlte Sortierspalte und -richtung wieder. Standardm&auml;&szlig;ig wird
nach der ersten Spalte, in aufsteigender Richtung sortiert.
<p>
Jedes Element von <tt>array</tt> legt den Inhalt einer Zeile in der List-View fest und
muss durch Tabulatoren getrennte Werte enthalten. Sind weniger Werte eines Elements in
<tt>array</tt> definiert als im <tt>Headers</tt>-String vorgegeben, bleiben die restlichen
Felder leer. Sind mehr Werte eines Element in <tt>array</tt> angegeben als
im <tt>Headers</tt>-String, werden die &uuml;berz&auml;hlgen stillschweigend ignoriert.
Keiner der Strings in <tt>array</tt> darf leer sein (sollte ein leerer String
vorhanden sein, werden alle nachfolgenden, inklusive dem Leerstring ignoriert).
<p>
Enth&auml;lt ein Listeneintrag Zeilenumbr&uuml;che (<tt>'\n'</tt>), so wird er entsprechend
mehrzeilig dargestellt.
<p>
Das optionale <tt>statement</tt> wird ausgef&uuml;hrt, wann immer der Benutzer auf einen Eintrag
in <tt>dlgListView</tt> doppelklickt (siehe <a href=#367>dlgSelectionChanged</a>
f&uuml;r Hinweise wie das <tt>statement</tt> auch bei einer blo&szlig;en &Auml;nderung der Auswahl in der
Liste aufgerufen werden kann.<br>
Bevor <tt>statement</tt> ausgef&uuml;hrt wird, werden alle Variablen, die mit den Dialog-Objekten benutzt
wurden, aktualisiert. Alle &Auml;nderungen, die in <tt>statement</tt> gemacht wurden, wirken sich auf
den Dialog aus, sobald das Statement zur&uuml;ckgegeben wird.
<p>
Ist der Ausgangswert von <tt>Selected</tt> ausserhalb des Index-Bereichs von <tt>array</tt>,
wird kein Eintrag selektiert.
<p>
Ist <tt>Headers</tt> ein leerer String, wird das erste Element von <tt>array</tt> als
Header-String benutzt. Folglich ist der Index des ersten Eintrags dann <tt>1</tt>.
<p>
Der Inhalt von <tt>dlgListView</tt> kann in einer beliebigen Spalte sortiert werden, indem man
auf dessen Spalten-Header klickt. Die Spalten-Reihenfolge kann man durch Anklicken&amp;Ziehen
des Spalten-Headers ver&auml;ndern. Beachten Sie, dass keine dieser &Auml;nderunen eine Auswirkung
auf den Inhalt von <tt>array</tt> hat.
Soll der Inhalt alphanumerisch sortiert werden, kann ein <tt>numeric string[]</tt>-Array
verwendet werden.
<h2>Beispiel</h2>
<pre>
string Colors[] = { "red\tThe color RED", "green\tThe color GREEN", "blue\tThe color BLUE" };
int Selected = 0; // initially selects "red"
dlgListView("Name\tDescription", Colors, Selected) dlgMessageBox("You have selected " + Colors[Selected]);
</pre>


<a name=349>
<h1>dlgPushButton</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert einen Push-Button.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgPushButton(string Text) <i>statement</i></tt>
</dl>
<b>Siehe auch</b> <a href=#361>Layout-Information</a>,
<a href=#362>Dialog-Funktionen</a>,
<a href=#369>Ein vollst&auml;ndige Beispiel</a>
<p>
Das <tt>dlgPushButton</tt>-Statement definiert einen Push-Button mit dem angegebenen <tt>Text</tt>.
<p>
Enth&auml;lt <tt>Text</tt> ein <tt>'&amp;'</tt>-Zeichen, wird das folgende Zeichen zum Hot-Key. Wenn der
Benutzer dann <tt>Alt+hotkey</tt> dr&uuml;ckt, wird dieser Button selektiert.
Soll ein <tt>'&amp;'</tt>-Zeichen im Text verwendet werden, muss es mit einem
<a href=#368>Escape-Zeichen</a> markiert werden.
<p>
Beginnt <tt>Text</tt> mit einem <tt>'+'</tt>-Zeichen, wird dieser Button der Default-Button.
Dieser wird bet&auml;tigt, wenn der Benutzer ENTER dr&uuml;ckt.<br>
Wenn <tt>Text</tt> mit einem <tt>'-'</tt>-Zeichen beginnt, wird dieser Button der Cancel-Button.
Dieser wird gew&auml;hlt wenn der Benutzer den Dialog schlie&szlig;t.<br>
<b>Achtung: Stellen Sie sicher, dass das <tt>statement</tt> eines so markierten Buttons einen
Aufruf von <a href=#366>dlgReject()</a> enth&auml;lt! Ansonsten ist es dem Benutzer nicht
m&ouml;glich den Dialog &uuml;berhaupt zu schlie&szlig;en!</b><br>
Um ein <tt>'+'</tt> oder <tt>'-'</tt>-Zeichen als erstes Zeichen des Textes zu verwenden,
muss es mit einem <a href=#368>Escape-Zeichen</a> markiert werden.
<p>
Wenn der Benutzer einen <tt>dlgPushButton</tt> selektiert, wird das angegebene <tt>statement</tt>
ausgef&uuml;hrt.<br>
Bevor <tt>statement</tt> ausgef&uuml;hrt wird, werden alle Variablen, die mit den Dialog-Objekten
benutzt wurden, aktualisiert. Alle &Auml;nderungen, die in <tt>statement</tt> gemacht wurden, wirken sich
auf den Dialog aus, sobald das Statement zur&uuml;ckgegeben wird.
<h2>Beispiel</h2>
<pre>
int defaultWidth = 10;
int defaultHeight = 20;
int width = 5;
int height = 7;
dlgPushButton("&amp;Reset defaults") {
  width = defaultWidth;
  height = defaultHeight;
  }
dlgPushButton("+&amp;Accept") dlgAccept();
dlgPushButton("-Cancel") { if (dlgMessageBox("Are you sure?", "Yes", "No") == 0) dlgReject(); }
</pre>


<a name=350>
<h1>dlgRadioButton</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert einen Radio-Button.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgRadioButton(string Text, int &amp;Selected) [ <i>statement</i> ]</tt>
</dl>
<b>Siehe auch</b> <a href=#339>dlgCheckBox</a>,
<a href=#343>dlgGroup</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgRadioButton</tt>-Statement definiert einen Radio-Button mit dem angegebenen <tt>Text</tt>.
<p>
Enth&auml;lt <tt>Text</tt> ein <tt>'&amp;'</tt>-Zeichen, wird das folgende Zeichen zum Hot-Key. Wenn der
Benutzer dann <tt>Alt+hotkey</tt> dr&uuml;ckt, wird dieser Button selektiert.
Soll ein <tt>'&amp;'</tt>-Zeichen im Text verwendet werden, muss es mit einem
<a href=#368>Escape-Zeichen</a> markiert werden.
<p>
<tt>dlgRadioButton</tt> kann nur innerhalb einer <a href=#343>dlgGroup</a> verwendet werden.<br>
Alle Radio-Buttons innerhalb derselben Group m&uuml;ssen <b>dieselbe</b> <tt>Selected</tt>-Variable haben!
<p>
Wenn der Benutzer einen <tt>dlgRadioButton</tt> selektiert, wird der Index dieses Buttons innerhalb
der <tt>dlgGroup</tt> in der <tt>Selected</tt>-Variablen gespeichert.<br>
Der Ausgangswert von <tt>Selected</tt> definiert, welcher Radio-button per default selektiert ist.
Liegt <tt>Selected</tt> ausserhalb des g&uuml;ltigen Bereichs dieser Group, ist kein Radio-Button
selektiert.
Um die richtige Radio-Button-Selektion zu erhalten, muss <tt>Selected</tt> schon <b>vor</b>
der Definition des ersten <tt>dlgRadioButton</tt> festgelegt werden, und darf nicht ver&auml;ndert
werden, w&auml;hrend man weitere Radio-Buttons hinzuf&uuml;gt. Ansonsten ist es ungewiss welcher
Radio-Button (wenn &uuml;berhaupt einer) selektiert wird.
<p>
Das optionale <tt>statement</tt> wird ausgef&uuml;hrt, wenn ein <tt>dlgRadioButton</tt> selektiet wird.
<h2>Beispiel</h2>
<pre>
int align = 1;
dlgGroup("Alignment") {
  dlgRadioButton("&amp;Top", align);
  dlgRadioButton("&amp;Center", align);
  dlgRadioButton("&amp;Bottom", align);
  }
</pre>


<a name=351>
<h1>dlgRealEdit</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein Real-Eingabe-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgRealEdit(real &amp;Value, real Min, real Max)</tt>
</dl>
<b>Siehe auch</b> <a href=#345>dlgIntEdit</a>,
<a href=#355>dlgStringEdit</a>,
<a href=#346>dlgLabel</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgRealEdit</tt>-Statement definiert ein Real-Eingabe-Feld mit dem angegebenen <tt>Value</tt> (Wert).
<p>
Wenn <tt>Value</tt> urspr&uuml;nglich ausserhalb des Bereiches von <tt>Min</tt> und <tt>Max</tt> liegt,
wird dieser auf diese Werte begrenzt.
<h2>Beispiel</h2>
<pre>
real Value = 1.4142;
dlgHBoxLayout {
  dlgLabel("Enter a &amp;Number between 0 and 99");
  dlgRealEdit(Value, 0.0, 99.0);
  }
</pre>


<a name=352>
<h1>dlgSpacing</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert zus&auml;tzlichen Abstand in einem Box-Layout-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgSpacing(int Size)</tt>
</dl>
<b>Siehe auch</b> <a href=#344>dlgHBoxLayout</a>,
<a href=#360>dlgVBoxLayout</a>,
<a href=#354>dlgStretch</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgSpacing</tt>-Statement definiert zus&auml;tzlichen Abstand in einem Vertical- bzw.
Horizontal-Box-Layout-Kontext.
<p>
<tt>Size</tt> definiert die Anzahl der Pixel des zus&auml;tzlichen Abstands.
<h2>Beispiel</h2>
<pre>
dlgVBoxLayout {
  dlgLabel("Label 1");
  dlgSpacing(40);
  dlgLabel("Label 2");
  }
</pre>


<a name=353>
<h1>dlgSpinBox</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein Spin-Box-Auswahl-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgSpinBox(int &amp;Value, int Min, int Max)</tt>
</dl>
<b>Siehe auch</b> <a href=#345>dlgIntEdit</a>,
<a href=#346>dlgLabel</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgSpinBox</tt>-Statement definiert ein Spin-Box-Auswahl-Feld mit dem angegebenen <tt>Value</tt>.
<p>
Wenn <tt>Value</tt> urspr&uuml;nglich ausserhalb des Bereiches von <tt>Min</tt> und <tt>Max</tt> liegt,
wird dieser auf diese Werte begrenzt.
<h2>Beispiel</h2>
<pre>
int Value = 42;
dlgHBoxLayout {
  dlgLabel("&amp;Select value");
  dlgSpinBox(Value, 0, 99);
  }
</pre>


<a name=354>
<h1>dlgStretch</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert einen leeren, dehnbaren Abstand in einem Box-Layout-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgStretch(int Factor)</tt>
</dl>
<b>Siehe auch</b> <a href=#344>dlgHBoxLayout</a>,
<a href=#360>dlgVBoxLayout</a>,
<a href=#352>dlgSpacing</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgStretch</tt>-Statement definiert einen leeren dehnbaren Abstand in einem Vertical-
oder einem Horizontal-Box-Layout-Kontext.
<p>
<tt>Factor</tt> definiert den Dehnungsfaktor des Abstands.
<h2>Beispiel</h2>
<pre>
dlgHBoxLayout {
  dlgStretch(1);
  dlgPushButton("+OK")    { dlgAccept(); };
  dlgPushButton("Cancel") { dlgReject(); };
  }
</pre>


<a name=355>
<h1>dlgStringEdit</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein String-Eingabe-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgStringEdit(string &amp;Text[, string &amp;History[][, int Size]])</tt>
</dl>
<b>Siehe auch</b> <a href=#351>dlgRealEdit</a>,
<a href=#345>dlgIntEdit</a>,
<a href=#358>dlgTextEdit</a>,
<a href=#346>dlgLabel</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgStringEdit</tt>-Statement definiert ein einzeiliges Text-Eingabe-Feld mit dem angegebenen <tt>Text</tt>.
<p>
Wird <tt>History</tt> angegeben, so werden die Strings, die der Benutzer der
Reihe nach eingibt, in diesem Array gespeichert. Das Eingabe-Feld enth&auml;lt dann
einen Button, &uuml;ber den der Benutzer aus bereits eingegeben Strings ausw&auml;hlen kann.
Wird eine <tt>Size</tt> gr&ouml;&szlig;er als Null angegeben, so werden maximal so viele
Strings im Array gespeichert.  Enth&auml;lt <tt>History</tt> beim &Ouml;ffnen des Dialogs
bereits Daten, so werden diese zur Initialisierung der History verwendet. Die zuletzt
erfolgte Benutzereingabe wird bei Index 0 gespeichert.<br>
Keiner der Strings in <tt>History</tt> darf leer sein (sollte ein leerer String
vorhanden sein, werden alle nachfolgenden, inklusive dem Leerstring ignoriert).
<h2>Beispiel</h2>
<pre>
string Name = "Linus";
dlgHBoxLayout {
  dlgLabel("Enter &amp;Name");
  dlgStringEdit(Name);
  }
</pre>


<a name=356>
<h1>dlgTabPage</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert eine Tab-Page.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgTabPage(string Title) <i>statement</i></tt>
</dl>
<b>Siehe auch</b> <a href=#357>dlgTabWidget</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgTabPage</tt>-Statement definiert eine Tab-Page mit dem angegebenen <tt>Title</tt>, die
<tt>statement</tt> enth&auml;lt.
<p>
Enth&auml;lt <tt>Title</tt> ein <tt>'&amp;'</tt>-Zeichen, wird das folgende Zeichen zum Hot-Key.
Dr&uuml;ckt der Benutzer <tt>Alt+hotkey</tt>, wird diese Tab-Page ge&ouml;ffnet.
Soll im Text ein <tt>'&amp;'</tt>-Zeichen verwendet werden, muss es mit einem
<a href=#368>Escape-Zeichen</a> markiert werden.
<p>
Tab-Pages k&ouml;nnen nur innerhalb eines <a href=#357>dlgTabWidget</a> verwendet werden.
<p>
Standardm&auml;&szlig;ig enth&auml;lt <tt>dlgTabPage</tt> ein <a href=#360>dlgVBoxLayout</a>,
so dass man sich bei einer einfachen Tab-Page nicht um das Layout k&uuml;mmern muss.
<h2>Beispiel</h2>
<pre>
dlgTabWidget {
  dlgTabPage("Tab &amp;1") {
    dlgLabel("This is page 1");
    }
  dlgTabPage("Tab &amp;2") {
    dlgLabel("This is page 2");
    }
  }
</pre>


<a name=357>
<h1>dlgTabWidget</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert einen Container f&uuml;r Tab-Pages.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgTabWidget <i>statement</i></tt>
</dl>
<b>Siehe auch</b> <a href=#356>dlgTabPage</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgTabWidget</tt>-Statement definiert einen Platzhalter f&uuml;r einen Satz von Tab-Pages.
<p>
<tt>statement</tt> ist eine Liste eines oder mehrerer <a href=#356>dlgTabPage</a>-Objekte.
Es d&uuml;rfen keine anderen Dialog-Objekte in dieser Liste enthalten sein.
<h2>Beispiel</h2>
<pre>
dlgTabWidget {
  dlgTabPage("Tab &amp;1") {
    dlgLabel("This is page 1");
    }
  dlgTabPage("Tab &amp;2") {
    dlgLabel("This is page 2");
    }
  }
</pre>


<a name=358>
<h1>dlgTextEdit</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein mehrzeiliges Text-Eingabe-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgTextEdit(string &amp;Text)</tt>
</dl>
<b>Siehe auch</b> <a href=#355>dlgStringEdit</a>,
<a href=#359>dlgTextView</a>,
<a href=#346>dlgLabel</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgTextEdit</tt>-Statement definiert ein mehrzeiliges text-Eingabe-Feld mit dem angegebenen <tt>Text</tt>.
<p>
Die einzelnen Zeilen in <tt>Text</tt> m&uuml;ssen mit einem Newline-Zeichen (<tt>'\n'</tt>) getrennt werden.
Beliebige Leerzeichen am Ende der <tt>Text</tt>-Zeilen werden gel&ouml;scht.
Leere Zeilen am Endes des Textes werden vollst&auml;ndig entfernt.
<h2>Beispiel</h2>
<pre>
string Text = "This is some text.\nLine 2\nLine 3";
dlgVBoxLayout {
  dlgLabel("&amp;Edit the text");
  dlgTextEdit(Text);
  }
</pre>


<a name=359>
<h1>dlgTextView</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Definiert ein mehrzeiliges Text-Viewer-Feld.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgTextView(string Text)</tt><br>
<tt>dlgTextView(string Text, string &amp;Link) <i>statement</i></tt>
</dl>
<b>Siehe auch</b> <a href=#358>dlgTextEdit</a>,
<a href=#346>dlgLabel</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgTextView</tt>-Statement definiert ein mehrzeiliges Text-Viewer-Feld mit dem angegebenen <tt>Text</tt>.
<p>
Der <tt>Text</tt> darf <a href=#370>HTML</a>-Tags enthalten.
<p>
Externe Hyperlinks im <tt>Text</tt> werden mit dem entsprechenden
Anwendungsprogramm ge&ouml;ffnet.
<p>
Falls <tt>Link</tt> angegeben wird und der <tt>Text</tt> Hyperlinks enth&auml;lt, wird <tt>statement</tt>
ausgef&uuml;hrt wenn der Benutzer auf einen Hyperlink klickt, wobei der Wert von <tt>Link</tt>
auf das gesetzt wird, was im <tt>&lt;a href=...&gt;</tt>-Tag als Wert f&uuml;r <i>href</i> angegeben wurde.
Ist die <tt>Link</tt>-Variable nach der Ausf&uuml;hrung von <tt>statement</tt> nicht leer, so
findet die standardm&auml;&szlig;ige Behandlung von Hyperlinks statt. Dies ist auch der Fall, wenn
<tt>Link</tt> vor dem &Ouml;ffnen von dlgTextView bereits Text enth&auml;lt, was es erm&ouml;glicht,
zu Beginn an eine vorgegebene Textstelle zu positionieren.
Ist ein <tt>Link</tt> angegeben, so werden externe Hyperlinks nicht ge&ouml;ffnet.
<h2>Beispiel</h2>
<pre>
string Text = "This is some text.\nLine 2\nLine 3";
dlgVBoxLayout {
  dlgLabel("&amp;View the text");
  dlgTextView(Text);
  }
</pre>


<a name=360>
<h1>dlgVBoxLayout</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
&Ouml;ffnet einen Vertical-Box-Layout-Kontext.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgVBoxLayout <i>statement</i></tt>
</dl>
<b>Siehe auch</b> <a href=#342>dlgGridLayout</a>,
<a href=#344>dlgHBoxLayout</a>,
<a href=#361>Layout-Information</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Das <tt>dlgVBoxLayout</tt>-Statement &ouml;ffnet einen Vertical-Box-Layout-Kontext f&uuml;r das angegebene
<tt>statement</tt>.
<p>
Standardm&auml;&szlig;ig enth&auml;lt <a href=#341>dlgDialog</a> ein <tt>dlgVBoxLayout</tt>,
so dass man sich bei einfachen Dialogen keine Gedanken zum Layout machen muss.
<h2>Beispiel</h2>
<pre>
dlgVBoxLayout {
  dlgLabel("Box 1");
  dlgLabel("Box 2");
  dlgLabel("Box 3");
  }
</pre>


<a name=361>
<h1>Layout-Information</h1>
Alle Objekte eines User-Language-Dialogs werden in einem <i>Layout-Kontext</i> verwendet.
<p>
Es gibt verschiedene Layout-Kontexte, wie <a href=#342>grid</a>, <a href=#344>horizontal</a>
oder <a href=#360>vertical</a>.
<h2>Grid-Layout-Kontext</h2>
Objekte in einem Grid-Layout-Kontext m&uuml;ssen die Raster-Koordinaten der Zelle (Cell) oder der Zellen angeben,
in der/denen sie plaziert werden sollen. Um einen Text in Reihe (row) 5, Spalte (column) 2 zu plazieren,
schreiben Sie
<pre>
dlgGridLayout {
  dlgCell(5, 2) dlgLabel("Text");
  }
</pre>
Soll das Objekt &uuml;ber mehr als eine Zelle gehen, m&uuml;ssen Sie die Koordinaten der Start-Zelle und
der End-Zelle angeben. Um eine Group zu plazieren, die sich von Reihe 1, Spalte 2 &uuml;ber Reihe 3,
Spalte 5 erstreckt, schreiben Sie
<pre>
dlgGridLayout {
  dlgCell(1, 2, 3, 5) dlgGroup("Title") {
    //...
    }
  }
</pre>
<h2>Horizontal-Layout-Kontext</h2>
Objekte in einem Horizontal-Layout-Kontext werden von links nach rechts plaziert.
<p>
Die Sonder-Objekte <a href=#354>dlgStretch</a> und <a href=#352>dlgSpacing</a>
k&ouml;nnen verwendet werden, um die Verteilung der Abst&auml;nde zu verfeinern.
<p>
Um zwei Buttons zu definieren, die sich bis an den rechten Rand des Dialogs erstrecken, schreiben Sie
<pre>
dlgHBoxLayout {
  dlgStretch(1);
  dlgPushButton("+OK")    dlgAccept();
  dlgPushButton("Cancel") dlgReject();
  }
</pre>
<h2>Vertical-Layout-Kontext</h2>
Objekte in einem Vertical-Layout-Kontext folgen denselben Vorschriften wie die in einem
Horizontal-Layout-Kontext mit dem Unterschied, dass sie von oben nach unten angeordnet werden.
<h2>Gemischter Layout-Kontext</h2>
Vertical-, Horizontal- und Grid-Layout-Kontexte k&ouml;nnen gemischt werden, um die gew&uuml;nschte
Dialog-Struktur zu ezeugen.
Siehe <a href=#369>Ein vollst&auml;ndiges Beispiel</a>.


<a name=362>
<h1>Dialog-Funktionen</h1>
Folgende Funktionen k&ouml;nnen mit User-Language-Dialogen verwendet werden:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#363>dlgAccept()</a>  </td><td width=20><td>schlie&szlig;t den Dialog und akzeptiert dessen Inhalt</td></tr>
<tr><td><a href=#364>dlgRedisplay()</a>  </td><td width=20><td>aktualisiert den Dialog nachdem beliebige Werte ver&auml;ndert wurden</td></tr>
<tr><td><a href=#365>dlgReset()</a>  </td><td width=20><td>setzt alle Dialog-Objekte auf den Ursprungswert zur&uuml;ck</td></tr>
<tr><td><a href=#366>dlgReject()</a>  </td><td width=20><td>schlie&szlig;t den Dialog und verwirft dessen Inhalt</td></tr>
<tr><td><a href=#367>dlgSelectionChanged()</a>  </td><td width=20><td>gibt an ob sich die aktuelle Auswahl in einer dlgListView oder dlgListBox ge&auml;ndert hat</td></tr>
</table>


<a name=363>
<h1>dlgAccept()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Schlie&szlig;t den Dialog und akzeptiert dessen Inhalt.
<dt>
<b>Syntax</b>
<dd>
<tt>void dlgAccept([ <i>int Result</i> ]);</tt>
</dl>
<b>Siehe auch</b> <a href=#366>dlgReject</a>,
<a href=#341>dlgDialog</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Die <tt>dlgAccept</tt>-Funktion schlie&szlig;t <a href=#341>dlgDialog</a>,
und kehrt zur&uuml;ck nachdem das aktuelle Statement beendet wurde.
<p>
Jede &Auml;nderung, die der Benutzer im Dialog macht, wird &uuml;bernommen und an die Variablen,
die bei der Definition der <a href=#337>Dialog-Objekte</a> angegeben
wurden, kopiert.
<p>
Die optionale Angabe von <tt>Result</tt> ist der Wert der vom Dialog geliefert wird.
Das sollte typischerweise ein positiver Integer-Wert sein.
Wird kein Wert angegeben, ist der Standardwert gleich <tt>1</tt>.
<p>
Bitte beachten Sie, dass <tt>dlgAccept()</tt> wieder in die normale Programm-
Routine zur&uuml;ckkehrt, so wie in dieser Sequenz:
<pre>
dlgPushButton("OK") {
  dlgAccept();
  dlgMessageBox("Accepting!");
  }
</pre>
Das Statement nach <tt>dlgAccept()</tt> wird noch ausgef&uuml;hrt!
<h2>Beispiel</h2>
<pre>
int Result = dlgDialog("Test") {
               dlgPushButton("+OK")    dlgAccept(42);
               dlgPushButton("Cancel") dlgReject();
               };
</pre>


<a name=364>
<h1>dlgRedisplay()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Aktualisiert den Dialog-Inhalt nachdem Werte ver&auml;ndert wurden.
<dt>
<b>Syntax</b>
<dd>
<tt>void dlgRedisplay(void);</tt>
</dl>
<b>Siehe auch</b> <a href=#365>dlgReset</a>,
<a href=#341>dlgDialog</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Die <tt>dlgRedisplay</tt>-Funktion wird aufgerufen, um den <a href=#341>dlgDialog</a>,
nach dem Ver&auml;ndern von Variablen, die in den <a href=#337>Dialog-Objekten</a>
definiert wurden, zu aktualisieren.
<p>
Sie brauchen nur <tt>dlgRedisplay()</tt> aufrufen, wenn der Dialog w&auml;hrend der Ausf&uuml;hrung
des Programmcodes aktualisiert werden soll.
Im folgenden Beispiel wird der Status auf "Running..." gesetzt und <tt>dlgRedisplay()</tt>
muss aufgerufen werden, um die &Auml;nderungen f&uuml;r die Ausf&uuml;hrung des Programms wirksam
zu machen. Nach dem &Auml;ndern des Status auf "Finished.", braucht man <tt>dlgRedisplay()</tt>
nicht mehr aufrufen, da alle Dialog-Objekte nach dem Verlassen des Statements aktualisiert
werden.
<h2>Beispiel</h2>
<pre>
string Status = "Idle";
int Result = dlgDialog("Test") {
               dlgLabel(Status, 1); // note the '1' to tell the label to be updated!
               dlgPushButton("+OK")    dlgAccept(42);
               dlgPushButton("Cancel") dlgReject();
               dlgPushButton("Run") {
                 Status = "Running...";
                 dlgRedisplay();
                 // some program action here...
                 Status = "Finished.";
                 }
               };
</pre>


<a name=365>
<h1>dlgReset()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Setzt alle Dialog-Objekte auf ihren urspr&uuml;nglichen Wert.
<dt>
<b>Syntax</b>
<dd>
<tt>void dlgReset(void);</tt>
</dl>
<b>Siehe auch</b> <a href=#366>dlgReject</a>,
<a href=#341>dlgDialog</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Die <tt>dlgReset</tt>-Funktion kopiert die urspr&uuml;nglichen Werte in alle
<a href=#337>Dialog-Objekte</a> des aktuellen
<a href=#341>dlgDialog</a> zur&uuml;ck.
<p>
Alle &Auml;nderungen, die der Benutzer im Dialog machte, werden verworfen.
<p>
Ein Aufruf von <a href=#366><tt>dlgReject()</tt></a> impliziert einen
Aufruf von <tt>dlgReset()</tt>.
<h2>Beispiel</h2>
<pre>
int Number = 1;
int Result = dlgDialog("Test") {
               dlgIntEdit(Number);
               dlgPushButton("+OK")    dlgAccept(42);
               dlgPushButton("Cancel") dlgReject();
               dlgPushButton("Reset")  dlgReset();
               };
</pre>


<a name=366>
<h1>dlgReject()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Schlie&szlig;t den Dialog und verwirft seinen Inhalt.
<dt>
<b>Syntax</b>
<dd>
<tt>void dlgReject([ <i>int Result</i> ]);</tt>
</dl>
<b>Siehe auch</b> <a href=#363>dlgAccept</a>,
<a href=#365>dlgReset</a>,
<a href=#341>dlgDialog</a>,
<a href=#369>Ein vollst&auml;ndiges Beispiel</a>
<p>
Die <tt>dlgReject</tt>-Funktion veranlasst, dass <a href=#341>dlgDialog</a>
geschlossen wird und nach dem Beenden der aktuellen Statement-Sequenz zur&uuml;ckkehrt.
<p>
Jede &Auml;nderung, die der Benutzer im Dialog machte, wird verworfen.
Die Variablen, die w&auml;hrend der Definition der <a href=#337>Dialog-Objekte</a>
&uuml;bergeben wurden, werden auf Ihren urspr&uuml;nglichen Wert zur&uuml;ckgesetzt.
<p>
Der optionale Wert f&uuml;r <tt>Result</tt> wird vom Dialog zur&uuml;ckgegeben.
Typischerweise ist das <tt>0</tt> oder ein negativer Integer-Wert.
Wird kein Wert angegeben, ist er standardm&auml;&szlig;ig <tt>0</tt>.
<p>
Beachten Sie, dass <tt>dlgReject()</tt> wieder in die normale Programm-Routine zur&uuml;ckkehrt,
wie in dieser Sequenz:
<pre>
dlgPushButton("Cancel") {
  dlgReject();
  dlgMessageBox("Rejecting!");
  }
</pre>
Das Statement nach <tt>dlgReject()</tt> wird auch noch ausgef&uuml;hrt!
<p>
Der Aufruf von <tt>dlgReject()</tt> impliziert den Aufruf von <a href=#365><tt>dlgReset()</tt></a>.
<h2>Beispiel</h2>
<pre>
int Result = dlgDialog("Test") {
               dlgPushButton("+OK")    dlgAccept(42);
               dlgPushButton("Cancel") dlgReject();
               };
</pre>


<a name=367>
<h1>dlgSelectionChanged()</h1>
<dl>
<dt>
<b>Funktion</b>
<dd>
Gibt an ob sich die aktuelle Auswahl in einer dlgListView oder dlgListBox ge&auml;ndert hat.
<dt>
<b>Syntax</b>
<dd>
<tt>int dlgSelectionChanged(void);</tt>
<dt>
<b>R&uuml;ckgabewert</b>
<dd>
Die <tt>dlgSelectionChanged</tt>-Funktion liefert einen Wert ungleich 0, falls sich lediglich
die Auswahl in der Liste ge&auml;ndert hat.
</dl>
<b>Siehe auch</b> <a href=#348>dlgListView</a>,
<a href=#347>dlgListBox</a>
<p>
Die <tt>dlgSelectionChanged</tt>-Funktion kann innerhalb eines Listen-Kontextes verwendet
werden um festzustellen, ob das "statement" einer <tt>dlgListView</tt> oder <tt>dlgListBox</tt>
aufgerufen wurde weil der Benutzer einen Doppelklick auf ein Listenelement gemacht hat,
oder weil sich lediglich die Auswahl in der Liste ge&auml;ndert hat.
<p>
Falls das "statement" einer <tt>dlgListView</tt> oder <tt>dlgListBox</tt> keinen
Aufruf von <tt>dlgSelectionChanged</tt> enth&auml;lt, so wird das "statement" nur dann
ausgef&uuml;hrt, wenn der Benutzer einen Doppelklick auf ein Listenelement macht.
Soll ein ULP auf blo&szlig;e &Auml;nderungen der Auswahl in der Liste reagieren, so kann es
<tt>dlgSelectionChanged</tt> im "statement" der Liste aufrufen. Hierdurch wird
erreicht, dass das "statement" auch bei einer &Auml;nderungen der Auswahl in der Liste
ausgef&uuml;hrt wird.
<p>
Ist beim &Ouml;ffnen des Dialogs bereits ein Listenelement ausgew&auml;hlt, und das "statement"
der Liste enth&auml;lt einen Aufruf von <tt>dlgSelectionChanged</tt>, so wird das
"statement" ausgef&uuml;hrt und <tt>dlgSelectionChanged</tt> liefert einen Wert ungleich 0,
um den anf&auml;nglichen Wechsel von "keine Auswahl" zu einer konkreten Auswahl anzuzeigen.
Etwaige sp&auml;tere programmtechnische Ver&auml;nderungen der Strings oder der Auswahl der Liste
f&uuml;hren nicht zu einer automatischen Ausf&uuml;hrung des "statements" der Liste. Dies
ist wichtig zu bedenken, falls das ausgew&auml;hlte Listenelement ein anderes Dialogobjekt
steuert, beispielsweise ein <tt>dlgTextView</tt>, welches eine ausf&uuml;hrlichere
Darstellung des ausgew&auml;hlten Listenelements anzeigt.
<h2>Beispiel</h2>
<pre>
string Colors[] = { "red\tThe color RED", "green\tThe color GREEN", "blue\tThe color BLUE" };
int Selected = 0; // initially selects "red"
string MyColor;
dlgLabel(MyColor, 1);
dlgListView("Name\tDescription", Colors, Selected) {
  if (dlgSelectionChanged())
     MyColor = Colors[Selected];
  else
     dlgMessageBox("You have chosen " + Colors[Selected]);
  }
</pre>


<a name=368>
<h1>Escape-Zeichen</h1>
Einige Zeichen haben in Schaltfl&auml;chen-
oder Label-Texten eine besondere Bedeutung, so dass sie mit <i>Escape-Zeichen</i>
markiert werden m&uuml;ssen, wenn sie tats&auml;chlich im Text erscheinen sollen.
<p>
Dazu m&uuml;ssen Sie dem Zeichen einen <i>Backslash</i> voranstellen, so wie in
<pre>
dlgLabel("Miller \\&amp; Co.");
</pre>
Das Ergebnis wird im Dialog so aussehen: "Miller &amp; Co."
<p>
Beachten Sie, dass hier in Wirklichkeit <b>zwei</b> Backslash-Zeichen verwendet wurden,
da diese Zeile erst durch den User-Language-Parser geht, der den ersten Backslash
abzieht.


<a name=369>
<h1>Ein vollst&auml;ndiges Beispiel</h1>
Hier folgt ein vollst&auml;ndiges Beispiel eines User-Language-Dialogs:
<pre>
int hor = 1;
int ver = 1;
string fileName;
int Result = dlgDialog("Enter Parameters") {
  dlgHBoxLayout {
    dlgStretch(1);
    dlgLabel("This is a simple dialog");
    dlgStretch(1);
    }
  dlgHBoxLayout {
    dlgGroup("Horizontal") {
      dlgRadioButton("&amp;Top", hor);
      dlgRadioButton("&amp;Center", hor);
      dlgRadioButton("&amp;Bottom", hor);
      }
    dlgGroup("Vertical") {
      dlgRadioButton("&amp;Left", ver);
      dlgRadioButton("C&amp;enter", ver);
      dlgRadioButton("&amp;Right", ver);
      }
    }
  dlgHBoxLayout {
    dlgLabel("File &amp;name:");
    dlgStringEdit(fileName);
    dlgPushButton("Bro&amp;wse") {
      fileName = dlgFileOpen("Select a file", fileName);
      }
    }
  dlgGridLayout {
    dlgCell(0, 0) dlgLabel("Row 0/Col 0");
    dlgCell(1, 0) dlgLabel("Row 1/Col 0");
    dlgCell(0, 1) dlgLabel("Row 0/Col 1");
    dlgCell(1, 1) dlgLabel("Row 1/Col 1");
    }
  dlgSpacing(10);
  dlgHBoxLayout {
    dlgStretch(1);
    dlgPushButton("+OK")    dlgAccept();
    dlgPushButton("Cancel") dlgReject();
    }
  };
</pre>


<a name=370>
<h1>Unterst&uuml;tzte HTML-Tags</h1>
EAGLE unterst&uuml;tzt eine Teilmenge von Tags (Steuerzeichen), die zum Formatieren von HTML-Seiten
verwendet werden.
Damit kann man Texte von einigen Objekten im <a href=#332>User-Language-Dialog</a>,
in der <tt><a href=#153>#usage</a></tt>-Directive oder in der <a href=#45>Description</a>
von Bibliotheks-Objekten formatieren.
<p>
Text wird zu HTML-Text, wenn die erste Zeile ein Tag enth&auml;lt.
Wenn das nicht der Fall ist und Sie den Text formatieren wollen,
schlie&szlig;en Sie den ganzen Text in das <tt>&lt;html&gt;...&lt;/html&gt;</tt> Tag ein.
<p>
Die folgende Tabelle listet alle unterst&uuml;tzten HTML-Tags mit ihren verf&uuml;gbaren Attributen auf:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Tag</b></td><td width=20><td><b>Beschreibung</b></td></tr>
<tr><td>&lt;html&gt;...&lt;/html&gt;</td><td width=20><td>Ein HTML-Dokument.</td></tr>
<tr><td>&lt;body&gt;...&lt;/body&gt;</td><td width=20><td>Der Inhalt eines HTML-Dokuments. Es versteht folgendes Attribut
<ul>
<li><tt>bgcolor</tt> - Die Hintergrundfarbe, z. B. <tt>bgcolor="yellow"</tt> oder <tt>bgcolor="#0000FF"</tt>.
                       Dieses Attribut wirkt nur innerhalb einer <a href=#359>dlgTextView</a>.
</ul>
</td></tr>
<tr><td>&lt;h1&gt;...&lt;/h1&gt;</td><td width=20><td>Eine Haupt-&Uuml;berschrift.</td></tr>
<tr><td>&lt;h2&gt;...&lt;/h2&gt;</td><td width=20><td>Eine untergeordnete &Uuml;berschrift.</td></tr>
<tr><td>&lt;h3&gt;...&lt;/h3&gt;</td><td width=20><td>Eine weiter untergeordnete &Uuml;berschrift.</td></tr>
<tr><td>&lt;p&gt;...&lt;/p&gt;</td><td width=20><td>Ein links-b&uuml;ndiger Abschnitt. Bestimmen Sie die Anordnung mit dem <tt>align</tt> Attribut. M&ouml;gliche Werte sind <tt>left</tt>, <tt>right</tt> und <tt>center</tt>.</td></tr>
<tr><td>&lt;center&gt;...&lt;/center&gt;</td><td width=20><td>Ein zentrierter Abschnitt.</td></tr>
<tr><td>&lt;blockquote&gt;...&lt;/blockquote&gt;</td><td width=20><td>Ein einger&uuml;ckter Abschnitt, sinnvoll f&uuml;r Zitate.</td></tr>
<tr><td>&lt;ul&gt;...&lt;/ul&gt;</td><td width=20><td>Eine ungeordnete Liste. Sie k&ouml;nnen auch ein type-Argument angeben um einen Bullet-Style zu definieren. Default ist <tt>type=disc</tt>,  andere Typen sind <tt>circle</tt> und <tt>square</tt>.</td></tr>
<tr><td>&lt;ol&gt;...&lt;/ol&gt;</td><td width=20><td>Eine geordnete Liste. Sie k&ouml;nnen auch ein type-Argument angeben um die Art der Nummerierung zu definieren. Default ist <tt>type="1"</tt>, andere Typen sind <tt>"a"</tt> und <tt>"A"</tt>.</td></tr>
<tr><td>&lt;li&gt;...&lt;/li&gt;</td><td width=20><td>Ein Punkt in einer Liste. Dieses Tag kann nur innerhalb eines <tt>ol</tt> oder <tt>ul</tt> Kontext verwendet werden.</td></tr>
<tr><td>&lt;pre&gt;...&lt;/pre&gt;</td><td width=20><td>F&uuml;r gr&ouml;&szlig;ere Mengen von Code. Leerzeichen im Inhalt bleiben erhalten. F&uuml;r kleinere Mengen Code, benutzen Sie den Inline-style <tt>code</tt>.</td></tr>
<tr><td>&lt;a&gt;...&lt;/a&gt;</td><td width=20><td>Ein Anker oder Link. Folgende Attribute sind erlaubt
<ul>
<li><tt>href</tt> - Das Referenz-Ziel wie in <tt>&lt;a href="target.html"&gt;...&lt;/a&gt;</tt>. Sie d&uuml;rfen auch einen zus&auml;tzlichen Anker innerhalb des angegebenen Ziel-Dokuments angeben, z. B. <tt>&lt;a href="target.html#123"&gt;...&lt;/a&gt;</tt>.
                    Falls Sie auf eine lokale Datei verlinken wollen, deren Name ein Leerzeichen enth&auml;lt, m&uuml;ssen Sie dem Dateinamen ein <tt>file:</tt> voranstellen, wie in <tt>&lt;a href="file:/path with blanks/target.html"&gt;...&lt;/a&gt;</tt>.
<li><tt>name</tt> - Der Anker-Name, wie in <tt>&lt;a name="123"&gt;...&lt;/a&gt;</tt>.
</ul>
</td></tr>
<tr><td>&lt;em&gt;...&lt;/em&gt;</td><td width=20><td>Emphasized (kursiv)(genauso wie <tt>&lt;i&gt;...&lt;/i&gt;</tt>).</td></tr>
<tr><td>&lt;strong&gt;...&lt;/strong&gt;</td><td width=20><td>Stark (genauso wie <tt>&lt;b&gt;...&lt;/b&gt;</tt>).</td></tr>
<tr><td>&lt;i&gt;...&lt;/i&gt;</td><td width=20><td>Kursiver Text.</td></tr>
<tr><td>&lt;b&gt;...&lt;/b&gt;</td><td width=20><td>Fetter Text.</td></tr>
<tr><td>&lt;u&gt;...&lt;/u&gt;</td><td width=20><td>Unterstrichener Text.</td></tr>
<tr><td>&lt;big&gt;...&lt;/big&gt;</td><td width=20><td>Eine gr&ouml;&szlig;ere Texth&ouml;he.</td></tr>
<tr><td>&lt;small&gt;...&lt;/small&gt;</td><td width=20><td>Eine kleinere Texth&ouml;he.</td></tr>
<tr><td>&lt;code&gt;...&lt;/code&gt;</td><td width=20><td>Kennzeichnet Code. (wie auch <tt>&lt;tt&gt;...&lt;/tt&gt;</tt>. F&uuml;r gr&ouml;&szlig;ere Mengen an Code, verwenden Sie das Block-Tag <tt>pre</tt>.</td></tr>
<tr><td>&lt;tt&gt;...&lt;/tt&gt;</td><td width=20><td>Typewriter Schriftart.</td></tr>
<tr><td>&lt;font&gt;...&lt;/font&gt;</td><td width=20><td>Zur Bestimmung von Texth&ouml;he, Schrift-Familie und Textfarbe. Das Tag versteht folgende Attribute:
<ul>
<li><tt>color</tt> - Die Textfarbe, z. B. <tt>color="red"</tt> oder <tt>color="#FF0000"</tt>.
<li><tt>size</tt> - Die logische Gr&ouml;&szlig;e der Schrift. Logische Gr&ouml;&szlig;en von 1 bis 7 werden unterst&uuml;tzt. Der Wert darf entweder absolut, z. B. <tt>size=3,</tt> oder relativ, wie <tt>size=-2</tt> sein. Im letzten Fall werden die Gr&ouml;&szlig;en einfach addiert.
<li><tt>face</tt> - Die Schriftart-Familie, z. B. <tt>face=times</tt>.
</ul>
</td></tr>
<tr><td>&lt;img...&gt;</td><td width=20><td>Ein Bild. Dieses Tag versteht die folgenden Attribute:
<ul>
<li><tt>src</tt> - Der Name des Bildes, z. B. <tt>&lt;img src="image.png"&gt;</tt>.<br>
Der URL des Bildes kann auch extern sein, wie in <tt>&lt;img src="http://www.cadsoft.de/cslogo.gif"&gt;</tt>.
<li><tt>width</tt> - Die Breite des Bildes. Passt das Bild nicht in die angegebene Gr&ouml;&szlig;e, wird es automatisch skaliert.
<li><tt>height</tt> - Die H&ouml;he des Bildes.
<li><tt>align</tt> - Bestimmt wo das Bild plaziert wird. Defaultm&auml;&szlig;ig wird ein Bild "inline" plaziert, genauso wie ein Buchstabe. Legen Sie <tt>left</tt> oder <tt>right</tt> fest, um das Bild an der entsprechenden Stelle zu plazieren.
</ul>
</td></tr>
<tr><td>&lt;hr&gt;</td><td width=20><td>Eine waagrechte Linie.</td></tr>
<tr><td>&lt;br&gt;</td><td width=20><td>Ein Zeilenumbruch.</td></tr>
<tr><td>&lt;nobr&gt;...&lt;/nobr&gt;</td><td width=20><td>Kein Zeilenumbruch.Erh&auml;lt "Word Wrap".</td></tr>
<tr><td>&lt;table&gt;...&lt;/table&gt;</td><td width=20><td>Eine Tabellen-Definition.
Die Standardtabelle ist ohne Rahmen. Geben Sie das boolesche Attribut
<tt>border</tt> an um einen Rahmen zu erhalten. Andere Attribute sind:
<ul>
<li><tt>bgcolor</tt> - Die Hintergrundfarbe.
<li> <tt>width</tt> - Die Tabellenbreite. Wird entweder in Pixel oder in Prozent der Spaltenbreite angegeben, z. B. <tt>width=80%</tt>.
<li> <tt>border</tt> - Die Breite des Tabellenrandes. Default ist 0 (= kein Rand).
<li> <tt>cellspacing</tt> - Zus&auml;tzlicher Leerraum um die Tabellenzelle. Default ist 2.
<li> <tt>cellpadding</tt> - Zus&auml;tzlicher Leerraum um den Inhalt einer Tabellenzelle. Default ist 1.
</ul>
</td></tr>
<tr><td>&lt;tr&gt;...&lt;/tr&gt;</td><td width=20><td>Eine Tabellen-Reihe. Kann nur mit <tt>table</tt> verwendet werden. Versteht die Attribute:
<ul>
<li><tt>bgcolor</tt> - Die Hintergrundfarbe.
</ul>
</td></tr>
<tr><td>&lt;td&gt;...&lt;/td&gt;</td><td width=20><td>Eine Zelle in einer Tabelle. Kann nur innerhalb <tt>tr</tt> verwendet werden.Versteht die Attribute:
<ul>
<li><tt>bgcolor</tt> - Die Hintergrundfarbe.
<li> <tt>width</tt> - Die Zellenbreite. Wird entweder in Pixel oder in Prozent der gesamten Tabellenbreite angegeben, z. B. <tt>width=50%</tt>.
<li> <tt>colspan</tt> - Legt fest wieviele Spalten diese Zelle belegt. Default ist 1.
<li> <tt>rowspan</tt> - Legt fest wieviele Reihen diese Zelle belegt. Default ist 1.
<li> <tt>align</tt> - Positionierung, m&ouml;gliche Angaben sind <tt>left</tt>, <tt>right</tt> und <tt>center</tt>. Default ist links-b&uuml;ndig.
</ul>
</td></tr>
<tr><td>&lt;th&gt;...&lt;/th&gt;</td><td width=20><td>Eine "Header"-Zelle in der Tabelle. Wie <tt>td</tt> aber als default mit zentrierter Ausrichtung und fetter Schriftart.</td></tr>
<tr><td>&lt;author&gt;...&lt;/author&gt;</td><td width=20><td>Markiert den Autor des Texts.</td></tr>
<tr><td>&lt;dl&gt;...&lt;/dl&gt;</td><td width=20><td>Eine Definitions-Liste.</td></tr>
<tr><td>&lt;dt&gt;...&lt;/dt&gt;</td><td width=20><td>Ein Definitions-Tag. Kann nur innerhalb <tt>dl</tt> verwendet werden.</td></tr>
<tr><td>&lt;dd&gt;...&lt;/dd&gt;</td><td width=20><td>Definitions-Daten. Kann nur innerhalb <tt>dl</tt> verwendet werden.</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Tag</b></td><td width=20><td><b>Bedeutung</b></td></tr>
<tr><td>&amp;lt;</td><td width=20><td>&lt;</td></tr>
<tr><td>&amp;gt;</td><td width=20><td>&gt;</td></tr>
<tr><td>&amp;amp;</td><td width=20><td>&amp;</td></tr>
<tr><td>&amp;nbsp;</td><td width=20><td>Leerzeichen ohne Umbruch</td></tr>
<tr><td>&amp;auml;</td><td width=20><td>&auml;</td></tr>
<tr><td>&amp;ouml;</td><td width=20><td>&ouml;</td></tr>
<tr><td>&amp;uuml;</td><td width=20><td>&uuml;</td></tr>
<tr><td>&amp;Auml;</td><td width=20><td>&Auml;</td></tr>
<tr><td>&amp;Ouml;</td><td width=20><td>&Ouml;</td></tr>
<tr><td>&amp;Uuml;</td><td width=20><td>&Uuml;</td></tr>
<tr><td>&amp;szlig;</td><td width=20><td>&szlig;</td></tr>
<tr><td>&amp;copy;</td><td width=20><td>&copy;</td></tr>
<tr><td>&amp;deg;</td><td width=20><td>&deg;</td></tr>
<tr><td>&amp;micro;</td><td width=20><td>&micro;</td></tr>
<tr><td>&amp;plusmn;</td><td width=20><td>&plusmn;</td></tr>
<tr><td>&amp;quot;</td><td width=20><td>&quot;</td></tr>
</table>


<a name=371>
<h1>Automatischer Backup</h1>
<h2>Maximum backup level</h2>
Der Write-Befehl erzeugt Backup-Kopien der gesicherten Dateien.
Sie haben denselben Namen wie die Originaldateien mit einer
modifizierten Extension, nach dem Muster
<pre>
.x#n
</pre>
Dabei steht f&uuml;r <tt>'x'</tt> der Buchstabe
<p>
<tt>b</tt> in Board-Dateien<br>
<tt>s</tt> in Schaltplan-Dateien<br>
<tt>l</tt> in Bibliotheks-Dateien
<p>
<tt>n</tt> steht f&uuml;r eine einstellige Zahl von
1..9. H&ouml;here Ziffern zeigen &auml;ltere Dateien an.
<p>
Die feste Position des Zeichens '#' erm&ouml;glicht das einfache L&ouml;schen
aller Backup-Dateien aus dem Betriebssystem heraus mit <b><tt>*.?#?</tt></b>
als "Wildcard".
<p>
Bitte beachten Sie, dass Backup-Dateien mit derselben Ziffer 'n'
nicht notwendigerweise konsistente Paare von Platinen- und
Schaltplan-Dateien repr&auml;sentieren.
<p>
Die maximale Zahl von Backup-Kopien kann im
<a href=#16>Backup-Dialog</a>
gesetzt werden.
<h2>Auto-Backup-Interval</h2>
Wurde eine Zeichnung modifiziert, wird automatisch nach der unter
<i>Auto backup interval</i> eingestellten Zeit eine Sicherungskopie
erstellt.
<p>
Diese Sicherungskopie erh&auml;lt den Namen nach folgendem Schema:
<pre>
.x##
</pre>
Dabei steht f&uuml;r <tt>'x'</tt> der Buchstabe
<p>
<tt>b</tt> in Board-Dateien<br>
<tt>s</tt> in Schaltplan-Dateien<br>
<tt>l</tt> in Bibliotheks-Dateien
<p>
Die Sicherheits-Backup-Datei wird nach einem erfolgreichen Abspeichern
der Zeichnung wieder gel&ouml;scht. Kann die Zeichnung nicht mit dem WRITE-Befehl
gespeichert werden (z. B. aufgrund eines Stromausfalls), benennen Sie
die Datei einfach um. So kann sie als normale Schaltplan-, Board- bzw.
Bibliotheksdatei wieder geladen werden.
<p>
Die Sicherungsintervall kann im <a href=#16>Backup-Dialog</a> gesetzt werden.


<a name=372>
<h1>Forward&amp;Back-Annotation</h1>
Eine Schaltplandatei und die zugeh&ouml;rigen Platinendatei sind durch
automatische Forward&amp;Back-Annotation logisch verkn&uuml;pft. Der Benutzer muss
sich darum normalerweise nicht k&uuml;mmern. Dennoch wird in diesem Abschnitt
beschrieben, was genau bei der Forward&amp;Back-Annotation geschieht:
<ul>
<li>Holt man ein neues Bauteil in den Schaltplan, so wird das zugeh&ouml;rige
Package in der linken unteren Ecke der Platinenzeichnung plaziert.
Enth&auml;lt das Bauteil Pins mit der Direction "Pwr", dann werden die
zugeh&ouml;rigen Pads automatisch mit dem entsprechenden Versorgungssignal
verbunden.
<li>Wird ein Bauteil aus einem Schaltplan gel&ouml;scht, so wird das
zugeh&ouml;rige Package auch aus der Platine gel&ouml;scht. Wires, die mit dem
Package verbunden waren, bleiben unber&uuml;hrt. Unter Unst&auml;nden sind
zus&auml;tzliche Vias erforderlich, um diese Signale an den Stellen zu
verbinden, an denen sich die Pads des gel&ouml;schten Bauteils befunden
haben.
<li>L&ouml;scht man ein Bauteil aus einer Platine, werden alle "Gates", die
sich in diesem Bauteil befinden, aus dem Schaltplan gel&ouml;scht. Dies kann
unterschiedliche Seiten betreffen, falls die "Gates" auf mehrere Seiten
verteilt waren.
<li>Nach einer Operation, die ein Pad von einem Signal entfernt bzw. es zu
einem Signal hinzuf&uuml;gt, das Polygone enth&auml;lt, kann die Anzeige der
Anschl&uuml;sse an das Polygon fehlerhaft sein. Der <a href=#86>RATSNEST</a>-Befehl korrigiert
die Anzeige. Derselbe Effekt kann bei Undo-/Redo-Operationen auftreten,
die sich auf Pads beziehen welche mit Signalen verbinden sind, die Polygone enthalten.
<li>Die Befehle Pinswap und Gateswap im Schaltplan sorgen daf&uuml;r, dass
alle notwendigen &Auml;nderungen auch im Board durchgef&uuml;hrt werden.
Allerdings k&ouml;nnen die Wires anschlie&szlig;end die Design Rules verletzen. Der
Benutzer sollte deshalb nach diesen Befehlen die Platine entsprechend
editieren.
<li>Um sicherzustellen, dass eine Platine und ein Schaltplan
zusammengeh&ouml;ren (und &uuml;ber Forward&amp;Back-Annotation verbunden sind),
m&uuml;ssen die beiden Dateien denselben Namen (mit Extensions .brd und .sch)
haben und im gleichen Verzeichnis gespeichert sein.
<li>Der Replace-Befehl pr&uuml;ft, ob alle Pads des alten Package, die einem
Pin zugewiesen waren, auch im neuen Package vorhanden sind - unabh&auml;ngig
davon, ob sie mit einem Signal verbunden sind oder nicht.
<li>Liegen die Pins zweier Schaltplan-Symbole &uuml;bereinander (Verbindung
ohne sichtbare Netz-Linie), dann wird eine Netz-Linie erzeugt, wenn
eines der Bauteile wegbewegt wird. Damit wird eine unn&ouml;tige
Ripup-Operation im Board vermieden.
</ul>


<a name=373>
<h1>Konsistenzpr&uuml;fung</h1>
Damit die Forward&amp;Back-Annotation wirksam werden kann, m&uuml;ssen
Platine und Schaltplan konsistent sein. Das heisst, sie m&uuml;ssen &auml;quivalente
Bauteile und Netze bzw. Signale enthalten.
<p>
Unter normalen Umst&auml;nden sind Platine und Schaltplan immer konsistent,
sofern sie nicht separat editiert worden sind (in diesem Fall
w&uuml;rden Sie mit der Meldung
<i>Die Forward&amp;Back-Annotation ist nicht aktiv!</i>
gewarnt worden sein).
<p>
Wenn ein Platinen/Schaltplan-Paar geladen wird, &uuml;berpr&uuml;ft das Programm
Konsistenzmarkierungen in den Dateien, um zu sehen, ob sie noch
konsistent sind. Weisen diese Markierungen auf eine Inkonsistenz hin,
dann bietet Ihnen das Programm an, einen
<a href=#50>Electrical Rule Check</a> (ERC) auszuf&uuml;hren,
der beide Dateien &uuml;berpr&uuml;ft.
<p>
F&auml;llt die Pr&uuml;fung positiv aus, werden die Dateien als konsistent markiert,
und die Forward&amp;Back-Annotation wird aktiviert.
<p>
Werden die Dateien als inkonsistent erkannt, erscheint das ERC-Protokoll
in einem Dialog und die Forward&amp;Back-Annotation wird
<b>nicht</b> aktiviert.
<p>
<b>Bitte erschrecken Sie nicht, wenn zahlreiche Fehlermeldungen
erscheinen. In den meisten F&auml;llen reduziert schon eine einzige Korrektur
(wie die Umbenennung eines Netzes) die Zahl der Meldungen f&uuml;r den
n&auml;chsten Durchlauf erheblich.</b>
<h2>Platine und Schaltplan konsistent machen</h2>
Um ein inkonsistentes Schaltplan-/Platinen-Paar konsistent zu machen,
m&uuml;ssem Sie alle im ERC-Protokoll aufgef&uuml;hrten Inkonsistenzen manuell
beseitigen.
Das kann mit Hilfe der Editor-Befehle wie
<a href=#72>NAME</a>,
<a href=#108>VALUE</a>,
<a href=#80>PINSWAP</a>,
<a href=#91>REPLACE</a> etc. erreicht werden.
Nach der Korrektur m&uuml;ssen Sie den
<a href=#50>ERC</a>-Befehl nochmals verwenden,
um die Dateien zu &uuml;berpr&uuml;fen und um die Forward&amp;Back-Annotation aktivieren
zu k&ouml;nnen.
<h3>Hinweis Attribute:</h3>
Namen und Werte von Attributen k&ouml;nnen mit <a href=#33>ATTRIBUTE</a> zur
Konsistenzherstellung angepa&szlig;t werden.
Handelt es sich um Bibliotheks-Attribute, kann ein Austausch der Devices f&uuml;r die betroffenen Bauteile
mit REPLACE im Schaltplan erforderlich sein.
<h3>Hinweis Packagevarianten:</h3>
Hier gibt es mehrere Ans&auml;tze:
<ul>
<li>Austausch der Packages f&uuml;r die betroffenen Elemente mit <a href=#91>REPLACE</a> im Board.
Ersetzen mit den Packages gem&auml;&szlig; der Definition im Schaltplan.</li>
<li>Austausch der Devices f&uuml;r die betroffenen Bauteile mit <a href=#91>REPLACE</a> im Schaltplan.
Ersetzen mit den Packages gem&auml;&szlig; der Definition im Board. Achten Sie dabei auch auf m&ouml;gliche &Auml;nderungen bei den Attributen.</li>
<li>Austausch der Packagevarianten im Schaltplan mit <a href=#37>CHANGE PACKAGE</a>.</li>


<a name=374>
<h1>Einschr&auml;nkungen</h1>
Folgende Aktionen sind in einer Platine nicht erlaubt, wenn die
Back-Annotation aktiv ist, wenn also der Schaltplan ebenfalls geladen ist:
<ul>
<li>Bauteil hinzuf&uuml;gen (ADD) oder kopieren, das Pads oder Smds enth&auml;lt
<li>Luftlinie l&ouml;schen
<li>Verbindungen mit dem Signal-Befehl definieren
<li>Schaltplanteile mit Paste von einem Board in ein Board kopieren,
wenn darin Pads, Smds oder verbundene Signale enthalten sind
</ul>
Sollten Sie eine dieser Operationen auszuf&uuml;hren versuchen, dann erhalten
Sie eine Meldung, dass dies unter Kontrolle der Back-Annotation nicht
m&ouml;glich ist. Bitte f&uuml;hren Sie die Operation dann im Schaltplan aus, sie
wird dann automatisch in die Platine &uuml;bernommen. Sollten Sie die
Operation dennoch im Board ausf&uuml;hren wollen, m&uuml;ssen Sie das
Schaltplan-Fenster schlie&szlig;en. In diesem Fall sind Schaltplan und Board
aber nicht mehr konsistent!


<a name=375>
<h1>Technische Unterst&uuml;tzung</h1>
Als registrierter EAGLE-Benutzer erhalten Sie von CadSoft kostenlose
technische Unterst&uuml;tzung. Es gibt folgende M&ouml;glichkeiten, uns zu
erreichen oder die neuesten Programmversionen, Bibliotheken und Treiber
zu erhalten:
<p>
CadSoft Computer GmbH<br>
Pleidolfweg 15<br>
84568 Pleiskirchen<br>
Deutschland
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Vertrieb      </td><td width=20><td>08635-6989-10</td></tr>
<tr><td>Hotline       </td><td width=20><td>08635-6989-30</td></tr>
<tr><td>Fax           </td><td width=20><td>08635-6989-40</td></tr>
<tr><td>Email         </td><td width=20><td><a href="mailto:support@cadsoft.de">support@cadsoft.de</a></td></tr>
<tr><td>URL           </td><td width=20><td><a href="http://www.cadsoft.de">www.cadsoft.de</a></td></tr>
</table>


<a name=376>
<h1>Lizenz</h1>
Als legaler EAGLE-Benutzer m&uuml;ssen Sie im Besitz einer registrierten
Benutzer-Lizenz sein. Bitte &uuml;berpr&uuml;fen Sie, ob im Dialog "Hilfe/&Uuml;ber EAGLE"
unter "Lizenziert auf:" Ihr Name und Ihre Anschrift eingetragen ist.
Sollten Sie Zweifel an der Echtheit Ihrer Lizenz
haben, setzen Sie sich bitte mit unserem
<a href=#375>Support-Personal</a>
in Verbindung.
<table><tr><td valign="top"><img src="platforms-mac.png"></td><td valign="middle">
Unter <b>Mac OS X</b> finden Sie diese Angaben unter "EAGLE/&Uuml;ber EAGLE".
</td></tr></table>
<p>
Es gibt verschiedene Lizenz-Typen, die sich darin unterscheiden,
wie viele Benutzer erlaubt sind und wo das Programm verwendet werden
darf.
<h2>Einzelplatz-Lizenz</h2>
Nur <b>ein</b> Benutzer darf das Programm zu einer bestimmten Zeit
benutzen. Der Benutzer darf das Programm allerdings auf
unterschiedlichen Computern installieren, solange er sicherstellt, dass
nur eine Programmkopie gleichzeitig verwendet wird.
<p>
Ein typischer Anwender einer Einzelplatz-Lizenz ist jemand, der
einen fest installierten PC und zus&auml;tzlich einen Notebook-Computer hat,
den er unterwegs benutzt. Da er immer nur einen Computer benutzt, reicht
die Einzelplatz-Lizenz aus.
<h2>Mehrbenutzer-Lizenz</h2>
Eine Mehrbenutzer-Lizenz darf von mehreren Benutzern (bis zu der auf der
Lizenz angegebenen maximalen Anzahl) gleichzeitig benutzt werden.
Das Programm darf auf beliebig vielen unterschiedlichen
Computern am Standort des Lizenznehmers installiert sein.
<h2>Commercial License</h2>
Das Programm darf f&uuml;r jeden Zweck verwendet werden, kommerziell oder
privat.
<h2>Educational License</h2>
Das Programm darf ausschlie&szlig;lich in Ausbildungsst&auml;tten wie Schulen,
Universit&auml;ten oder Lehrwerkst&auml;tten zu Ausbildungszwecken verwendet
werden.
<h2>Student License</h2>
Das Programm darf ausschlie&szlig;lich f&uuml;r private Zwecke verwendet werden.
Jede kommerzielle Anwendung ist untersagt. Es stellt eine Verletzung der
Lizenzbedingungen dar, wenn Sie durch Gebrauch einer Studentenversion
Geld verdienen.


<a name=377>
<h1>EAGLE-Lizenz</h1>
Bevor Sie mit EAGLE arbeiten k&ouml;nnen, m&uuml;ssen Sie dem Programm Ihre
pers&ouml;nlichen Lizenzdaten "mitteilen".
<p>
Hierzu geben Sie im Dialog "EAGLE Lizenz" den Dateinamen Ihrer EAGLE-Lizenzdatei ein,
sowie den dazugeh&ouml;rigen Installations-Code, den Sie zusammen mit der Lizenzdatei
erhalten haben (dieser Code besteht aus zehn Kleinbuchstaben).
<p>
Nach dem Bet&auml;tigen der Enter-Taste oder dem Anklicken des
<b>OK</b>-Buttons
ist EAGLE mit Ihren pers&ouml;nlichen Lizenzdaten installiert.
<p>
Wenn Sie Probleme mit der Installation haben oder &uuml;ber die
G&uuml;ltigkeit Ihrer Lizenz im Zweifel sind, setzen Sie sich bitte mit
unserem
<a href=#375>Technischen Support</a> in Verbindung.
<h2>Nachtr&auml;gliches Installieren von Modulen</h2>
Soll die Lizenz um das Schaltplan-/Autorouter-Modul erweitert werden,
erhalten Sie von uns eine neue Lizenzdatei mit einem
neuen Installations-Code, welche Sie dem Programm mitteilen m&uuml;ssen.
Dazu starten Sie das EAGLE-Programm und w&auml;hlen im <a href=#13>Control Panel</a>
im Hilfe-Men&uuml; den Eintrag <i>EAGLE Lizenz</i>.


<a name=378>
<h1>EAGLE-Editionen</h1>
EAGLE ist in drei verschiedenen Editionen verf&uuml;gbar, um den
Anspr&uuml;chen verschiedener Benutzergruppen gerecht zu werden.
<h2>Professional</h2>
Die <i>Professional</i> Edition stellt die volle Funktionalit&auml;t zur Verf&uuml;gung:
<ul>
<li>Platinenfl&auml;che bis zu 4000x4000mm (157x157inch)
<li>bis zu 16 Signallayer
<li>bis zu 999 Schaltplanseiten
</ul>
<h2>Standard</h2>
Die <i>Standard</i> Edition besitzt folgende Einschr&auml;nkungen:
<ul>
<li>die Platinenfl&auml;che ist auf 160x100mm (6.3x4inch) beschr&auml;nkt, was einer ganzen Europakarte entspricht
<li>es stehen nur sechst Signallayer (Top, Route2, Route3, Route14, Route15 und Bottom) zur Verf&uuml;gung
<li>ein Schaltplan kann aus bis zu 99 Seiten bestehen
</ul>
<h2>Light</h2>
Die <i>Light</i> Edition besitzt folgende Einschr&auml;nkungen:
<ul>
<li>die Platinenfl&auml;che ist auf 100x80mm (4x3.2inch) beschr&auml;nkt, was einer halben Europakarte entspricht
<li>es stehen nur zwei Signal-Layer (Top und Bottom) zur Verf&uuml;gung
<li>ein Schaltplan kann nur aus einer einzelnen Seite bestehen
</ul>
<h2>Freemium</h2>
Die <i>Freemium</i> Edition ist eine <i>Free Premium</i> Edition, deren Eigenschaften
zwischen denen der <i>Light</i> und der <i>Standard</i> Editionen angesiedelt sind.
Die Freemium Edition ist nur nach Registrierung auf <a href="http://www.element-14.com/eagle-freemium">http://www.element-14.com/eagle-freemium</a>
erh&auml;ltlich und hat folgende Einschr&auml;nkungen:
<ul>
<li>die Platinenfl&auml;che ist auf 100x80mm (4x3.2inch) beschr&auml;nkt, was einer halben Europakarte entspricht
<li>es stehen nur vier Signal-Layer (Top, Route2, Route15 und Bottom) zur Verf&uuml;gung
<li>ein Schaltplan kann nur aus vier Seiten bestehen
<li>eine Freemium-Lizenz ist auf einen einzelnen Benutzer und Computer beschr&auml;nkt und erfordert
    eine aktive Verbindung zum Internet um zu funktionieren; sie l&auml;uft 60 Tage nach
    der Installation ab
</ul>
<p>
Falls Sie eine Fehlermeldung der Form
<p>
<i>Die Light-Edition von EAGLE kann die gew&uuml;nschte Aktion nicht ausf&uuml;hren!</i>
<p>
erhalten, so bedeutet dies, dass Sie versucht haben, etwas zu tun, das
im Widerspruch zu den Einschr&auml;nkungen der benutzten EAGLE-Edition steht,
wie etwa ein Bauteil ausserhalb der zul&auml;ssigen Fl&auml;che zu plazieren.
<p>
Alle Editionen von EAGLE
sind in der Lage, Dateien zu laden, die mit der <i>Standard</i> oder <i>Professional</i>
Edition erzeugt wurden, selbst wenn diese Zeichnungen die Editier-M&ouml;glichkeiten
der verwendeten Edition &uuml;bersteigen.
<p>
Um zu sehen, welcher Edition Ihre Lizenz entspricht, w&auml;hlen Sie
<i>Hilfe/&Uuml;ber EAGLE</i> aus dem Men&uuml; des Control Panels.

</body>
</html>
